/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.12
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

#include "CSparseMatrix_internal.h" // must be before NumericsMatrix.h
#include "relay_cst.h"
#include "AVI_cst.h"
#include "SOCLCP_cst.h"
#include "Friction_cst.h"
#include "lcp_cst.h"
#include "MCP_cst.h"
#include "NCP_cst.h"
#include "mlcp_cst.h"
#include "VI_cst.h"
#include "ConvexQP_cst.h"
#include "GenericMechanical_cst.h"
#include "fc2d_Solvers.h"
#include "fc3d_Solvers.h"
#include "gfc3d_Solvers.h"
#include "MCP_Solvers.h"
#include "NCP_Solvers.h"
#include "MLCP_Solvers.h"
#include "ConvexQP_Solvers.h"
#include "SiconosCompat.h"
#include "SOCLCP_Solvers.h"
#include "NonSmoothDrivers.h"
  


#ifndef SWIGPYTHON
#define SWIGPYTHON
#endif

#define SWIG_PYTHON_DIRECTOR_NO_VTABLE

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if defined(__GNUC__)
#  if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#    ifndef GCC_HASCLASSVISIBILITY
#      define GCC_HASCLASSVISIBILITY
#    endif
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif

/* Deal with Apple's deprecated 'AssertMacros.h' from Carbon-framework */
#if defined(__APPLE__) && !defined(__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES)
# define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
#endif

/* Intel's compiler complains if a variable which was never initialised is
 * cast to void, which is a common idiom which we use to indicate that we
 * are aware a variable isn't used.  So we just silence that warning.
 * See: https://github.com/swig/swig/issues/192 for more discussion.
 */
#ifdef __INTEL_COMPILER
# pragma warning disable 592
#endif


#if defined(_DEBUG) && defined(SWIG_PYTHON_INTERPRETER_NO_DEBUG)
/* Use debug wrappers with the Python release dll */
# undef _DEBUG
# include <Python.h>
# define _DEBUG
#else
# include <Python.h>
#endif

/* -----------------------------------------------------------------------------
 * swigrun.swg
 *
 * This file contains generic C API SWIG runtime support for pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "4"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the SWIG runtime code.
  In 99.9% of the cases, SWIG just needs to declare them as 'static'.

  But only do this if strictly necessary, ie, if you have problems
  with your compiler or suchlike.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

/*  Generic buffer size */
#ifndef SWIG_BUFFER_SIZE
# define SWIG_BUFFER_SIZE 1024
#endif

/* Flags for pointer conversions */
#define SWIG_POINTER_DISOWN        0x1
#define SWIG_CAST_NEW_MEMORY       0x2

/* Flags for new pointer objects */
#define SWIG_POINTER_OWN           0x1


/*
   Flags/methods for returning states.

   The SWIG conversion methods, as ConvertPtr, return an integer
   that tells if the conversion was successful or not. And if not,
   an error code can be returned (see swigerrors.swg for the codes).

   Use the following macros/flags to set or process the returning
   states.

   In old versions of SWIG, code such as the following was usually written:

     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
       // success code
     } else {
       //fail code
     }

   Now you can be more explicit:

    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
    } else {
      // fail code
    }

   which is the same really, but now you can also do

    Type *ptr;
    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
      if (SWIG_IsNewObj(res) {
        ...
	delete *ptr;
      } else {
        ...
      }
    } else {
      // fail code
    }

   I.e., now SWIG_ConvertPtr can return new objects and you can
   identify the case and take care of the deallocation. Of course that
   also requires SWIG_ConvertPtr to return new result values, such as

      int SWIG_ConvertPtr(obj, ptr,...) {
        if (<obj is ok>) {
          if (<need new object>) {
            *ptr = <ptr to new allocated object>;
            return SWIG_NEWOBJ;
          } else {
            *ptr = <ptr to old object>;
            return SWIG_OLDOBJ;
          }
        } else {
          return SWIG_BADOBJ;
        }
      }

   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
   SWIG errors code.

   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
   allows to return the 'cast rank', for example, if you have this

       int food(double)
       int fooi(int);

   and you call

      food(1)   // cast rank '1'  (1 -> 1.0)
      fooi(1)   // cast rank '0'

   just use the SWIG_AddCast()/SWIG_CheckState()
*/

#define SWIG_OK                    (0)
#define SWIG_ERROR                 (-1)
#define SWIG_IsOK(r)               (r >= 0)
#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)

/* The CastRankLimit says how many bits are used for the cast rank */
#define SWIG_CASTRANKLIMIT         (1 << 8)
/* The NewMask denotes the object was created (using new/malloc) */
#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
/* The TmpMask is for in/out typemaps that use temporal objects */
#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
/* Simple returning values */
#define SWIG_BADOBJ                (SWIG_ERROR)
#define SWIG_OLDOBJ                (SWIG_OK)
#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
/* Check, add and del mask methods */
#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))

/* Cast-Rank Mode */
#if defined(SWIG_CASTRANK_MODE)
#  ifndef SWIG_TypeRank
#    define SWIG_TypeRank             unsigned long
#  endif
#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
#    define SWIG_MAXCASTRANK          (2)
#  endif
#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
SWIGINTERNINLINE int SWIG_AddCast(int r) {
  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
}
SWIGINTERNINLINE int SWIG_CheckState(int r) {
  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0;
}
#else /* no cast-rank mode */
#  define SWIG_AddCast(r) (r)
#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
#endif


#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *, int *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store information on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
  int                    owndata;		/* flag if the structure owns the clientdata */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;

/*
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
  }
  return (int)((l1 - f1) - (l2 - f2));
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCmp(const char *nb, const char *tb) {
  int equiv = 1;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (equiv != 0 && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = SWIG_TypeNameComp(nb, ne, tb, te);
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  return SWIG_TypeCmp(nb, tb) == 0 ? 1 : 0;
}

/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (strcmp(iter->type->name, c) == 0) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (iter->type == from) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
}

/*
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (!type) return NULL;
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/*
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;

  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }
    cast = cast->next;
  }
}
SWIGRUNTIME void
SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientData(ti, clientdata);
  ti->owndata = 1;
}

/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start,
                            swig_module_info *end,
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      size_t l = 0;
      size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	size_t i = (l + r) >> 1;
	const char *iname = iter->types[i]->name;
	if (iname) {
	  int compare = strcmp(name, iname);
	  if (compare == 0) {
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start,
                     swig_module_info *end,
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }

  /* neither found a match */
  return 0;
}

/*
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  const unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/*
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    char d = *(c++);
    unsigned char uu;
    if ((d >= '0') && (d <= '9'))
      uu = (unsigned char)((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = (unsigned char)((d - ('a'-10)) << 4);
    else
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (unsigned char)(d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (unsigned char)(d - ('a'-10));
    else
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/*
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/*  Errors in SWIG */
#define  SWIG_UnknownError    	   -1
#define  SWIG_IOError        	   -2
#define  SWIG_RuntimeError   	   -3
#define  SWIG_IndexError     	   -4
#define  SWIG_TypeError      	   -5
#define  SWIG_DivisionByZero 	   -6
#define  SWIG_OverflowError  	   -7
#define  SWIG_SyntaxError    	   -8
#define  SWIG_ValueError     	   -9
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12
#define  SWIG_NullReferenceError   -13



/* Compatibility macros for Python 3 */
#if PY_VERSION_HEX >= 0x03000000

#define PyClass_Check(obj) PyObject_IsInstance(obj, (PyObject *)&PyType_Type)
#define PyInt_Check(x) PyLong_Check(x)
#define PyInt_AsLong(x) PyLong_AsLong(x)
#define PyInt_FromLong(x) PyLong_FromLong(x)
#define PyInt_FromSize_t(x) PyLong_FromSize_t(x)
#define PyString_Check(name) PyBytes_Check(name)
#define PyString_FromString(x) PyUnicode_FromString(x)
#define PyString_Format(fmt, args)  PyUnicode_Format(fmt, args)
#define PyString_AsString(str) PyBytes_AsString(str)
#define PyString_Size(str) PyBytes_Size(str)	
#define PyString_InternFromString(key) PyUnicode_InternFromString(key)
#define Py_TPFLAGS_HAVE_CLASS Py_TPFLAGS_BASETYPE
#define PyString_AS_STRING(x) PyUnicode_AS_STRING(x)
#define _PyLong_FromSsize_t(x) PyLong_FromSsize_t(x)

#endif

#ifndef Py_TYPE
#  define Py_TYPE(op) ((op)->ob_type)
#endif

/* SWIG APIs for compatibility of both Python 2 & 3 */

#if PY_VERSION_HEX >= 0x03000000
#  define SWIG_Python_str_FromFormat PyUnicode_FromFormat
#else
#  define SWIG_Python_str_FromFormat PyString_FromFormat
#endif


/* Warning: This function will allocate a new string in Python 3,
 * so please call SWIG_Python_str_DelForPy3(x) to free the space.
 */
SWIGINTERN char*
SWIG_Python_str_AsChar(PyObject *str)
{
#if PY_VERSION_HEX >= 0x03000000
  char *cstr;
  char *newstr;
  Py_ssize_t len;
  str = PyUnicode_AsUTF8String(str);
  PyBytes_AsStringAndSize(str, &cstr, &len);
  newstr = (char *) malloc(len+1);
  memcpy(newstr, cstr, len+1);
  Py_XDECREF(str);
  return newstr;
#else
  return PyString_AsString(str);
#endif
}

#if PY_VERSION_HEX >= 0x03000000
#  define SWIG_Python_str_DelForPy3(x) free( (void*) (x) )
#else
#  define SWIG_Python_str_DelForPy3(x) 
#endif


SWIGINTERN PyObject*
SWIG_Python_str_FromChar(const char *c)
{
#if PY_VERSION_HEX >= 0x03000000
  return PyUnicode_FromString(c); 
#else
  return PyString_FromString(c);
#endif
}

/* Add PyOS_snprintf for old Pythons */
#if PY_VERSION_HEX < 0x02020000
# if defined(_MSC_VER) || defined(__BORLANDC__) || defined(_WATCOM)
#  define PyOS_snprintf _snprintf
# else
#  define PyOS_snprintf snprintf
# endif
#endif

/* A crude PyString_FromFormat implementation for old Pythons */
#if PY_VERSION_HEX < 0x02020000

#ifndef SWIG_PYBUFFER_SIZE
# define SWIG_PYBUFFER_SIZE 1024
#endif

static PyObject *
PyString_FromFormat(const char *fmt, ...) {
  va_list ap;
  char buf[SWIG_PYBUFFER_SIZE * 2];
  int res;
  va_start(ap, fmt);
  res = vsnprintf(buf, sizeof(buf), fmt, ap);
  va_end(ap);
  return (res < 0 || res >= (int)sizeof(buf)) ? 0 : PyString_FromString(buf);
}
#endif

#ifndef PyObject_DEL
# define PyObject_DEL PyObject_Del
#endif

/* A crude PyExc_StopIteration exception for old Pythons */
#if PY_VERSION_HEX < 0x02020000
# ifndef PyExc_StopIteration
#  define PyExc_StopIteration PyExc_RuntimeError
# endif
# ifndef PyObject_GenericGetAttr
#  define PyObject_GenericGetAttr 0
# endif
#endif

/* Py_NotImplemented is defined in 2.1 and up. */
#if PY_VERSION_HEX < 0x02010000
# ifndef Py_NotImplemented
#  define Py_NotImplemented PyExc_RuntimeError
# endif
#endif

/* A crude PyString_AsStringAndSize implementation for old Pythons */
#if PY_VERSION_HEX < 0x02010000
# ifndef PyString_AsStringAndSize
#  define PyString_AsStringAndSize(obj, s, len) {*s = PyString_AsString(obj); *len = *s ? strlen(*s) : 0;}
# endif
#endif

/* PySequence_Size for old Pythons */
#if PY_VERSION_HEX < 0x02000000
# ifndef PySequence_Size
#  define PySequence_Size PySequence_Length
# endif
#endif

/* PyBool_FromLong for old Pythons */
#if PY_VERSION_HEX < 0x02030000
static
PyObject *PyBool_FromLong(long ok)
{
  PyObject *result = ok ? Py_True : Py_False;
  Py_INCREF(result);
  return result;
}
#endif

/* Py_ssize_t for old Pythons */
/* This code is as recommended by: */
/* http://www.python.org/dev/peps/pep-0353/#conversion-guidelines */
#if PY_VERSION_HEX < 0x02050000 && !defined(PY_SSIZE_T_MIN)
typedef int Py_ssize_t;
# define PY_SSIZE_T_MAX INT_MAX
# define PY_SSIZE_T_MIN INT_MIN
typedef inquiry lenfunc;
typedef intargfunc ssizeargfunc;
typedef intintargfunc ssizessizeargfunc;
typedef intobjargproc ssizeobjargproc;
typedef intintobjargproc ssizessizeobjargproc;
typedef getreadbufferproc readbufferproc;
typedef getwritebufferproc writebufferproc;
typedef getsegcountproc segcountproc;
typedef getcharbufferproc charbufferproc;
static long PyNumber_AsSsize_t (PyObject *x, void *SWIGUNUSEDPARM(exc))
{
  long result = 0;
  PyObject *i = PyNumber_Int(x);
  if (i) {
    result = PyInt_AsLong(i);
    Py_DECREF(i);
  }
  return result;
}
#endif

#if PY_VERSION_HEX < 0x02050000
#define PyInt_FromSize_t(x) PyInt_FromLong((long)x)
#endif

#if PY_VERSION_HEX < 0x02040000
#define Py_VISIT(op)				\
  do { 						\
    if (op) {					\
      int vret = visit((op), arg);		\
      if (vret)					\
        return vret;				\
    }						\
  } while (0)
#endif

#if PY_VERSION_HEX < 0x02030000
typedef struct {
  PyTypeObject type;
  PyNumberMethods as_number;
  PyMappingMethods as_mapping;
  PySequenceMethods as_sequence;
  PyBufferProcs as_buffer;
  PyObject *name, *slots;
} PyHeapTypeObject;
#endif

#if PY_VERSION_HEX < 0x02030000
typedef destructor freefunc;
#endif

#if ((PY_MAJOR_VERSION == 2 && PY_MINOR_VERSION > 6) || \
     (PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION > 0) || \
     (PY_MAJOR_VERSION > 3))
# define SWIGPY_USE_CAPSULE
# define SWIGPY_CAPSULE_NAME ((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION ".type_pointer_capsule" SWIG_TYPE_TABLE_NAME)
#endif

#if PY_VERSION_HEX < 0x03020000
#define PyDescr_TYPE(x) (((PyDescrObject *)(x))->d_type)
#define PyDescr_NAME(x) (((PyDescrObject *)(x))->d_name)
#define Py_hash_t long
#endif

/* -----------------------------------------------------------------------------
 * error manipulation
 * ----------------------------------------------------------------------------- */

SWIGRUNTIME PyObject*
SWIG_Python_ErrorType(int code) {
  PyObject* type = 0;
  switch(code) {
  case SWIG_MemoryError:
    type = PyExc_MemoryError;
    break;
  case SWIG_IOError:
    type = PyExc_IOError;
    break;
  case SWIG_RuntimeError:
    type = PyExc_RuntimeError;
    break;
  case SWIG_IndexError:
    type = PyExc_IndexError;
    break;
  case SWIG_TypeError:
    type = PyExc_TypeError;
    break;
  case SWIG_DivisionByZero:
    type = PyExc_ZeroDivisionError;
    break;
  case SWIG_OverflowError:
    type = PyExc_OverflowError;
    break;
  case SWIG_SyntaxError:
    type = PyExc_SyntaxError;
    break;
  case SWIG_ValueError:
    type = PyExc_ValueError;
    break;
  case SWIG_SystemError:
    type = PyExc_SystemError;
    break;
  case SWIG_AttributeError:
    type = PyExc_AttributeError;
    break;
  default:
    type = PyExc_RuntimeError;
  }
  return type;
}


SWIGRUNTIME void
SWIG_Python_AddErrorMsg(const char* mesg)
{
  PyObject *type = 0;
  PyObject *value = 0;
  PyObject *traceback = 0;

  if (PyErr_Occurred()) PyErr_Fetch(&type, &value, &traceback);
  if (value) {
    char *tmp;
    PyObject *old_str = PyObject_Str(value);
    PyErr_Clear();
    Py_XINCREF(type);

    PyErr_Format(type, "%s %s", tmp = SWIG_Python_str_AsChar(old_str), mesg);
    SWIG_Python_str_DelForPy3(tmp);
    Py_DECREF(old_str);
    Py_DECREF(value);
  } else {
    PyErr_SetString(PyExc_RuntimeError, mesg);
  }
}

#if defined(SWIG_PYTHON_NO_THREADS)
#  if defined(SWIG_PYTHON_THREADS)
#    undef SWIG_PYTHON_THREADS
#  endif
#endif
#if defined(SWIG_PYTHON_THREADS) /* Threading support is enabled */
#  if !defined(SWIG_PYTHON_USE_GIL) && !defined(SWIG_PYTHON_NO_USE_GIL)
#    if (PY_VERSION_HEX >= 0x02030000) /* For 2.3 or later, use the PyGILState calls */
#      define SWIG_PYTHON_USE_GIL
#    endif
#  endif
#  if defined(SWIG_PYTHON_USE_GIL) /* Use PyGILState threads calls */
#    ifndef SWIG_PYTHON_INITIALIZE_THREADS
#     define SWIG_PYTHON_INITIALIZE_THREADS  PyEval_InitThreads() 
#    endif
#    ifdef __cplusplus /* C++ code */
       class SWIG_Python_Thread_Block {
         bool status;
         PyGILState_STATE state;
       public:
         void end() { if (status) { PyGILState_Release(state); status = false;} }
         SWIG_Python_Thread_Block() : status(true), state(PyGILState_Ensure()) {}
         ~SWIG_Python_Thread_Block() { end(); }
       };
       class SWIG_Python_Thread_Allow {
         bool status;
         PyThreadState *save;
       public:
         void end() { if (status) { PyEval_RestoreThread(save); status = false; }}
         SWIG_Python_Thread_Allow() : status(true), save(PyEval_SaveThread()) {}
         ~SWIG_Python_Thread_Allow() { end(); }
       };
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   SWIG_Python_Thread_Block _swig_thread_block
#      define SWIG_PYTHON_THREAD_END_BLOCK     _swig_thread_block.end()
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   SWIG_Python_Thread_Allow _swig_thread_allow
#      define SWIG_PYTHON_THREAD_END_ALLOW     _swig_thread_allow.end()
#    else /* C code */
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   PyGILState_STATE _swig_thread_block = PyGILState_Ensure()
#      define SWIG_PYTHON_THREAD_END_BLOCK     PyGILState_Release(_swig_thread_block)
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   PyThreadState *_swig_thread_allow = PyEval_SaveThread()
#      define SWIG_PYTHON_THREAD_END_ALLOW     PyEval_RestoreThread(_swig_thread_allow)
#    endif
#  else /* Old thread way, not implemented, user must provide it */
#    if !defined(SWIG_PYTHON_INITIALIZE_THREADS)
#      define SWIG_PYTHON_INITIALIZE_THREADS
#    endif
#    if !defined(SWIG_PYTHON_THREAD_BEGIN_BLOCK)
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK
#    endif
#    if !defined(SWIG_PYTHON_THREAD_END_BLOCK)
#      define SWIG_PYTHON_THREAD_END_BLOCK
#    endif
#    if !defined(SWIG_PYTHON_THREAD_BEGIN_ALLOW)
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW
#    endif
#    if !defined(SWIG_PYTHON_THREAD_END_ALLOW)
#      define SWIG_PYTHON_THREAD_END_ALLOW
#    endif
#  endif
#else /* No thread support */
#  define SWIG_PYTHON_INITIALIZE_THREADS
#  define SWIG_PYTHON_THREAD_BEGIN_BLOCK
#  define SWIG_PYTHON_THREAD_END_BLOCK
#  define SWIG_PYTHON_THREAD_BEGIN_ALLOW
#  define SWIG_PYTHON_THREAD_END_ALLOW
#endif

/* -----------------------------------------------------------------------------
 * Python API portion that goes into the runtime
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

/* -----------------------------------------------------------------------------
 * Constant declarations
 * ----------------------------------------------------------------------------- */

/* Constant Types */
#define SWIG_PY_POINTER 4
#define SWIG_PY_BINARY  5

/* Constant information structure */
typedef struct swig_const_info {
  int type;
  char *name;
  long lvalue;
  double dvalue;
  void   *pvalue;
  swig_type_info **ptype;
} swig_const_info;


/* -----------------------------------------------------------------------------
 * Wrapper of PyInstanceMethod_New() used in Python 3
 * It is exported to the generated module, used for -fastproxy
 * ----------------------------------------------------------------------------- */
#if PY_VERSION_HEX >= 0x03000000
SWIGRUNTIME PyObject* SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func)
{
  return PyInstanceMethod_New(func);
}
#else
SWIGRUNTIME PyObject* SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *SWIGUNUSEDPARM(func))
{
  return NULL;
}
#endif

#ifdef __cplusplus
}
#endif


/* -----------------------------------------------------------------------------
 * pyrun.swg
 *
 * This file contains the runtime support for Python modules
 * and includes code for managing global variables and pointer
 * type checking.
 *
 * ----------------------------------------------------------------------------- */

/* Common SWIG API */

/* for raw pointers */
#define SWIG_Python_ConvertPtr(obj, pptr, type, flags)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
#define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Python_ConvertPtr(obj, pptr, type, flags)
#define SWIG_ConvertPtrAndOwn(obj,pptr,type,flags,own)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, own)

#ifdef SWIGPYTHON_BUILTIN
#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Python_NewPointerObj(self, ptr, type, flags)
#else
#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Python_NewPointerObj(NULL, ptr, type, flags)
#endif

#define SWIG_InternalNewPointerObj(ptr, type, flags)	SWIG_Python_NewPointerObj(NULL, ptr, type, flags)

#define SWIG_CheckImplicit(ty)                          SWIG_Python_CheckImplicit(ty) 
#define SWIG_AcquirePtr(ptr, src)                       SWIG_Python_AcquirePtr(ptr, src)
#define swig_owntype                                    int

/* for raw packed data */
#define SWIG_ConvertPacked(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewPackedObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)

/* for class or struct pointers */
#define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_ConvertPtr(obj, pptr, type, flags)
#define SWIG_NewInstanceObj(ptr, type, flags)           SWIG_NewPointerObj(ptr, type, flags)

/* for C or C++ function pointers */
#define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_Python_ConvertFunctionPtr(obj, pptr, type)
#define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_Python_NewPointerObj(NULL, ptr, type, 0)

/* for C++ member pointers, ie, member methods */
#define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewMemberObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)


/* Runtime API */

#define SWIG_GetModule(clientdata)                      SWIG_Python_GetModule(clientdata)
#define SWIG_SetModule(clientdata, pointer)             SWIG_Python_SetModule(pointer)
#define SWIG_NewClientData(obj)                         SwigPyClientData_New(obj)

#define SWIG_SetErrorObj                                SWIG_Python_SetErrorObj                            
#define SWIG_SetErrorMsg                        	SWIG_Python_SetErrorMsg				   
#define SWIG_ErrorType(code)                    	SWIG_Python_ErrorType(code)                        
#define SWIG_Error(code, msg)            		SWIG_Python_SetErrorMsg(SWIG_ErrorType(code), msg) 
#define SWIG_fail                        		goto fail					   


/* Runtime API implementation */

/* Error manipulation */

SWIGINTERN void 
SWIG_Python_SetErrorObj(PyObject *errtype, PyObject *obj) {
  SWIG_PYTHON_THREAD_BEGIN_BLOCK; 
  PyErr_SetObject(errtype, obj);
  Py_DECREF(obj);
  SWIG_PYTHON_THREAD_END_BLOCK;
}

SWIGINTERN void 
SWIG_Python_SetErrorMsg(PyObject *errtype, const char *msg) {
  SWIG_PYTHON_THREAD_BEGIN_BLOCK;
  PyErr_SetString(errtype, msg);
  SWIG_PYTHON_THREAD_END_BLOCK;
}

#define SWIG_Python_Raise(obj, type, desc)  SWIG_Python_SetErrorObj(SWIG_Python_ExceptionType(desc), obj)

/* Set a constant value */

#if defined(SWIGPYTHON_BUILTIN)

SWIGINTERN void
SwigPyBuiltin_AddPublicSymbol(PyObject *seq, const char *key) {
  PyObject *s = PyString_InternFromString(key);
  PyList_Append(seq, s);
  Py_DECREF(s);
}

SWIGINTERN void
SWIG_Python_SetConstant(PyObject *d, PyObject *public_interface, const char *name, PyObject *obj) {   
#if PY_VERSION_HEX < 0x02030000
  PyDict_SetItemString(d, (char *)name, obj);
#else
  PyDict_SetItemString(d, name, obj);
#endif
  Py_DECREF(obj);
  if (public_interface)
    SwigPyBuiltin_AddPublicSymbol(public_interface, name);
}

#else

SWIGINTERN void
SWIG_Python_SetConstant(PyObject *d, const char *name, PyObject *obj) {   
#if PY_VERSION_HEX < 0x02030000
  PyDict_SetItemString(d, (char *)name, obj);
#else
  PyDict_SetItemString(d, name, obj);
#endif
  Py_DECREF(obj);                            
}

#endif

/* Append a value to the result obj */

SWIGINTERN PyObject*
SWIG_Python_AppendOutput(PyObject* result, PyObject* obj) {
#if !defined(SWIG_PYTHON_OUTPUT_TUPLE)
  if (!result) {
    result = obj;
  } else if (result == Py_None) {
    Py_DECREF(result);
    result = obj;
  } else {
    if (!PyList_Check(result)) {
      PyObject *o2 = result;
      result = PyList_New(1);
      PyList_SetItem(result, 0, o2);
    }
    PyList_Append(result,obj);
    Py_DECREF(obj);
  }
  return result;
#else
  PyObject*   o2;
  PyObject*   o3;
  if (!result) {
    result = obj;
  } else if (result == Py_None) {
    Py_DECREF(result);
    result = obj;
  } else {
    if (!PyTuple_Check(result)) {
      o2 = result;
      result = PyTuple_New(1);
      PyTuple_SET_ITEM(result, 0, o2);
    }
    o3 = PyTuple_New(1);
    PyTuple_SET_ITEM(o3, 0, obj);
    o2 = result;
    result = PySequence_Concat(o2, o3);
    Py_DECREF(o2);
    Py_DECREF(o3);
  }
  return result;
#endif
}

/* Unpack the argument tuple */

SWIGINTERN Py_ssize_t
SWIG_Python_UnpackTuple(PyObject *args, const char *name, Py_ssize_t min, Py_ssize_t max, PyObject **objs)
{
  if (!args) {
    if (!min && !max) {
      return 1;
    } else {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got none", 
		   name, (min == max ? "" : "at least "), (int)min);
      return 0;
    }
  }  
  if (!PyTuple_Check(args)) {
    if (min <= 1 && max >= 1) {
      Py_ssize_t i;
      objs[0] = args;
      for (i = 1; i < max; ++i) {
	objs[i] = 0;
      }
      return 2;
    }
    PyErr_SetString(PyExc_SystemError, "UnpackTuple() argument list is not a tuple");
    return 0;
  } else {
    Py_ssize_t l = PyTuple_GET_SIZE(args);
    if (l < min) {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
		   name, (min == max ? "" : "at least "), (int)min, (int)l);
      return 0;
    } else if (l > max) {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
		   name, (min == max ? "" : "at most "), (int)max, (int)l);
      return 0;
    } else {
      Py_ssize_t i;
      for (i = 0; i < l; ++i) {
	objs[i] = PyTuple_GET_ITEM(args, i);
      }
      for (; l < max; ++l) {
	objs[l] = 0;
      }
      return i + 1;
    }    
  }
}

/* A functor is a function object with one single object argument */
#if PY_VERSION_HEX >= 0x02020000
#define SWIG_Python_CallFunctor(functor, obj)	        PyObject_CallFunctionObjArgs(functor, obj, NULL);
#else
#define SWIG_Python_CallFunctor(functor, obj)	        PyObject_CallFunction(functor, "O", obj);
#endif

/*
  Helper for static pointer initialization for both C and C++ code, for example
  static PyObject *SWIG_STATIC_POINTER(MyVar) = NewSomething(...);
*/
#ifdef __cplusplus
#define SWIG_STATIC_POINTER(var)  var
#else
#define SWIG_STATIC_POINTER(var)  var = 0; if (!var) var
#endif

/* -----------------------------------------------------------------------------
 * Pointer declarations
 * ----------------------------------------------------------------------------- */

/* Flags for new pointer objects */
#define SWIG_POINTER_NOSHADOW       (SWIG_POINTER_OWN      << 1)
#define SWIG_POINTER_NEW            (SWIG_POINTER_NOSHADOW | SWIG_POINTER_OWN)

#define SWIG_POINTER_IMPLICIT_CONV  (SWIG_POINTER_DISOWN   << 1)

#define SWIG_BUILTIN_TP_INIT	    (SWIG_POINTER_OWN << 2)
#define SWIG_BUILTIN_INIT	    (SWIG_BUILTIN_TP_INIT | SWIG_POINTER_OWN)

#ifdef __cplusplus
extern "C" {
#endif

/*  How to access Py_None */
#if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#  ifndef SWIG_PYTHON_NO_BUILD_NONE
#    ifndef SWIG_PYTHON_BUILD_NONE
#      define SWIG_PYTHON_BUILD_NONE
#    endif
#  endif
#endif

#ifdef SWIG_PYTHON_BUILD_NONE
#  ifdef Py_None
#   undef Py_None
#   define Py_None SWIG_Py_None()
#  endif
SWIGRUNTIMEINLINE PyObject * 
_SWIG_Py_None(void)
{
  PyObject *none = Py_BuildValue((char*)"");
  Py_DECREF(none);
  return none;
}
SWIGRUNTIME PyObject * 
SWIG_Py_None(void)
{
  static PyObject *SWIG_STATIC_POINTER(none) = _SWIG_Py_None();
  return none;
}
#endif

/* The python void return value */

SWIGRUNTIMEINLINE PyObject * 
SWIG_Py_Void(void)
{
  PyObject *none = Py_None;
  Py_INCREF(none);
  return none;
}

/* SwigPyClientData */

typedef struct {
  PyObject *klass;
  PyObject *newraw;
  PyObject *newargs;
  PyObject *destroy;
  int delargs;
  int implicitconv;
  PyTypeObject *pytype;
} SwigPyClientData;

SWIGRUNTIMEINLINE int 
SWIG_Python_CheckImplicit(swig_type_info *ty)
{
  SwigPyClientData *data = (SwigPyClientData *)ty->clientdata;
  return data ? data->implicitconv : 0;
}

SWIGRUNTIMEINLINE PyObject *
SWIG_Python_ExceptionType(swig_type_info *desc) {
  SwigPyClientData *data = desc ? (SwigPyClientData *) desc->clientdata : 0;
  PyObject *klass = data ? data->klass : 0;
  return (klass ? klass : PyExc_RuntimeError);
}


SWIGRUNTIME SwigPyClientData * 
SwigPyClientData_New(PyObject* obj)
{
  if (!obj) {
    return 0;
  } else {
    SwigPyClientData *data = (SwigPyClientData *)malloc(sizeof(SwigPyClientData));
    /* the klass element */
    data->klass = obj;
    Py_INCREF(data->klass);
    /* the newraw method and newargs arguments used to create a new raw instance */
    if (PyClass_Check(obj)) {
      data->newraw = 0;
      data->newargs = obj;
      Py_INCREF(obj);
    } else {
#if (PY_VERSION_HEX < 0x02020000)
      data->newraw = 0;
#else
      data->newraw = PyObject_GetAttrString(data->klass, (char *)"__new__");
#endif
      if (data->newraw) {
	Py_INCREF(data->newraw);
	data->newargs = PyTuple_New(1);
	PyTuple_SetItem(data->newargs, 0, obj);
      } else {
	data->newargs = obj;
      }
      Py_INCREF(data->newargs);
    }
    /* the destroy method, aka as the C++ delete method */
    data->destroy = PyObject_GetAttrString(data->klass, (char *)"__swig_destroy__");
    if (PyErr_Occurred()) {
      PyErr_Clear();
      data->destroy = 0;
    }
    if (data->destroy) {
      int flags;
      Py_INCREF(data->destroy);
      flags = PyCFunction_GET_FLAGS(data->destroy);
#ifdef METH_O
      data->delargs = !(flags & (METH_O));
#else
      data->delargs = 0;
#endif
    } else {
      data->delargs = 0;
    }
    data->implicitconv = 0;
    data->pytype = 0;
    return data;
  }
}

SWIGRUNTIME void 
SwigPyClientData_Del(SwigPyClientData *data) {
  Py_XDECREF(data->newraw);
  Py_XDECREF(data->newargs);
  Py_XDECREF(data->destroy);
}

/* =============== SwigPyObject =====================*/

typedef struct {
  PyObject_HEAD
  void *ptr;
  swig_type_info *ty;
  int own;
  PyObject *next;
#ifdef SWIGPYTHON_BUILTIN
  PyObject *dict;
#endif
} SwigPyObject;


#ifdef SWIGPYTHON_BUILTIN

SWIGRUNTIME PyObject *
SwigPyObject_get___dict__(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
{
  SwigPyObject *sobj = (SwigPyObject *)v;

  if (!sobj->dict)
    sobj->dict = PyDict_New();

  Py_INCREF(sobj->dict);
  return sobj->dict;
}

#endif

SWIGRUNTIME PyObject *
SwigPyObject_long(SwigPyObject *v)
{
  return PyLong_FromVoidPtr(v->ptr);
}

SWIGRUNTIME PyObject *
SwigPyObject_format(const char* fmt, SwigPyObject *v)
{
  PyObject *res = NULL;
  PyObject *args = PyTuple_New(1);
  if (args) {
    if (PyTuple_SetItem(args, 0, SwigPyObject_long(v)) == 0) {
      PyObject *ofmt = SWIG_Python_str_FromChar(fmt);
      if (ofmt) {
#if PY_VERSION_HEX >= 0x03000000
	res = PyUnicode_Format(ofmt,args);
#else
	res = PyString_Format(ofmt,args);
#endif
	Py_DECREF(ofmt);
      }
      Py_DECREF(args);
    }
  }
  return res;
}

SWIGRUNTIME PyObject *
SwigPyObject_oct(SwigPyObject *v)
{
  return SwigPyObject_format("%o",v);
}

SWIGRUNTIME PyObject *
SwigPyObject_hex(SwigPyObject *v)
{
  return SwigPyObject_format("%x",v);
}

SWIGRUNTIME PyObject *
#ifdef METH_NOARGS
SwigPyObject_repr(SwigPyObject *v)
#else
SwigPyObject_repr(SwigPyObject *v, PyObject *args)
#endif
{
  const char *name = SWIG_TypePrettyName(v->ty);
  PyObject *repr = SWIG_Python_str_FromFormat("<Swig Object of type '%s' at %p>", (name ? name : "unknown"), (void *)v);
  if (v->next) {
# ifdef METH_NOARGS
    PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next);
# else
    PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next, args);
# endif
# if PY_VERSION_HEX >= 0x03000000
    PyObject *joined = PyUnicode_Concat(repr, nrep);
    Py_DecRef(repr);
    Py_DecRef(nrep);
    repr = joined;
# else
    PyString_ConcatAndDel(&repr,nrep);
# endif
  }
  return repr;  
}

SWIGRUNTIME int
SwigPyObject_compare(SwigPyObject *v, SwigPyObject *w)
{
  void *i = v->ptr;
  void *j = w->ptr;
  return (i < j) ? -1 : ((i > j) ? 1 : 0);
}

/* Added for Python 3.x, would it also be useful for Python 2.x? */
SWIGRUNTIME PyObject*
SwigPyObject_richcompare(SwigPyObject *v, SwigPyObject *w, int op)
{
  PyObject* res;
  if( op != Py_EQ && op != Py_NE ) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  res = PyBool_FromLong( (SwigPyObject_compare(v, w)==0) == (op == Py_EQ) ? 1 : 0);
  return res;  
}


SWIGRUNTIME PyTypeObject* SwigPyObject_TypeOnce(void);

#ifdef SWIGPYTHON_BUILTIN
static swig_type_info *SwigPyObject_stype = 0;
SWIGRUNTIME PyTypeObject*
SwigPyObject_type(void) {
    SwigPyClientData *cd;
    assert(SwigPyObject_stype);
    cd = (SwigPyClientData*) SwigPyObject_stype->clientdata;
    assert(cd);
    assert(cd->pytype);
    return cd->pytype;
}
#else
SWIGRUNTIME PyTypeObject*
SwigPyObject_type(void) {
  static PyTypeObject *SWIG_STATIC_POINTER(type) = SwigPyObject_TypeOnce();
  return type;
}
#endif

SWIGRUNTIMEINLINE int
SwigPyObject_Check(PyObject *op) {
#ifdef SWIGPYTHON_BUILTIN
  PyTypeObject *target_tp = SwigPyObject_type();
  if (PyType_IsSubtype(op->ob_type, target_tp))
    return 1;
  return (strcmp(op->ob_type->tp_name, "SwigPyObject") == 0);
#else
  return (Py_TYPE(op) == SwigPyObject_type())
    || (strcmp(Py_TYPE(op)->tp_name,"SwigPyObject") == 0);
#endif
}

SWIGRUNTIME PyObject *
SwigPyObject_New(void *ptr, swig_type_info *ty, int own);

SWIGRUNTIME void
SwigPyObject_dealloc(PyObject *v)
{
  SwigPyObject *sobj = (SwigPyObject *) v;
  PyObject *next = sobj->next;
  if (sobj->own == SWIG_POINTER_OWN) {
    swig_type_info *ty = sobj->ty;
    SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
    PyObject *destroy = data ? data->destroy : 0;
    if (destroy) {
      /* destroy is always a VARARGS method */
      PyObject *res;

      /* PyObject_CallFunction() has the potential to silently drop
         the active active exception.  In cases of unnamed temporary
         variable or where we just finished iterating over a generator
         StopIteration will be active right now, and this needs to
         remain true upon return from SwigPyObject_dealloc.  So save
         and restore. */
      
      PyObject *val = NULL, *type = NULL, *tb = NULL;
      PyErr_Fetch(&val, &type, &tb);

      if (data->delargs) {
        /* we need to create a temporary object to carry the destroy operation */
        PyObject *tmp = SwigPyObject_New(sobj->ptr, ty, 0);
        res = SWIG_Python_CallFunctor(destroy, tmp);
        Py_DECREF(tmp);
      } else {
        PyCFunction meth = PyCFunction_GET_FUNCTION(destroy);
        PyObject *mself = PyCFunction_GET_SELF(destroy);
        res = ((*meth)(mself, v));
      }
      if (!res)
        PyErr_WriteUnraisable(destroy);

      PyErr_Restore(val, type, tb);

      Py_XDECREF(res);
    } 
#if !defined(SWIG_PYTHON_SILENT_MEMLEAK)
    else {
      const char *name = SWIG_TypePrettyName(ty);
      printf("swig/python detected a memory leak of type '%s', no destructor found.\n", (name ? name : "unknown"));
    }
#endif
  } 
  Py_XDECREF(next);
  PyObject_DEL(v);
}

SWIGRUNTIME PyObject* 
SwigPyObject_append(PyObject* v, PyObject* next)
{
  SwigPyObject *sobj = (SwigPyObject *) v;
#ifndef METH_O
  PyObject *tmp = 0;
  if (!PyArg_ParseTuple(next,(char *)"O:append", &tmp)) return NULL;
  next = tmp;
#endif
  if (!SwigPyObject_Check(next)) {
    PyErr_SetString(PyExc_TypeError, "Attempt to append a non SwigPyObject");
    return NULL;
  }
  sobj->next = next;
  Py_INCREF(next);
  return SWIG_Py_Void();
}

SWIGRUNTIME PyObject* 
#ifdef METH_NOARGS
SwigPyObject_next(PyObject* v)
#else
SwigPyObject_next(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
#endif
{
  SwigPyObject *sobj = (SwigPyObject *) v;
  if (sobj->next) {    
    Py_INCREF(sobj->next);
    return sobj->next;
  } else {
    return SWIG_Py_Void();
  }
}

SWIGINTERN PyObject*
#ifdef METH_NOARGS
SwigPyObject_disown(PyObject *v)
#else
SwigPyObject_disown(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
#endif
{
  SwigPyObject *sobj = (SwigPyObject *)v;
  sobj->own = 0;
  return SWIG_Py_Void();
}

SWIGINTERN PyObject*
#ifdef METH_NOARGS
SwigPyObject_acquire(PyObject *v)
#else
SwigPyObject_acquire(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
#endif
{
  SwigPyObject *sobj = (SwigPyObject *)v;
  sobj->own = SWIG_POINTER_OWN;
  return SWIG_Py_Void();
}

SWIGINTERN PyObject*
SwigPyObject_own(PyObject *v, PyObject *args)
{
  PyObject *val = 0;
#if (PY_VERSION_HEX < 0x02020000)
  if (!PyArg_ParseTuple(args,(char *)"|O:own",&val))
#elif (PY_VERSION_HEX < 0x02050000)
  if (!PyArg_UnpackTuple(args, (char *)"own", 0, 1, &val)) 
#else
  if (!PyArg_UnpackTuple(args, "own", 0, 1, &val)) 
#endif
    {
      return NULL;
    } 
  else
    {
      SwigPyObject *sobj = (SwigPyObject *)v;
      PyObject *obj = PyBool_FromLong(sobj->own);
      if (val) {
#ifdef METH_NOARGS
	if (PyObject_IsTrue(val)) {
	  SwigPyObject_acquire(v);
	} else {
	  SwigPyObject_disown(v);
	}
#else
	if (PyObject_IsTrue(val)) {
	  SwigPyObject_acquire(v,args);
	} else {
	  SwigPyObject_disown(v,args);
	}
#endif
      } 
      return obj;
    }
}

#ifdef METH_O
static PyMethodDef
swigobject_methods[] = {
  {(char *)"disown",  (PyCFunction)SwigPyObject_disown,  METH_NOARGS,  (char *)"releases ownership of the pointer"},
  {(char *)"acquire", (PyCFunction)SwigPyObject_acquire, METH_NOARGS,  (char *)"acquires ownership of the pointer"},
  {(char *)"own",     (PyCFunction)SwigPyObject_own,     METH_VARARGS, (char *)"returns/sets ownership of the pointer"},
  {(char *)"append",  (PyCFunction)SwigPyObject_append,  METH_O,       (char *)"appends another 'this' object"},
  {(char *)"next",    (PyCFunction)SwigPyObject_next,    METH_NOARGS,  (char *)"returns the next 'this' object"},
  {(char *)"__repr__",(PyCFunction)SwigPyObject_repr,    METH_NOARGS,  (char *)"returns object representation"},
  {0, 0, 0, 0}  
};
#else
static PyMethodDef
swigobject_methods[] = {
  {(char *)"disown",  (PyCFunction)SwigPyObject_disown,  METH_VARARGS,  (char *)"releases ownership of the pointer"},
  {(char *)"acquire", (PyCFunction)SwigPyObject_acquire, METH_VARARGS,  (char *)"acquires ownership of the pointer"},
  {(char *)"own",     (PyCFunction)SwigPyObject_own,     METH_VARARGS,  (char *)"returns/sets ownership of the pointer"},
  {(char *)"append",  (PyCFunction)SwigPyObject_append,  METH_VARARGS,  (char *)"appends another 'this' object"},
  {(char *)"next",    (PyCFunction)SwigPyObject_next,    METH_VARARGS,  (char *)"returns the next 'this' object"},
  {(char *)"__repr__",(PyCFunction)SwigPyObject_repr,   METH_VARARGS,  (char *)"returns object representation"},
  {0, 0, 0, 0}  
};
#endif

#if PY_VERSION_HEX < 0x02020000
SWIGINTERN PyObject *
SwigPyObject_getattr(SwigPyObject *sobj,char *name)
{
  return Py_FindMethod(swigobject_methods, (PyObject *)sobj, name);
}
#endif

SWIGRUNTIME PyTypeObject*
SwigPyObject_TypeOnce(void) {
  static char swigobject_doc[] = "Swig object carries a C/C++ instance pointer";

  static PyNumberMethods SwigPyObject_as_number = {
    (binaryfunc)0, /*nb_add*/
    (binaryfunc)0, /*nb_subtract*/
    (binaryfunc)0, /*nb_multiply*/
    /* nb_divide removed in Python 3 */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc)0, /*nb_divide*/
#endif
    (binaryfunc)0, /*nb_remainder*/
    (binaryfunc)0, /*nb_divmod*/
    (ternaryfunc)0,/*nb_power*/
    (unaryfunc)0,  /*nb_negative*/
    (unaryfunc)0,  /*nb_positive*/
    (unaryfunc)0,  /*nb_absolute*/
    (inquiry)0,    /*nb_nonzero*/
    0,		   /*nb_invert*/
    0,		   /*nb_lshift*/
    0,		   /*nb_rshift*/
    0,		   /*nb_and*/
    0,		   /*nb_xor*/
    0,		   /*nb_or*/
#if PY_VERSION_HEX < 0x03000000
    0,   /*nb_coerce*/
#endif
    (unaryfunc)SwigPyObject_long, /*nb_int*/
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc)SwigPyObject_long, /*nb_long*/
#else
    0, /*nb_reserved*/
#endif
    (unaryfunc)0,                 /*nb_float*/
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc)SwigPyObject_oct,  /*nb_oct*/
    (unaryfunc)SwigPyObject_hex,  /*nb_hex*/
#endif
#if PY_VERSION_HEX >= 0x03050000 /* 3.5 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_matrix_multiply */
#elif PY_VERSION_HEX >= 0x03000000 /* 3.0 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_index, nb_inplace_divide removed */
#elif PY_VERSION_HEX >= 0x02050000 /* 2.5.0 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_index */
#elif PY_VERSION_HEX >= 0x02020000 /* 2.2.0 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_true_divide */
#elif PY_VERSION_HEX >= 0x02000000 /* 2.0.0 */
    0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_or */
#endif
  };

  static PyTypeObject swigpyobject_type;
  static int type_init = 0;
  if (!type_init) {
    const PyTypeObject tmp = {
#if PY_VERSION_HEX >= 0x03000000
      PyVarObject_HEAD_INIT(NULL, 0)
#else
      PyObject_HEAD_INIT(NULL)
      0,                                    /* ob_size */
#endif
      (char *)"SwigPyObject",               /* tp_name */
      sizeof(SwigPyObject),                 /* tp_basicsize */
      0,                                    /* tp_itemsize */
      (destructor)SwigPyObject_dealloc,     /* tp_dealloc */
      0,                                    /* tp_print */
#if PY_VERSION_HEX < 0x02020000
      (getattrfunc)SwigPyObject_getattr,    /* tp_getattr */
#else
      (getattrfunc)0,                       /* tp_getattr */
#endif
      (setattrfunc)0,                       /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
      0, /* tp_reserved in 3.0.1, tp_compare in 3.0.0 but not used */
#else
      (cmpfunc)SwigPyObject_compare,        /* tp_compare */
#endif
      (reprfunc)SwigPyObject_repr,          /* tp_repr */
      &SwigPyObject_as_number,              /* tp_as_number */
      0,                                    /* tp_as_sequence */
      0,                                    /* tp_as_mapping */
      (hashfunc)0,                          /* tp_hash */
      (ternaryfunc)0,                       /* tp_call */
      0,                                    /* tp_str */
      PyObject_GenericGetAttr,              /* tp_getattro */
      0,                                    /* tp_setattro */
      0,                                    /* tp_as_buffer */
      Py_TPFLAGS_DEFAULT,                   /* tp_flags */
      swigobject_doc,                       /* tp_doc */
      0,                                    /* tp_traverse */
      0,                                    /* tp_clear */
      (richcmpfunc)SwigPyObject_richcompare,/* tp_richcompare */
      0,                                    /* tp_weaklistoffset */
#if PY_VERSION_HEX >= 0x02020000
      0,                                    /* tp_iter */
      0,                                    /* tp_iternext */
      swigobject_methods,                   /* tp_methods */
      0,                                    /* tp_members */
      0,                                    /* tp_getset */
      0,                                    /* tp_base */
      0,                                    /* tp_dict */
      0,                                    /* tp_descr_get */
      0,                                    /* tp_descr_set */
      0,                                    /* tp_dictoffset */
      0,                                    /* tp_init */
      0,                                    /* tp_alloc */
      0,                                    /* tp_new */
      0,                                    /* tp_free */
      0,                                    /* tp_is_gc */
      0,                                    /* tp_bases */
      0,                                    /* tp_mro */
      0,                                    /* tp_cache */
      0,                                    /* tp_subclasses */
      0,                                    /* tp_weaklist */
#endif
#if PY_VERSION_HEX >= 0x02030000
      0,                                    /* tp_del */
#endif
#if PY_VERSION_HEX >= 0x02060000
      0,                                    /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
      0,                                    /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
      0,                                    /* tp_allocs */
      0,                                    /* tp_frees */
      0,                                    /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
      0,                                    /* tp_prev */
#endif
      0                                     /* tp_next */
#endif
    };
    swigpyobject_type = tmp;
    type_init = 1;
#if PY_VERSION_HEX < 0x02020000
    swigpyobject_type.ob_type = &PyType_Type;
#else
    if (PyType_Ready(&swigpyobject_type) < 0)
      return NULL;
#endif
  }
  return &swigpyobject_type;
}

SWIGRUNTIME PyObject *
SwigPyObject_New(void *ptr, swig_type_info *ty, int own)
{
  SwigPyObject *sobj = PyObject_NEW(SwigPyObject, SwigPyObject_type());
  if (sobj) {
    sobj->ptr  = ptr;
    sobj->ty   = ty;
    sobj->own  = own;
    sobj->next = 0;
  }
  return (PyObject *)sobj;
}

/* -----------------------------------------------------------------------------
 * Implements a simple Swig Packed type, and use it instead of string
 * ----------------------------------------------------------------------------- */

typedef struct {
  PyObject_HEAD
  void *pack;
  swig_type_info *ty;
  size_t size;
} SwigPyPacked;

SWIGRUNTIME int
SwigPyPacked_print(SwigPyPacked *v, FILE *fp, int SWIGUNUSEDPARM(flags))
{
  char result[SWIG_BUFFER_SIZE];
  fputs("<Swig Packed ", fp); 
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {
    fputs("at ", fp); 
    fputs(result, fp); 
  }
  fputs(v->ty->name,fp); 
  fputs(">", fp);
  return 0; 
}
  
SWIGRUNTIME PyObject *
SwigPyPacked_repr(SwigPyPacked *v)
{
  char result[SWIG_BUFFER_SIZE];
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {
    return SWIG_Python_str_FromFormat("<Swig Packed at %s%s>", result, v->ty->name);
  } else {
    return SWIG_Python_str_FromFormat("<Swig Packed %s>", v->ty->name);
  }  
}

SWIGRUNTIME PyObject *
SwigPyPacked_str(SwigPyPacked *v)
{
  char result[SWIG_BUFFER_SIZE];
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))){
    return SWIG_Python_str_FromFormat("%s%s", result, v->ty->name);
  } else {
    return SWIG_Python_str_FromChar(v->ty->name);
  }  
}

SWIGRUNTIME int
SwigPyPacked_compare(SwigPyPacked *v, SwigPyPacked *w)
{
  size_t i = v->size;
  size_t j = w->size;
  int s = (i < j) ? -1 : ((i > j) ? 1 : 0);
  return s ? s : strncmp((char *)v->pack, (char *)w->pack, 2*v->size);
}

SWIGRUNTIME PyTypeObject* SwigPyPacked_TypeOnce(void);

SWIGRUNTIME PyTypeObject*
SwigPyPacked_type(void) {
  static PyTypeObject *SWIG_STATIC_POINTER(type) = SwigPyPacked_TypeOnce();
  return type;
}

SWIGRUNTIMEINLINE int
SwigPyPacked_Check(PyObject *op) {
  return ((op)->ob_type == SwigPyPacked_TypeOnce()) 
    || (strcmp((op)->ob_type->tp_name,"SwigPyPacked") == 0);
}

SWIGRUNTIME void
SwigPyPacked_dealloc(PyObject *v)
{
  if (SwigPyPacked_Check(v)) {
    SwigPyPacked *sobj = (SwigPyPacked *) v;
    free(sobj->pack);
  }
  PyObject_DEL(v);
}

SWIGRUNTIME PyTypeObject*
SwigPyPacked_TypeOnce(void) {
  static char swigpacked_doc[] = "Swig object carries a C/C++ instance pointer";
  static PyTypeObject swigpypacked_type;
  static int type_init = 0;
  if (!type_init) {
    const PyTypeObject tmp = {
#if PY_VERSION_HEX>=0x03000000
      PyVarObject_HEAD_INIT(NULL, 0)
#else
      PyObject_HEAD_INIT(NULL)
      0,                                    /* ob_size */
#endif
      (char *)"SwigPyPacked",               /* tp_name */
      sizeof(SwigPyPacked),                 /* tp_basicsize */
      0,                                    /* tp_itemsize */
      (destructor)SwigPyPacked_dealloc,     /* tp_dealloc */
      (printfunc)SwigPyPacked_print,        /* tp_print */
      (getattrfunc)0,                       /* tp_getattr */
      (setattrfunc)0,                       /* tp_setattr */
#if PY_VERSION_HEX>=0x03000000
      0, /* tp_reserved in 3.0.1 */
#else
      (cmpfunc)SwigPyPacked_compare,        /* tp_compare */
#endif
      (reprfunc)SwigPyPacked_repr,          /* tp_repr */
      0,                                    /* tp_as_number */
      0,                                    /* tp_as_sequence */
      0,                                    /* tp_as_mapping */
      (hashfunc)0,                          /* tp_hash */
      (ternaryfunc)0,                       /* tp_call */
      (reprfunc)SwigPyPacked_str,           /* tp_str */
      PyObject_GenericGetAttr,              /* tp_getattro */
      0,                                    /* tp_setattro */
      0,                                    /* tp_as_buffer */
      Py_TPFLAGS_DEFAULT,                   /* tp_flags */
      swigpacked_doc,                       /* tp_doc */
      0,                                    /* tp_traverse */
      0,                                    /* tp_clear */
      0,                                    /* tp_richcompare */
      0,                                    /* tp_weaklistoffset */
#if PY_VERSION_HEX >= 0x02020000
      0,                                    /* tp_iter */
      0,                                    /* tp_iternext */
      0,                                    /* tp_methods */
      0,                                    /* tp_members */
      0,                                    /* tp_getset */
      0,                                    /* tp_base */
      0,                                    /* tp_dict */
      0,                                    /* tp_descr_get */
      0,                                    /* tp_descr_set */
      0,                                    /* tp_dictoffset */
      0,                                    /* tp_init */
      0,                                    /* tp_alloc */
      0,                                    /* tp_new */
      0,                                    /* tp_free */
      0,                                    /* tp_is_gc */
      0,                                    /* tp_bases */
      0,                                    /* tp_mro */
      0,                                    /* tp_cache */
      0,                                    /* tp_subclasses */
      0,                                    /* tp_weaklist */
#endif
#if PY_VERSION_HEX >= 0x02030000
      0,                                    /* tp_del */
#endif
#if PY_VERSION_HEX >= 0x02060000
      0,                                    /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
      0,                                    /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
      0,                                    /* tp_allocs */
      0,                                    /* tp_frees */
      0,                                    /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
      0,                                    /* tp_prev */
#endif
      0                                     /* tp_next */
#endif
    };
    swigpypacked_type = tmp;
    type_init = 1;
#if PY_VERSION_HEX < 0x02020000
    swigpypacked_type.ob_type = &PyType_Type;
#else
    if (PyType_Ready(&swigpypacked_type) < 0)
      return NULL;
#endif
  }
  return &swigpypacked_type;
}

SWIGRUNTIME PyObject *
SwigPyPacked_New(void *ptr, size_t size, swig_type_info *ty)
{
  SwigPyPacked *sobj = PyObject_NEW(SwigPyPacked, SwigPyPacked_type());
  if (sobj) {
    void *pack = malloc(size);
    if (pack) {
      memcpy(pack, ptr, size);
      sobj->pack = pack;
      sobj->ty   = ty;
      sobj->size = size;
    } else {
      PyObject_DEL((PyObject *) sobj);
      sobj = 0;
    }
  }
  return (PyObject *) sobj;
}

SWIGRUNTIME swig_type_info *
SwigPyPacked_UnpackData(PyObject *obj, void *ptr, size_t size)
{
  if (SwigPyPacked_Check(obj)) {
    SwigPyPacked *sobj = (SwigPyPacked *)obj;
    if (sobj->size != size) return 0;
    memcpy(ptr, sobj->pack, size);
    return sobj->ty;
  } else {
    return 0;
  }
}

/* -----------------------------------------------------------------------------
 * pointers/data manipulation
 * ----------------------------------------------------------------------------- */

SWIGRUNTIMEINLINE PyObject *
_SWIG_This(void)
{
    return SWIG_Python_str_FromChar("this");
}

static PyObject *swig_this = NULL;

SWIGRUNTIME PyObject *
SWIG_This(void)
{
  if (swig_this == NULL)
    swig_this = _SWIG_This();
  return swig_this;
}

/* #define SWIG_PYTHON_SLOW_GETSET_THIS */

/* TODO: I don't know how to implement the fast getset in Python 3 right now */
#if PY_VERSION_HEX>=0x03000000
#define SWIG_PYTHON_SLOW_GETSET_THIS 
#endif

SWIGRUNTIME SwigPyObject *
SWIG_Python_GetSwigThis(PyObject *pyobj) 
{
  PyObject *obj;

  if (SwigPyObject_Check(pyobj))
    return (SwigPyObject *) pyobj;

#ifdef SWIGPYTHON_BUILTIN
  (void)obj;
# ifdef PyWeakref_CheckProxy
  if (PyWeakref_CheckProxy(pyobj)) {
    pyobj = PyWeakref_GET_OBJECT(pyobj);
    if (pyobj && SwigPyObject_Check(pyobj))
      return (SwigPyObject*) pyobj;
  }
# endif
  return NULL;
#else

  obj = 0;

#if (!defined(SWIG_PYTHON_SLOW_GETSET_THIS) && (PY_VERSION_HEX >= 0x02030000))
  if (PyInstance_Check(pyobj)) {
    obj = _PyInstance_Lookup(pyobj, SWIG_This());      
  } else {
    PyObject **dictptr = _PyObject_GetDictPtr(pyobj);
    if (dictptr != NULL) {
      PyObject *dict = *dictptr;
      obj = dict ? PyDict_GetItem(dict, SWIG_This()) : 0;
    } else {
#ifdef PyWeakref_CheckProxy
      if (PyWeakref_CheckProxy(pyobj)) {
	PyObject *wobj = PyWeakref_GET_OBJECT(pyobj);
	return wobj ? SWIG_Python_GetSwigThis(wobj) : 0;
      }
#endif
      obj = PyObject_GetAttr(pyobj,SWIG_This());
      if (obj) {
	Py_DECREF(obj);
      } else {
	if (PyErr_Occurred()) PyErr_Clear();
	return 0;
      }
    }
  }
#else
  obj = PyObject_GetAttr(pyobj,SWIG_This());
  if (obj) {
    Py_DECREF(obj);
  } else {
    if (PyErr_Occurred()) PyErr_Clear();
    return 0;
  }
#endif
  if (obj && !SwigPyObject_Check(obj)) {
    /* a PyObject is called 'this', try to get the 'real this'
       SwigPyObject from it */ 
    return SWIG_Python_GetSwigThis(obj);
  }
  return (SwigPyObject *)obj;
#endif
}

/* Acquire a pointer value */

SWIGRUNTIME int
SWIG_Python_AcquirePtr(PyObject *obj, int own) {
  if (own == SWIG_POINTER_OWN) {
    SwigPyObject *sobj = SWIG_Python_GetSwigThis(obj);
    if (sobj) {
      int oldown = sobj->own;
      sobj->own = own;
      return oldown;
    }
  }
  return 0;
}

/* Convert a pointer value */

SWIGRUNTIME int
SWIG_Python_ConvertPtrAndOwn(PyObject *obj, void **ptr, swig_type_info *ty, int flags, int *own) {
  int res;
  SwigPyObject *sobj;
  int implicit_conv = (flags & SWIG_POINTER_IMPLICIT_CONV) != 0;

  if (!obj)
    return SWIG_ERROR;
  if (obj == Py_None && !implicit_conv) {
    if (ptr)
      *ptr = 0;
    return SWIG_OK;
  }

  res = SWIG_ERROR;

  sobj = SWIG_Python_GetSwigThis(obj);
  if (own)
    *own = 0;
  while (sobj) {
    void *vptr = sobj->ptr;
    if (ty) {
      swig_type_info *to = sobj->ty;
      if (to == ty) {
        /* no type cast needed */
        if (ptr) *ptr = vptr;
        break;
      } else {
        swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
        if (!tc) {
          sobj = (SwigPyObject *)sobj->next;
        } else {
          if (ptr) {
            int newmemory = 0;
            *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
            if (newmemory == SWIG_CAST_NEW_MEMORY) {
              assert(own); /* badly formed typemap which will lead to a memory leak - it must set and use own to delete *ptr */
              if (own)
                *own = *own | SWIG_CAST_NEW_MEMORY;
            }
          }
          break;
        }
      }
    } else {
      if (ptr) *ptr = vptr;
      break;
    }
  }
  if (sobj) {
    if (own)
      *own = *own | sobj->own;
    if (flags & SWIG_POINTER_DISOWN) {
      sobj->own = 0;
    }
    res = SWIG_OK;
  } else {
    if (implicit_conv) {
      SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
      if (data && !data->implicitconv) {
        PyObject *klass = data->klass;
        if (klass) {
          PyObject *impconv;
          data->implicitconv = 1; /* avoid recursion and call 'explicit' constructors*/
          impconv = SWIG_Python_CallFunctor(klass, obj);
          data->implicitconv = 0;
          if (PyErr_Occurred()) {
            PyErr_Clear();
            impconv = 0;
          }
          if (impconv) {
            SwigPyObject *iobj = SWIG_Python_GetSwigThis(impconv);
            if (iobj) {
              void *vptr;
              res = SWIG_Python_ConvertPtrAndOwn((PyObject*)iobj, &vptr, ty, 0, 0);
              if (SWIG_IsOK(res)) {
                if (ptr) {
                  *ptr = vptr;
                  /* transfer the ownership to 'ptr' */
                  iobj->own = 0;
                  res = SWIG_AddCast(res);
                  res = SWIG_AddNewMask(res);
                } else {
                  res = SWIG_AddCast(res);		    
                }
              }
            }
            Py_DECREF(impconv);
          }
        }
      }
    }
    if (!SWIG_IsOK(res) && obj == Py_None) {
      if (ptr)
        *ptr = 0;
      if (PyErr_Occurred())
        PyErr_Clear();
      res = SWIG_OK;
    }
  }
  return res;
}

/* Convert a function ptr value */

SWIGRUNTIME int
SWIG_Python_ConvertFunctionPtr(PyObject *obj, void **ptr, swig_type_info *ty) {
  if (!PyCFunction_Check(obj)) {
    return SWIG_ConvertPtr(obj, ptr, ty, 0);
  } else {
    void *vptr = 0;
    
    /* here we get the method pointer for callbacks */
    const char *doc = (((PyCFunctionObject *)obj) -> m_ml -> ml_doc);
    const char *desc = doc ? strstr(doc, "swig_ptr: ") : 0;
    if (desc)
      desc = ty ? SWIG_UnpackVoidPtr(desc + 10, &vptr, ty->name) : 0;
    if (!desc) 
      return SWIG_ERROR;
    if (ty) {
      swig_cast_info *tc = SWIG_TypeCheck(desc,ty);
      if (tc) {
        int newmemory = 0;
        *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
        assert(!newmemory); /* newmemory handling not yet implemented */
      } else {
        return SWIG_ERROR;
      }
    } else {
      *ptr = vptr;
    }
    return SWIG_OK;
  }
}

/* Convert a packed value value */

SWIGRUNTIME int
SWIG_Python_ConvertPacked(PyObject *obj, void *ptr, size_t sz, swig_type_info *ty) {
  swig_type_info *to = SwigPyPacked_UnpackData(obj, ptr, sz);
  if (!to) return SWIG_ERROR;
  if (ty) {
    if (to != ty) {
      /* check type cast? */
      swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
      if (!tc) return SWIG_ERROR;
    }
  }
  return SWIG_OK;
}  

/* -----------------------------------------------------------------------------
 * Create a new pointer object
 * ----------------------------------------------------------------------------- */

/*
  Create a new instance object, without calling __init__, and set the
  'this' attribute.
*/

SWIGRUNTIME PyObject* 
SWIG_Python_NewShadowInstance(SwigPyClientData *data, PyObject *swig_this)
{
#if (PY_VERSION_HEX >= 0x02020000)
  PyObject *inst = 0;
  PyObject *newraw = data->newraw;
  if (newraw) {
    inst = PyObject_Call(newraw, data->newargs, NULL);
    if (inst) {
#if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
      PyObject **dictptr = _PyObject_GetDictPtr(inst);
      if (dictptr != NULL) {
	PyObject *dict = *dictptr;
	if (dict == NULL) {
	  dict = PyDict_New();
	  *dictptr = dict;
	  PyDict_SetItem(dict, SWIG_This(), swig_this);
	}
      }
#else
      PyObject *key = SWIG_This();
      PyObject_SetAttr(inst, key, swig_this);
#endif
    }
  } else {
#if PY_VERSION_HEX >= 0x03000000
    inst = ((PyTypeObject*) data->newargs)->tp_new((PyTypeObject*) data->newargs, Py_None, Py_None);
    if (inst) {
      PyObject_SetAttr(inst, SWIG_This(), swig_this);
      Py_TYPE(inst)->tp_flags &= ~Py_TPFLAGS_VALID_VERSION_TAG;
    }
#else
    PyObject *dict = PyDict_New();
    if (dict) {
      PyDict_SetItem(dict, SWIG_This(), swig_this);
      inst = PyInstance_NewRaw(data->newargs, dict);
      Py_DECREF(dict);
    }
#endif
  }
  return inst;
#else
#if (PY_VERSION_HEX >= 0x02010000)
  PyObject *inst = 0;
  PyObject *dict = PyDict_New();
  if (dict) {
    PyDict_SetItem(dict, SWIG_This(), swig_this);
    inst = PyInstance_NewRaw(data->newargs, dict);
    Py_DECREF(dict);
  }
  return (PyObject *) inst;
#else
  PyInstanceObject *inst = PyObject_NEW(PyInstanceObject, &PyInstance_Type);
  if (inst == NULL) {
    return NULL;
  }
  inst->in_class = (PyClassObject *)data->newargs;
  Py_INCREF(inst->in_class);
  inst->in_dict = PyDict_New();
  if (inst->in_dict == NULL) {
    Py_DECREF(inst);
    return NULL;
  }
#ifdef Py_TPFLAGS_HAVE_WEAKREFS
  inst->in_weakreflist = NULL;
#endif
#ifdef Py_TPFLAGS_GC
  PyObject_GC_Init(inst);
#endif
  PyDict_SetItem(inst->in_dict, SWIG_This(), swig_this);
  return (PyObject *) inst;
#endif
#endif
}

SWIGRUNTIME void
SWIG_Python_SetSwigThis(PyObject *inst, PyObject *swig_this)
{
 PyObject *dict;
#if (PY_VERSION_HEX >= 0x02020000) && !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
 PyObject **dictptr = _PyObject_GetDictPtr(inst);
 if (dictptr != NULL) {
   dict = *dictptr;
   if (dict == NULL) {
     dict = PyDict_New();
     *dictptr = dict;
   }
   PyDict_SetItem(dict, SWIG_This(), swig_this);
   return;
 }
#endif
 dict = PyObject_GetAttrString(inst, (char*)"__dict__");
 PyDict_SetItem(dict, SWIG_This(), swig_this);
 Py_DECREF(dict);
} 


SWIGINTERN PyObject *
SWIG_Python_InitShadowInstance(PyObject *args) {
  PyObject *obj[2];
  if (!SWIG_Python_UnpackTuple(args, "swiginit", 2, 2, obj)) {
    return NULL;
  } else {
    SwigPyObject *sthis = SWIG_Python_GetSwigThis(obj[0]);
    if (sthis) {
      SwigPyObject_append((PyObject*) sthis, obj[1]);
    } else {
      SWIG_Python_SetSwigThis(obj[0], obj[1]);
    }
    return SWIG_Py_Void();
  }
}

/* Create a new pointer object */

SWIGRUNTIME PyObject *
SWIG_Python_NewPointerObj(PyObject *self, void *ptr, swig_type_info *type, int flags) {
  SwigPyClientData *clientdata;
  PyObject * robj;
  int own;

  if (!ptr)
    return SWIG_Py_Void();

  clientdata = type ? (SwigPyClientData *)(type->clientdata) : 0;
  own = (flags & SWIG_POINTER_OWN) ? SWIG_POINTER_OWN : 0;
  if (clientdata && clientdata->pytype) {
    SwigPyObject *newobj;
    if (flags & SWIG_BUILTIN_TP_INIT) {
      newobj = (SwigPyObject*) self;
      if (newobj->ptr) {
        PyObject *next_self = clientdata->pytype->tp_alloc(clientdata->pytype, 0);
        while (newobj->next)
	  newobj = (SwigPyObject *) newobj->next;
        newobj->next = next_self;
        newobj = (SwigPyObject *)next_self;
#ifdef SWIGPYTHON_BUILTIN
        newobj->dict = 0;
#endif
      }
    } else {
      newobj = PyObject_New(SwigPyObject, clientdata->pytype);
#ifdef SWIGPYTHON_BUILTIN
      newobj->dict = 0;
#endif
    }
    if (newobj) {
      newobj->ptr = ptr;
      newobj->ty = type;
      newobj->own = own;
      newobj->next = 0;
      return (PyObject*) newobj;
    }
    return SWIG_Py_Void();
  }

  assert(!(flags & SWIG_BUILTIN_TP_INIT));

  robj = SwigPyObject_New(ptr, type, own);
  if (robj && clientdata && !(flags & SWIG_POINTER_NOSHADOW)) {
    PyObject *inst = SWIG_Python_NewShadowInstance(clientdata, robj);
    Py_DECREF(robj);
    robj = inst;
  }
  return robj;
}

/* Create a new packed object */

SWIGRUNTIMEINLINE PyObject *
SWIG_Python_NewPackedObj(void *ptr, size_t sz, swig_type_info *type) {
  return ptr ? SwigPyPacked_New((void *) ptr, sz, type) : SWIG_Py_Void();
}

/* -----------------------------------------------------------------------------*
 *  Get type list 
 * -----------------------------------------------------------------------------*/

#ifdef SWIG_LINK_RUNTIME
void *SWIG_ReturnGlobalTypeList(void *);
#endif

SWIGRUNTIME swig_module_info *
SWIG_Python_GetModule(void *SWIGUNUSEDPARM(clientdata)) {
  static void *type_pointer = (void *)0;
  /* first check if module already created */
  if (!type_pointer) {
#ifdef SWIG_LINK_RUNTIME
    type_pointer = SWIG_ReturnGlobalTypeList((void *)0);
#else
# ifdef SWIGPY_USE_CAPSULE
    type_pointer = PyCapsule_Import(SWIGPY_CAPSULE_NAME, 0);
# else
    type_pointer = PyCObject_Import((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION,
				    (char*)"type_pointer" SWIG_TYPE_TABLE_NAME);
# endif
    if (PyErr_Occurred()) {
      PyErr_Clear();
      type_pointer = (void *)0;
    }
#endif
  }
  return (swig_module_info *) type_pointer;
}

#if PY_MAJOR_VERSION < 2
/* PyModule_AddObject function was introduced in Python 2.0.  The following function
   is copied out of Python/modsupport.c in python version 2.3.4 */
SWIGINTERN int
PyModule_AddObject(PyObject *m, char *name, PyObject *o)
{
  PyObject *dict;
  if (!PyModule_Check(m)) {
    PyErr_SetString(PyExc_TypeError, "PyModule_AddObject() needs module as first arg");
    return SWIG_ERROR;
  }
  if (!o) {
    PyErr_SetString(PyExc_TypeError, "PyModule_AddObject() needs non-NULL value");
    return SWIG_ERROR;
  }
  
  dict = PyModule_GetDict(m);
  if (dict == NULL) {
    /* Internal error -- modules must have a dict! */
    PyErr_Format(PyExc_SystemError, "module '%s' has no __dict__",
		 PyModule_GetName(m));
    return SWIG_ERROR;
  }
  if (PyDict_SetItemString(dict, name, o))
    return SWIG_ERROR;
  Py_DECREF(o);
  return SWIG_OK;
}
#endif

SWIGRUNTIME void
#ifdef SWIGPY_USE_CAPSULE
SWIG_Python_DestroyModule(PyObject *obj)
#else
SWIG_Python_DestroyModule(void *vptr)
#endif
{
#ifdef SWIGPY_USE_CAPSULE
  swig_module_info *swig_module = (swig_module_info *) PyCapsule_GetPointer(obj, SWIGPY_CAPSULE_NAME);
#else
  swig_module_info *swig_module = (swig_module_info *) vptr;
#endif
  swig_type_info **types = swig_module->types;
  size_t i;
  for (i =0; i < swig_module->size; ++i) {
    swig_type_info *ty = types[i];
    if (ty->owndata) {
      SwigPyClientData *data = (SwigPyClientData *) ty->clientdata;
      if (data) SwigPyClientData_Del(data);
    }
  }
  Py_DECREF(SWIG_This());
  swig_this = NULL;
}

SWIGRUNTIME void
SWIG_Python_SetModule(swig_module_info *swig_module) {
#if PY_VERSION_HEX >= 0x03000000
 /* Add a dummy module object into sys.modules */
  PyObject *module = PyImport_AddModule((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION);
#else
  static PyMethodDef swig_empty_runtime_method_table[] = { {NULL, NULL, 0, NULL} }; /* Sentinel */
  PyObject *module = Py_InitModule((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION, swig_empty_runtime_method_table);
#endif
#ifdef SWIGPY_USE_CAPSULE
  PyObject *pointer = PyCapsule_New((void *) swig_module, SWIGPY_CAPSULE_NAME, SWIG_Python_DestroyModule);
  if (pointer && module) {
    PyModule_AddObject(module, (char*)"type_pointer_capsule" SWIG_TYPE_TABLE_NAME, pointer);
  } else {
    Py_XDECREF(pointer);
  }
#else
  PyObject *pointer = PyCObject_FromVoidPtr((void *) swig_module, SWIG_Python_DestroyModule);
  if (pointer && module) {
    PyModule_AddObject(module, (char*)"type_pointer" SWIG_TYPE_TABLE_NAME, pointer);
  } else {
    Py_XDECREF(pointer);
  }
#endif
}

/* The python cached type query */
SWIGRUNTIME PyObject *
SWIG_Python_TypeCache(void) {
  static PyObject *SWIG_STATIC_POINTER(cache) = PyDict_New();
  return cache;
}

SWIGRUNTIME swig_type_info *
SWIG_Python_TypeQuery(const char *type)
{
  PyObject *cache = SWIG_Python_TypeCache();
  PyObject *key = SWIG_Python_str_FromChar(type); 
  PyObject *obj = PyDict_GetItem(cache, key);
  swig_type_info *descriptor;
  if (obj) {
#ifdef SWIGPY_USE_CAPSULE
    descriptor = (swig_type_info *) PyCapsule_GetPointer(obj, NULL);
#else
    descriptor = (swig_type_info *) PyCObject_AsVoidPtr(obj);
#endif
  } else {
    swig_module_info *swig_module = SWIG_GetModule(0);
    descriptor = SWIG_TypeQueryModule(swig_module, swig_module, type);
    if (descriptor) {
#ifdef SWIGPY_USE_CAPSULE
      obj = PyCapsule_New((void*) descriptor, NULL, NULL);
#else
      obj = PyCObject_FromVoidPtr(descriptor, NULL);
#endif
      PyDict_SetItem(cache, key, obj);
      Py_DECREF(obj);
    }
  }
  Py_DECREF(key);
  return descriptor;
}

/* 
   For backward compatibility only
*/
#define SWIG_POINTER_EXCEPTION  0
#define SWIG_arg_fail(arg)      SWIG_Python_ArgFail(arg)
#define SWIG_MustGetPtr(p, type, argnum, flags)  SWIG_Python_MustGetPtr(p, type, argnum, flags)

SWIGRUNTIME int
SWIG_Python_AddErrMesg(const char* mesg, int infront)
{  
  if (PyErr_Occurred()) {
    PyObject *type = 0;
    PyObject *value = 0;
    PyObject *traceback = 0;
    PyErr_Fetch(&type, &value, &traceback);
    if (value) {
      char *tmp;
      PyObject *old_str = PyObject_Str(value);
      Py_XINCREF(type);
      PyErr_Clear();
      if (infront) {
	PyErr_Format(type, "%s %s", mesg, tmp = SWIG_Python_str_AsChar(old_str));
      } else {
	PyErr_Format(type, "%s %s", tmp = SWIG_Python_str_AsChar(old_str), mesg);
      }
      SWIG_Python_str_DelForPy3(tmp);
      Py_DECREF(old_str);
    }
    return 1;
  } else {
    return 0;
  }
}
  
SWIGRUNTIME int
SWIG_Python_ArgFail(int argnum)
{
  if (PyErr_Occurred()) {
    /* add information about failing argument */
    char mesg[256];
    PyOS_snprintf(mesg, sizeof(mesg), "argument number %d:", argnum);
    return SWIG_Python_AddErrMesg(mesg, 1);
  } else {
    return 0;
  }
}

SWIGRUNTIMEINLINE const char *
SwigPyObject_GetDesc(PyObject *self)
{
  SwigPyObject *v = (SwigPyObject *)self;
  swig_type_info *ty = v ? v->ty : 0;
  return ty ? ty->str : "";
}

SWIGRUNTIME void
SWIG_Python_TypeError(const char *type, PyObject *obj)
{
  if (type) {
#if defined(SWIG_COBJECT_TYPES)
    if (obj && SwigPyObject_Check(obj)) {
      const char *otype = (const char *) SwigPyObject_GetDesc(obj);
      if (otype) {
	PyErr_Format(PyExc_TypeError, "a '%s' is expected, 'SwigPyObject(%s)' is received",
		     type, otype);
	return;
      }
    } else 
#endif      
    {
      const char *otype = (obj ? obj->ob_type->tp_name : 0); 
      if (otype) {
	PyObject *str = PyObject_Str(obj);
	const char *cstr = str ? SWIG_Python_str_AsChar(str) : 0;
	if (cstr) {
	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s(%s)' is received",
		       type, otype, cstr);
          SWIG_Python_str_DelForPy3(cstr);
	} else {
	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s' is received",
		       type, otype);
	}
	Py_XDECREF(str);
	return;
      }
    }   
    PyErr_Format(PyExc_TypeError, "a '%s' is expected", type);
  } else {
    PyErr_Format(PyExc_TypeError, "unexpected type is received");
  }
}


/* Convert a pointer value, signal an exception on a type mismatch */
SWIGRUNTIME void *
SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int SWIGUNUSEDPARM(argnum), int flags) {
  void *result;
  if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {
    PyErr_Clear();
#if SWIG_POINTER_EXCEPTION
    if (flags) {
      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
      SWIG_Python_ArgFail(argnum);
    }
#endif
  }
  return result;
}

#ifdef SWIGPYTHON_BUILTIN
SWIGRUNTIME int
SWIG_Python_NonDynamicSetAttr(PyObject *obj, PyObject *name, PyObject *value) {
  PyTypeObject *tp = obj->ob_type;
  PyObject *descr;
  PyObject *encoded_name;
  descrsetfunc f;
  int res = -1;

# ifdef Py_USING_UNICODE
  if (PyString_Check(name)) {
    name = PyUnicode_Decode(PyString_AsString(name), PyString_Size(name), NULL, NULL);
    if (!name)
      return -1;
  } else if (!PyUnicode_Check(name))
# else
  if (!PyString_Check(name))
# endif
  {
    PyErr_Format(PyExc_TypeError, "attribute name must be string, not '%.200s'", name->ob_type->tp_name);
    return -1;
  } else {
    Py_INCREF(name);
  }

  if (!tp->tp_dict) {
    if (PyType_Ready(tp) < 0)
      goto done;
  }

  descr = _PyType_Lookup(tp, name);
  f = NULL;
  if (descr != NULL)
    f = descr->ob_type->tp_descr_set;
  if (!f) {
    if (PyString_Check(name)) {
      encoded_name = name;
      Py_INCREF(name);
    } else {
      encoded_name = PyUnicode_AsUTF8String(name);
    }
    PyErr_Format(PyExc_AttributeError, "'%.100s' object has no attribute '%.200s'", tp->tp_name, PyString_AsString(encoded_name));
    Py_DECREF(encoded_name);
  } else {
    res = f(descr, obj, value);
  }
  
  done:
  Py_DECREF(name);
  return res;
}
#endif


#ifdef __cplusplus
}
#endif



#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 

#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 



  #define SWIG_exception(code, msg) do { SWIG_Error(code, msg); SWIG_fail;; } while(0) 


/* -------- TYPES TABLE (BEGIN) -------- */

#define SWIGTYPE_p_AffineVariationalInequalities swig_types[0]
#define SWIGTYPE_p_AlartCurnierParams swig_types[1]
#define SWIGTYPE_p_CSparseMatrix_lu_factors swig_types[2]
#define SWIGTYPE_p_Callback swig_types[3]
#define SWIGTYPE_p_ConvexQP swig_types[4]
#define SWIGTYPE_p_FILE swig_types[5]
#define SWIGTYPE_p_FrictionContactProblem swig_types[6]
#define SWIGTYPE_p_GAMS_opt_bool_ swig_types[7]
#define SWIGTYPE_p_GAMS_opt_double_ swig_types[8]
#define SWIGTYPE_p_GAMS_opt_int_ swig_types[9]
#define SWIGTYPE_p_GAMS_opt_str_ swig_types[10]
#define SWIGTYPE_p_GlobalFrictionContactProblem swig_types[11]
#define SWIGTYPE_p_LinearComplementarityProblem swig_types[12]
#define SWIGTYPE_p_MixedComplementarityProblem swig_types[13]
#define SWIGTYPE_p_MixedComplementarityProblem2 swig_types[14]
#define SWIGTYPE_p_MixedLinearComplementarityProblem swig_types[15]
#define SWIGTYPE_p_NM_gesv_opts swig_types[16]
#define SWIGTYPE_p_NSM_linear_solver swig_types[17]
#define SWIGTYPE_p_NSM_linear_solver_params swig_types[18]
#define SWIGTYPE_p_NonlinearComplementarityProblem swig_types[19]
#define SWIGTYPE_p_NumericsMatrix swig_types[20]
#define SWIGTYPE_p_NumericsMatrixInternalData swig_types[21]
#define SWIGTYPE_p_NumericsMatrix_types swig_types[22]
#define SWIGTYPE_p_NumericsSparseMatrix swig_types[23]
#define SWIGTYPE_p_NumericsSparseOrigin swig_types[24]
#define SWIGTYPE_p_NumericsSparseTypesNZ swig_types[25]
#define SWIGTYPE_p_RelayProblem swig_types[26]
#define SWIGTYPE_p_SBM_index_by_column swig_types[27]
#define SWIGTYPE_p_SN_GAMS_NM_gdx_ swig_types[28]
#define SWIGTYPE_p_SN_GAMS_NV_gdx_ swig_types[29]
#define SWIGTYPE_p_SN_GAMS_gdx swig_types[30]
#define SWIGTYPE_p_SN_GAMSparams swig_types[31]
#define SWIGTYPE_p_SecondOrderConeLinearComplementarityProblem swig_types[32]
#define SWIGTYPE_p_SolverOptions swig_types[33]
#define SWIGTYPE_p_SparseBlockCoordinateMatrix swig_types[34]
#define SWIGTYPE_p_SparseBlockStructuredMatrix swig_types[35]
#define SWIGTYPE_p_SparseBlockStructuredMatrixPred swig_types[36]
#define SWIGTYPE_p_SplittedFrictionContactProblem swig_types[37]
#define SWIGTYPE_p_VariationalInequality swig_types[38]
#define SWIGTYPE_p_char swig_types[39]
#define SWIGTYPE_p_cs_di_numeric swig_types[40]
#define SWIGTYPE_p_cs_di_symbolic swig_types[41]
#define SWIGTYPE_p_cs_dl_numeric swig_types[42]
#define SWIGTYPE_p_cs_dl_sparse swig_types[43]
#define SWIGTYPE_p_cs_dl_symbolic swig_types[44]
#define SWIGTYPE_p_double swig_types[45]
#define SWIGTYPE_p_f_int_p_double_p_double__void swig_types[46]
#define SWIGTYPE_p_f_p_double_p_double_double_p_double_p_double_p_double_p_double__void swig_types[47]
#define SWIGTYPE_p_f_p_struct_linalg_data_t__void swig_types[48]
#define SWIGTYPE_p_f_p_void__void swig_types[49]
#define SWIGTYPE_p_f_p_void_int_p_double_p_NumericsMatrix__void swig_types[50]
#define SWIGTYPE_p_f_p_void_int_p_double_p_double__void swig_types[51]
#define SWIGTYPE_p_f_p_void_int_p_double_p_double_double_p_void__void swig_types[52]
#define SWIGTYPE_p_f_p_void_p_double_p_double__p_void swig_types[53]
#define SWIGTYPE_p_f_p_void_p_double_p_double__void swig_types[54]
#define SWIGTYPE_p_int swig_types[55]
#define SWIGTYPE_p_linalg_data_id swig_types[56]
#define SWIGTYPE_p_linalg_data_t swig_types[57]
#define SWIGTYPE_p_long swig_types[58]
#define SWIGTYPE_p_p_PyObject swig_types[59]
#define SWIGTYPE_p_p_double swig_types[60]
#define SWIGTYPE_p_p_f_int_p_FrictionContactProblem_p_FrictionContactProblem_p_double_p_SolverOptions__void swig_types[61]
#define SWIGTYPE_p_p_f_p_FrictionContactProblem_p_FrictionContactProblem_p_SolverOptions__void swig_types[62]
#define SWIGTYPE_p_p_f_p_FrictionContactProblem_p_double_p_SolverOptions__int swig_types[63]
#define SWIGTYPE_p_p_f_p_FrictionContactProblem_p_double_p_double_double_p_SolverOptions_double_p_double__void swig_types[64]
#define SWIGTYPE_p_p_int swig_types[65]
#define SWIGTYPE_p_polyhedron_set swig_types[66]
#define SWIGTYPE_p_size_t swig_types[67]
#define SWIGTYPE_p_uintptr_t swig_types[68]
#define SWIGTYPE_p_unsigned_int swig_types[69]
#define SWIGTYPE_p_void swig_types[70]
static swig_type_info *swig_types[72];
static swig_module_info swig_module = {swig_types, 71, 0, 0, 0, 0};
#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)

/* -------- TYPES TABLE (END) -------- */

#if (PY_VERSION_HEX <= 0x02000000)
# if !defined(SWIG_PYTHON_CLASSIC)
#  error "This python version requires swig to be run with the '-classic' option"
# endif
#endif

/*-----------------------------------------------
              @(target):= _numerics.so
  ------------------------------------------------*/
#if PY_VERSION_HEX >= 0x03000000
#  define SWIG_init    PyInit__numerics

#else
#  define SWIG_init    init_numerics

#endif
#define SWIG_name    "_numerics"

#define SWIGVERSION 0x030012 
#define SWIG_VERSION SWIGVERSION


#define SWIG_as_voidptr(a) (void *)((const void *)(a)) 
#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),(void**)(a)) 


#define SWIG_FILE_WITH_INIT

#ifdef __cplusplus
extern "C"
#endif

SWIGEXPORT
#if PY_VERSION_HEX >= 0x03000000
PyObject*
#else
void
#endif
SWIG_init(void);

#ifdef __cplusplus
#include <sstream>
#endif


#if defined(Py_COMPLEXOBJECT_H)
#undef c_sum
#undef c_diff
#undef c_neg
#undef c_prod
#undef c_quot
#undef c_pow
#undef c_abs
#endif

#include <assert.h>
//#define DEBUG_MESSAGES 1
#include <debug.h>
#include <numerics_verbose.h>

#if PY_VERSION_HEX < 0x02070000
#ifndef PyBytes_Check
#define PyBytes_Check PyString_Check
#define PyBytes_Size PyString_Size
#define PyBytes_AsString PyString_AsString
#define PyBytes_AS_STRING PyString_AS_STRING
#define PyBytes_GET_SIZE PyString_GET_SIZE
#endif

#ifndef PyCapsule_New
#define PyCapsule_New PyCObject_FromVoidPtrAndDesc
#define PyCapsule_CheckExact PyCObject_Check
#define PyCapsule_GetPointer(o, n) PyCObject_GetDesc((o))
#endif

#endif



#define SN_ARRAY_TYPE PyArrayObject
#define SN_OBJ_TYPE PyObject
#define TARGET_ERROR_VERBOSE PyErr_PrintEx(0)

#define C_to_target_lang1_detail(out, dim, cobj, FAILED_ACTION, CLASSID) \
{ \
  npy_intp pydims[] = { dim }; \
  out = FPyArray_SimpleNewFromData(1, pydims, CLASSID, cobj); \
  if (!out) { SWIG_Error(SWIG_RuntimeError, "Could not create an array from C object. Please file a bug"); FAILED_ACTION; } \
}

#define C_to_target_lang1(out, dim, cobj, FAILED_ACTION) C_to_target_lang1_detail(out, dim, cobj, FAILED_ACTION, NPY_DOUBLE)
#define C_to_target_lang1_int(out, dim, cobj, FAILED_ACTION) C_to_target_lang1_detail(out, dim, cobj, FAILED_ACTION, NPY_INT)

#define C_to_target_lang1_alloc(out, outarray, dim, FAILED_ACTION) \
{ \
  npy_intp pydims[] = { dim }; \
  outarray = PyArray_SimpleNew(1, pydims, NPY_DOUBLE); \
  if (!outarray) { SWIG_Error(SWIG_RuntimeError, "Could not create an array"); FAILED_ACTION; } \
  out = (double*) array_data(outarray); \
}

#define C_to_target_lang2_alloc(out, outarray, dim0, dim1, FAILED_ACTION) \
{ \
  npy_intp pydims[] = { dim0, dim1 }; \
  outarray = PyArray_SimpleNew(2, pydims, NPY_DOUBLE); \
  if (!outarray) { SWIG_Error(SWIG_RuntimeError, "Could not create an array"); FAILED_ACTION; } \
  out = (double*) array_data(outarray); \
}

#define C_to_target_lang2(out, dim0, dim1, cobj, FAILED_ACTION) \
{ \
  npy_intp pydims[] = { dim0, dim1 }; \
  out = FPyArray_SimpleNewFromData(2, pydims, NPY_DOUBLE, cobj); \
  if (!out) { SWIG_Error(SWIG_RuntimeError, "Could not create an array from C object. Please file a bug"); FAILED_ACTION; } \
}

#define sn_check_array_type(X, FAILED_ACTION) if (!X) { SWIG_Error(SWIG_RuntimeError, "Could not create an array from C object. Please file a bug"); FAILED_ACTION; }
#define sn_check_size_mat_vec(size, vec, FAILED_ACTION) if ((array_numdims(vec) == 1 && size != array_size(vec, 0)) || (array_numdims(vec) == 2 && size != array_size(vec, 0)*array_size(vec, 1) && (array_size(vec, 0)==1 || array_size(vec, 1)==1))) { SWIG_Error(SWIG_RuntimeError, "Matrix and vector given as arguments have different sizes"); FAILED_ACTION; }
#define sn_check_size_mat(dim0, dim1, mat, FAILED_ACTION) if (!CHECK_ARRAY_SIZE(dim0, mat, 0) || !CHECK_ARRAY_SIZE(dim1, mat, 1)) { SWIG_Error(SWIG_RuntimeError, "Matrix does not have the right size"); FAILED_ACTION; }

#define set_vec_from_target(dest, src, CTRL_ACTION, FAILED_ACTION) \
{ \
  size_t sizeB = array_size(src, 0) * sizeof(double); \
  if (dest) { SWIG_Error(SWIG_RuntimeError, "destination vector is already allocated"); FAILED_ACTION; } \
  dest = (double*)malloc(sizeB); \
  memcpy(dest, array_data(src), sizeB); \
}



#ifndef SWIG_FILE_WITH_INIT
#define NO_IMPORT_ARRAY
#endif
#include "stdio.h"
#define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION
#include <numpy/arrayobject.h>



#define FPyArray_SimpleNewFromData(nd, dims, typenum, data)             \
  PyArray_New(&PyArray_Type, nd, dims, typenum, NULL,                   \
              data, 0, NPY_ARRAY_FARRAY, NULL)



#include "tlsdef.h"
#include "sn_error_handling.h"

tlsvar char error_msg[2048];

static char* format_exception_msg(const char* first_line)
{
  strncpy(error_msg, first_line, strlen(first_line)+1);
  strncat(error_msg, "\n", 2);
  const char* sn_msg = sn_fatal_error_msg();
  strncat(error_msg, sn_msg, strlen(sn_msg) - 1);
  return error_msg;
}

static char* format_msg_concat(const char* msg1, const char* msg2)
{
  strncpy(error_msg, msg1, strlen(msg1)+1);
  strncat(error_msg, "\n", 2);
  strncat(error_msg, msg2, strlen(msg2));
  return error_msg;
}



#include "SiconosConfig.h"
#include "SiconosNumerics.h"
#include "SolverOptions.h"
#include "CSparseMatrix_internal.h"
#include "NumericsMatrix.h"
#include "SparseBlockMatrix.h"
#include "NumericsSparseMatrix.h"

#ifdef SWIGPYTHON
#include "Numerics_python_functions.h"
#endif /* SWIGPYTHON */

#ifdef SWIGMATLAB
#include "Numerics_matlab_functions.h"
#endif /* SWIGMATLAB */

#include "SiconosSets.h"
#include "GAMSlink.h"
#include "NumericsFwd.h"
  

  #define SWIG_From_long   PyInt_FromLong 


#ifdef __cplusplus
#if defined(SICONOS_STD_SHARED_PTR) && !defined(SICONOS_USE_BOOST_FOR_CXX11)
namespace std11 = std;
#include <memory>
#else
#include <boost/shared_ptr.hpp>
#include <boost/enable_shared_from_this.hpp>
namespace std11 = boost;
#endif
#endif



#define CHECK_ARRAY(X) \
!require_native(X)

#define CHECK_ARRAY_VECTOR(X) \
CHECK_ARRAY(X) || !require_contiguous(X) || !require_dimensions(X, 1)

#define CHECK_ARRAY_MATRIX(X) \
CHECK_ARRAY(X) || !require_fortran(X) || !require_dimensions(X, 2)

#define CHECK_ARRAY_SIZE(req_size, array, indx) (req_size == array_size(array, indx))

#define obj_to_sn_array(obj, alloc) obj_to_array_fortran_allow_conversion(obj, NPY_DOUBLE, alloc);
#define obj_to_sn_vector(obj, alloc) obj_to_array_contiguous_allow_conversion(obj, NPY_DOUBLE, alloc);


#define ALLOC_CTRL_I 0x1
#define ALLOC_CTRL_P 0x2

  static void NM_clean_cs(CSparseMatrix* m, int alloc_ctrl)
  {
    assert(m);
    if (alloc_ctrl & ALLOC_CTRL_P) { assert(m->p); free(m->p); }
    if (alloc_ctrl & ALLOC_CTRL_I) { assert(m->i); free(m->i); }
    // We do not own any data (we steal it from a numpy array)
    m->p = NULL;
    m->i = NULL;
    m->x = NULL;
  }

  static int NM_clean(NumericsMatrix* M, int alloc_ctrl)
  {
    switch (M->storageType)
    {
    case NM_DENSE:
    {
      // We do not own the data
      M->matrix0 = NULL;
      break;
    }
    case NM_SPARSE:
    {
      assert(M->matrix2);
      switch (M->matrix2->origin)
      {
      case NSM_CSC:
      {
        NM_clean_cs(M->matrix2->csc, alloc_ctrl);
        free(M->matrix2->csc);
        M->matrix2->csc = NULL;
        break;
      }
      case NSM_CSR:
      {
        NM_clean_cs(M->matrix2->csr, alloc_ctrl);
        free(M->matrix2->csr);
        M->matrix2->csr = NULL;
        break;
      }
      case NSM_TRIPLET:
      {
        NM_clean_cs(M->matrix2->triplet, alloc_ctrl);
        free(M->matrix2->triplet);
        M->matrix2->triplet = NULL;
        break;
      }
      default:
      {
        SWIG_Error(SWIG_RuntimeError, "The origin of the sparse matrix is unknown!");
        return 0;
      }
      }
      if (M->matrix2->trans_csc) { free(M->matrix2->trans_csc); M->matrix2->trans_csc = NULL; }
      if (M->matrix2->csc) { free(M->matrix2->csc); M->matrix2->csc = NULL; }
      if (M->matrix2->csr) { free(M->matrix2->csr); M->matrix2->csr = NULL;}
      if (M->matrix2->triplet) { free(M->matrix2->triplet); M->matrix2->triplet = NULL;}
      NM_clearSparse(M);
      break;
    }
    case NM_SPARSE_BLOCK:
    {
      // We do not own the data
      M->matrix1 = NULL;
      break;
    }
    default:
    {
      SWIG_Error(SWIG_RuntimeError, "NM_clean: unknown matrix storageType!");
      return 0;
    }
    }
    return 1;

  }


SWIGINTERNINLINE PyObject*
  SWIG_From_int  (int value)
{
  return PyInt_FromLong((long) value);
}


#include <limits.h>
#if !defined(SWIG_NO_LLONG_MAX)
# if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
#   define LLONG_MAX __LONG_LONG_MAX__
#   define LLONG_MIN (-LLONG_MAX - 1LL)
#   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
# endif
#endif


SWIGINTERN int
SWIG_AsVal_double (PyObject *obj, double *val)
{
  int res = SWIG_TypeError;
  if (PyFloat_Check(obj)) {
    if (val) *val = PyFloat_AsDouble(obj);
    return SWIG_OK;
#if PY_VERSION_HEX < 0x03000000
  } else if (PyInt_Check(obj)) {
    if (val) *val = (double) PyInt_AsLong(obj);
    return SWIG_OK;
#endif
  } else if (PyLong_Check(obj)) {
    double v = PyLong_AsDouble(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    double d = PyFloat_AsDouble(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = d;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      long v = PyLong_AsLong(obj);
      if (!PyErr_Occurred()) {
	if (val) *val = v;
	return SWIG_AddCast(SWIG_AddCast(SWIG_OK));
      } else {
	PyErr_Clear();
      }
    }
  }
#endif
  return res;
}


#include <float.h>


#include <math.h>


SWIGINTERNINLINE int
SWIG_CanCastAsInteger(double *d, double min, double max) {
  double x = *d;
  if ((min <= x && x <= max)) {
   double fx = floor(x);
   double cx = ceil(x);
   double rd =  ((x - fx) < 0.5) ? fx : cx; /* simple rint */
   if ((errno == EDOM) || (errno == ERANGE)) {
     errno = 0;
   } else {
     double summ, reps, diff;
     if (rd < x) {
       diff = x - rd;
     } else if (rd > x) {
       diff = rd - x;
     } else {
       return 1;
     }
     summ = rd + x;
     reps = diff/summ;
     if (reps < 8*DBL_EPSILON) {
       *d = rd;
       return 1;
     }
   }
  }
  return 0;
}


SWIGINTERN int
SWIG_AsVal_long (PyObject *obj, long* val)
{
#if PY_VERSION_HEX < 0x03000000
  if (PyInt_Check(obj)) {
    if (val) *val = PyInt_AsLong(obj);
    return SWIG_OK;
  } else
#endif
  if (PyLong_Check(obj)) {
    long v = PyLong_AsLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
      return SWIG_OverflowError;
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    long v = PyInt_AsLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      double d;
      int res = SWIG_AddCast(SWIG_AsVal_double (obj,&d));
      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, LONG_MIN, LONG_MAX)) {
	if (val) *val = (long)(d);
	return res;
      }
    }
  }
#endif
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_int (PyObject * obj, int *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < INT_MIN || v > INT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = (int)(v);
    }
  }  
  return res;
}



#include "CSparseMatrix.h"

static inline bool sane_pyseq_check(PyObject *o)
{
  if (PySequence_Check(o) && (PyList_Check(o) || PyTuple_Check(o)))
  {
    PyObject* elt = PySequence_GetItem(o, 0);
    if (elt && (PyInt_Check(elt) || PyFloat_Check(elt)))
    {
      Py_DECREF(elt);
      return true;
    }
    Py_XDECREF(elt);
  }
  return false;
}
#define CHECK_PYINT(PYSEQ, INDX, OUT) \
  PyObject *_TEMP##OUT = PySequence_GetItem(PYSEQ, INDX);                 \
  if (!PyInt_Check(_TEMP##OUT))                                         \
  {                                                                     \
    Py_XDECREF(_TEMP##OUT);                                             \
    PyErr_SetString(PyExc_RuntimeError, "expecting an int for " # OUT);       \
    PyObject_Print(PYSEQ, stderr, 0);                                     \
  }                                                                     \
  OUT = PyInt_AsLong(_TEMP##OUT);                                   \
  Py_DECREF(_TEMP##OUT)


#ifndef NDEBUG
static inline void _sn_check_nnz(PyObject** mat, CSparseMatrix *M)
{
  if (!*mat) { return; }
  PyObject *auto_nnz = PyObject_GetAttrString(*mat, "nnz");
  CS_INT nz;
  if (M->nz >= 0) { nz = M->nz; } else { nz = M->nzmax; }
  if(PyInt_AsLong(auto_nnz) != nz) {  PyErr_SetString(PyExc_RuntimeError, "number of nnz is inconsistent"); *mat = NULL; }
  Py_XDECREF(auto_nnz);
}

static inline void _sn_check_shape(PyObject** mat, CSparseMatrix *M)
{
  if (!*mat) { return; }
  PyObject *shape_ = PyObject_GetAttrString(*mat, "shape");
  unsigned nrows, ncols;
  CHECK_PYINT(shape_, 0, nrows);
  CHECK_PYINT(shape_, 1, ncols);

  Py_DECREF(shape_);

  if (nrows != M->m) { PyErr_SetString(PyExc_RuntimeError, "number of rows is inconsistent"); *mat = NULL;}
  if (ncols != M->n) { PyErr_SetString(PyExc_RuntimeError, "number of columns is inconsistent"); *mat = NULL;}
}
#else
static inline void _sn_check_nnz(PyObject** mat, CSparseMatrix *M) {};
static inline void _sn_check_shape(PyObject** mat, CSparseMatrix *M) {};
#endif

#include "SiconosConfig.h"
#include "debug.h"
// Work-around for "disappearing" SICONOS_INT64 problem in use of
// %#ifdef below
#ifdef SICONOS_INT64
#define _SICONOS_INT64
#endif

#if defined(SICONOS_INT64) && !defined(SICONOS_FORCE_NPY_INT32)
#define NPY_INT_TYPE NPY_INT64
#else
#define NPY_INT_TYPE NPY_INT32
#endif

#if defined(SICONOS_FORCE_NPY_INT32) && defined(SICONOS_INT64)

#define INT_TO_NPY_INT(dim, intp, out, copy) \
  { \
  int32_t* int32p = (int32_t*) malloc(dim[0] * sizeof(int32_t)); \
  if (!int32p) {  PyErr_SetString(PyExc_RuntimeError, "Could not allocate memory to convert " # intp "to 32 bits"); return NULL; }; \
  for (size_t i = 0; i < (size_t)dim[0]; ++i) { int32p[i] = intp[i]; }        \
  out  = PyArray_SimpleNewFromData(1, dim, NPY_INT_TYPE, int32p); \
  if(!out) {  PyErr_SetString(PyExc_RuntimeError, "Could not extract " # intp); return NULL; }; \
  PyArray_UpdateFlags((PyArrayObject*)out, NPY_ARRAY_OWNDATA); \
  }

#else

#define INT_TO_NPY_INT(dim, intp, out, copy) \
  { \
  CS_INT * int_p; \
  if (copy) \
  { \
    int_p = (CS_INT*)malloc(dim[0] * sizeof(CS_INT)); \
    memcpy(int_p, intp, dim[0] * sizeof(CS_INT)); \
  } \
  else \
  { \
    int_p = intp; \
  } \
  out  = PyArray_SimpleNewFromData(1, dim, NPY_INT_TYPE, int_p); \
  if(!out) {  PyErr_SetString(PyExc_RuntimeError, "Could not extract " # intp); return NULL; }; \
  if (copy) { PyArray_UpdateFlags((PyArrayObject*)out, NPY_ARRAY_OWNDATA); } \
  } \

#endif

#define CS_TO_SCIPY(TYPE, P_LEN, copy) \
  if (!M) \
  { \
    Py_INCREF(Py_None); \
    return Py_None; \
  } \
  else \
  { \
    /* get sys.modules dict */ \
    PyObject* sys_mod_dict = PyImport_GetModuleDict(); \
\
    /* get the csr module object */ \
    PyObject* scipy_mod = PyMapping_GetItemString(sys_mod_dict, (char *)"scipy.sparse." #TYPE);\
\
    if (!scipy_mod) \
    { \
      PyErr_SetString(PyExc_RuntimeError, "Did you import scipy.sparse." #TYPE "?"); \
      return NULL; \
    } \
\
    npy_intp this_M_x_dims[1] = { M->nzmax }; \
    npy_intp this_M_i_dims[1] = { M->nzmax }; \
    npy_intp this_M_p_dims[1] = { P_LEN + 1 }; \
\
    double* data_p; \
    if (copy) \
    { \
      data_p = (double*)malloc(M->nzmax * sizeof(double)); \
      memcpy(data_p, M->x, M->nzmax * sizeof(double)); \
    } \
    else \
    { \
      data_p = M->x; \
    } \
\
    PyObject* out_data = PyArray_SimpleNewFromData(1, this_M_x_dims, NPY_DOUBLE, data_p); \
    if(!out_data) { PyErr_SetString(PyExc_RuntimeError, "Could not extract M->x"); return NULL; }; \
    if (copy) { PyArray_UpdateFlags((PyArrayObject*)out_data, NPY_ARRAY_OWNDATA); } \
\
    PyObject* out_indices; \
    INT_TO_NPY_INT(this_M_i_dims, M->i, out_indices, copy); \
\
    PyObject* out_indptr ; \
    INT_TO_NPY_INT(this_M_p_dims, M->p, out_indptr, copy); \
\
    /* Warning ! m is the number of rows, n the number of columns ! --xhub */ \
    PyObject* out_shape = PyTuple_Pack(2, PyInt_FromLong(M->m), PyInt_FromLong(M->n)); \
    if(!out_shape) {  PyErr_SetString(PyExc_RuntimeError, "Could not extract M->m or M->n"); return NULL; }; \
\
    PyObject* out_nnz = PyInt_FromLong(M->nzmax); \
    if(!out_nnz) {  PyErr_SetString(PyExc_RuntimeError, "Could not extract M->nzmax"); return NULL; }; \
\
    /* call the class inside the csr module */ \
    PyObject* out_mat = PyObject_CallMethodObjArgs(scipy_mod, PyString_FromString((char *) #TYPE "_matrix"), out_shape, NULL); \
\
    if(out_mat) \
    { \
      PyObject_SetAttrString(out_mat,"data", out_data); \
      PyObject_SetAttrString(out_mat,"indices", out_indices); \
      PyObject_SetAttrString(out_mat,"indptr", out_indptr); \
\
      _sn_check_nnz(&out_mat, M); \
      _sn_check_shape(&out_mat, M); \
\
      return out_mat; \
    } \
    else \
    { \
      PyErr_SetString(PyExc_RuntimeError, "Could not create " #TYPE " matrix"); \
      return NULL; \
    } \
  }

static inline bool is_Pyobject_scipy_sparse_matrix(PyObject* o, PyObject* scipy_mod)
 {
    bool ret;
    PyObject* res = PyObject_CallMethodObjArgs(scipy_mod, PyString_FromString("issparse"), o, NULL);

    if (!res) return false;

    ret = (res == Py_True);
    Py_DECREF(res);

    return ret;
}



SWIGINTERNINLINE PyObject*
  SWIG_From_bool  (bool value)
{
  return PyBool_FromLong(value ? 1 : 0);
}


SWIGINTERN int
SWIG_AsVal_unsigned_SS_long (PyObject *obj, unsigned long *val) 
{
#if PY_VERSION_HEX < 0x03000000
  if (PyInt_Check(obj)) {
    long v = PyInt_AsLong(obj);
    if (v >= 0) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      return SWIG_OverflowError;
    }
  } else
#endif
  if (PyLong_Check(obj)) {
    unsigned long v = PyLong_AsUnsignedLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
      return SWIG_OverflowError;
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    unsigned long v = PyLong_AsUnsignedLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      double d;
      int res = SWIG_AddCast(SWIG_AsVal_double (obj,&d));
      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, 0, ULONG_MAX)) {
	if (val) *val = (unsigned long)(d);
	return res;
      }
    }
  }
#endif
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_unsigned_SS_int (PyObject * obj, unsigned int *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v > UINT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = (unsigned int)(v);
    }
  }  
  return res;
}


#include "Newton_methods.h"


  static int convert_iarray(PyObject *input, int *ptr) {
  int i = 0;
  if (!PySequence_Check(input)) {
      PyErr_SetString(PyExc_TypeError,"Expecting a sequence");
      return 0;
  }
  for (i =0; i <  PyObject_Length(input); i++) {
      PyObject *o = PySequence_GetItem(input,i);
      if (!PyInt_Check(o)) {
        Py_XDECREF(o);
        PyErr_SetString(PyExc_ValueError,"Expecting a sequence of ints");
        return 0;
      }
      ptr[i] = (int) PyInt_AsLong(o);

      if (ptr[i] == -1 && PyErr_Occurred())
        return 0;
      Py_DECREF(o);
  }
  return 1;
}


static int convert_darray(PyObject *input, double *ptr) {
  int i = 0;
  if (!PySequence_Check(input)) {
      PyErr_SetString(PyExc_TypeError,"Expecting a sequence");
      return 0;
  }

  for (i =0; i < PyObject_Length(input); ++i) {
      PyObject *o = PySequence_GetItem(input,i);
      if (!PyFloat_Check(o)) {
         Py_XDECREF(o);
         PyErr_SetString(PyExc_ValueError,"Expecting a sequence of floats");
         return 0;
      }
      ptr[i] = PyFloat_AsDouble(o);

      if (ptr[i] == -1 && PyErr_Occurred())
        return 0;

      Py_DECREF(o);
  }
  return 1;
  
}



#if defined(__GNUC__)
#pragma GCC diagnostic push
#ifdef __cplusplus
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#else
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#endif
#endif

#if NPY_API_VERSION < 0x00000007
#define NPY_ARRAY_DEFAULT NPY_DEFAULT
#define NPY_ARRAY_FARRAY  NPY_FARRAY
#define NPY_ARRAY_F_CONTIGUOUS NPY_F_CONTIGUOUS
#endif


/* Macros to extract array attributes.
 */
#if NPY_API_VERSION < 0x00000007
#define is_array(a)            ((a) && PyArray_Check((PyArrayObject*)a))
#define array_type(a)          (int)(PyArray_TYPE((PyArrayObject*)a))
#define array_numdims(a)       (((PyArrayObject*)a)->nd)
#define array_dimensions(a)    (((PyArrayObject*)a)->dimensions)
npy_intp array_size(PyArrayObject *a, int i) { return ((PyArrayObject*)a)->dimensions[i]; }
#define array_strides(a)       (((PyArrayObject*)a)->strides)
#define array_stride(a,i)      (((PyArrayObject*)a)->strides[i])
#define array_data(a)          (((PyArrayObject*)a)->data)
#define array_descr(a)         (((PyArrayObject*)a)->descr)
#define array_flags(a)         (((PyArrayObject*)a)->flags)
#define array_enableflags(a,f) (((PyArrayObject*)a)->flags) = f
#else
#define is_array(a)            ((a) && PyArray_Check(a))
#define array_type(a)          PyArray_TYPE((PyArrayObject*)a)
#define array_numdims(a)       PyArray_NDIM((PyArrayObject*)a)
#define array_dimensions(a)    PyArray_DIMS((PyArrayObject*)a)
#define array_strides(a)       PyArray_STRIDES((PyArrayObject*)a)
#define array_stride(a,i)      PyArray_STRIDE((PyArrayObject*)a,i)
npy_intp array_size(PyArrayObject *a, int i) { return PyArray_DIM((PyArrayObject*)a,i); }
#define array_data(a)          PyArray_DATA((PyArrayObject*)a)
#define array_descr(a)         PyArray_DESCR((PyArrayObject*)a)
#define array_flags(a)         PyArray_FLAGS((PyArrayObject*)a)
#define array_enableflags(a,f) PyArray_ENABLEFLAGS((PyArrayObject*)a,f)
#endif
#define array_is_contiguous(a) (PyArray_ISCONTIGUOUS((PyArrayObject*)a))
#define array_is_native(a)     (PyArray_ISNOTSWAPPED((PyArrayObject*)a))
#define array_is_fortran(a)    (PyArray_ISFORTRAN((PyArrayObject*)a))


  /* Given a PyObject, return a string describing its type.
   */
  const char* pytype_string(PyObject* py_obj)
  {
    if (py_obj == NULL          ) return "C NULL value";
    if (py_obj == Py_None       ) return "Python None" ;
    if (PyCallable_Check(py_obj)) return "callable"    ;
    if (PyString_Check(  py_obj)) return "string"      ;
    if (PyInt_Check(     py_obj)) return "int"         ;
    if (PyFloat_Check(   py_obj)) return "float"       ;
    if (PyDict_Check(    py_obj)) return "dict"        ;
    if (PyList_Check(    py_obj)) return "list"        ;
    if (PyTuple_Check(   py_obj)) return "tuple"       ;
#if PY_MAJOR_VERSION < 3
    if (PyFile_Check(    py_obj)) return "file"        ;
    if (PyModule_Check(  py_obj)) return "module"      ;
    if (PyInstance_Check(py_obj)) return "instance"    ;
#endif

    return "unknown type";
  }

  /* Given a NumPy typecode, return a string describing the type.
   */
  const char* typecode_string(int typecode)
  {
    static const char* type_names[25] = {"bool",
                                         "byte",
                                         "unsigned byte",
                                         "short",
                                         "unsigned short",
                                         "int",
                                         "unsigned int",
                                         "long",
                                         "unsigned long",
                                         "long long",
                                         "unsigned long long",
                                         "float",
                                         "double",
                                         "long double",
                                         "complex float",
                                         "complex double",
                                         "complex long double",
                                         "object",
                                         "string",
                                         "unicode",
                                         "void",
                                         "ntypes",
                                         "notype",
                                         "char",
                                         "unknown"};
    return typecode < 24 ? type_names[typecode] : type_names[24];
  }

  /* Make sure input has correct numpy type.  This now just calls
     PyArray_EquivTypenums().
   */
  int type_match(int actual_type,
                 int desired_type)
  {
    return PyArray_EquivTypenums(actual_type, desired_type);
  }

#ifdef SWIGPY_USE_CAPSULE
  void free_cap(PyObject * cap)
  {
    void* array = (void*) PyCapsule_GetPointer(cap,SWIGPY_CAPSULE_NAME);
    if (array != NULL) free(array);
  }
#endif



  /* Given a PyObject pointer, cast it to a PyArrayObject pointer if
   * legal.  If not, set the python error string appropriately and
   * return NULL.
   */
  PyArrayObject* obj_to_array_no_conversion(PyObject* input,
                                            int        typecode)
  {
    PyArrayObject* ary = NULL;
    if (is_array(input) && (typecode == NPY_NOTYPE ||
                            PyArray_EquivTypenums(array_type(input), typecode)))
    {
      ary = (PyArrayObject*) input;
    }
    else if is_array(input)
    {
      const char* desired_type = typecode_string(typecode);
      const char* actual_type  = typecode_string(array_type(input));
      PyErr_Format(PyExc_TypeError,
                   "Array of type '%s' required.  Array of type '%s' given",
                   desired_type, actual_type);
      ary = NULL;
    }
    else
    {
      const char* desired_type = typecode_string(typecode);
      const char* actual_type  = pytype_string(input);
      PyErr_Format(PyExc_TypeError,
                   "Array of type '%s' required.  A '%s' was given",
                   desired_type,
                   actual_type);
      ary = NULL;
    }
    return ary;
  }

  /* Convert the given PyObject to a NumPy array with the given
   * typecode.  On success, return a valid PyArrayObject* with the
   * correct type.  On failure, the python error string will be set and
   * the routine returns NULL.
   */
  PyArrayObject* obj_to_array_allow_conversion(PyObject* input,
                                               int       typecode,
                                               int*      is_new_object)
  {
    PyArrayObject* ary = NULL;
    PyObject*      py_obj;
    if (is_array(input) && (typecode == NPY_NOTYPE ||
                            PyArray_EquivTypenums(array_type(input),typecode)))
    {
      ary = (PyArrayObject*) input;
      *is_new_object = 0;
    }
    else
    {
      py_obj = PyArray_FROMANY(input, typecode, 0, 0, NPY_ARRAY_DEFAULT);
      /* If NULL, PyArray_FromObject will have set python error value.*/
      ary = (PyArrayObject*) py_obj;
      *is_new_object = 1;
    }
    return ary;
  }

  /* Given a PyArrayObject, check to see if it is contiguous.  If so,
   * return the input pointer and flag it as not a new object.  If it is
   * not contiguous, create a new PyArrayObject using the original data,
   * flag it as a new object and return the pointer.
   */
  PyArrayObject* make_contiguous(PyArrayObject* ary,
                                 int*           is_new_object,
                                 int            min_dims,
                                 int            max_dims)
  {
    PyArrayObject* result;
    if (array_is_contiguous(ary))
    {
      result = ary;
      *is_new_object = 0;
    }
    else
    {
      result = (PyArrayObject*) PyArray_ContiguousFromObject((PyObject*)ary,
                                                              array_type(ary),
                                                              min_dims,
                                                              max_dims);
      *is_new_object = 1;
    }
    return result;
  }

  /* Given a PyArrayObject, check to see if it is Fortran-contiguous.
   * If so, return the input pointer, but do not flag it as not a new
   * object.  If it is not Fortran-contiguous, create a new
   * PyArrayObject using the original data, flag it as a new object
   * and return the pointer.
   */
  PyArrayObject* make_fortran(PyArrayObject* ary,
                              int*           is_new_object)
  {
    PyArrayObject* result;
    if (array_is_fortran(ary))
    {
      result = ary;
      *is_new_object = 0;
    }
    else
    {
      Py_INCREF(array_descr(ary));
      result = (PyArrayObject*) PyArray_FromArray(ary,
                                                  array_descr(ary),
                                                  NPY_ARRAY_F_CONTIGUOUS);
      *is_new_object = 1;
    }
    return result;
  }

  /* Convert a given PyObject to a contiguous PyArrayObject of the
   * specified type.  If the input object is not a contiguous
   * PyArrayObject, a new one will be created and the new object flag
   * will be set.
   */
  PyArrayObject* obj_to_array_contiguous_allow_conversion(PyObject* input,
                                                          int       typecode,
                                                          int*      is_new_object)
  {
    int is_new1 = 0;
    int is_new2 = 0;
    PyArrayObject* ary2;
    PyArrayObject* ary1 = obj_to_array_allow_conversion(input,
                                                        typecode,
                                                        &is_new1);
    if (ary1)
    {
      ary2 = make_contiguous(ary1, &is_new2, 0, 0);
      if ( is_new1 && is_new2)
      {
        Py_DECREF(ary1);
      }
      ary1 = ary2;
    }
    *is_new_object = is_new1 || is_new2;
    return ary1;
  }

  /* Convert a given PyObject to a Fortran-ordered PyArrayObject of the
   * specified type.  If the input object is not a Fortran-ordered
   * PyArrayObject, a new one will be created and the new object flag
   * will be set.
   */
  PyArrayObject* obj_to_array_fortran_allow_conversion(PyObject* input,
                                                       int       typecode,
                                                       int*      is_new_object)
  {
    int is_new1 = 0;
    int is_new2 = 0;
    PyArrayObject* ary2;
    PyArrayObject* ary1 = obj_to_array_allow_conversion(input,
                                                        typecode,
                                                        &is_new1);
    if (ary1)
    {
      ary2 = make_fortran(ary1, &is_new2);
      if (is_new1 && is_new2)
      {
        Py_DECREF(ary1);
      }
      ary1 = ary2;
    }
    *is_new_object = is_new1 || is_new2;
    return ary1;
  }


  /* Test whether a python object is contiguous.  If array is
   * contiguous, return 1.  Otherwise, set the python error string and
   * return 0.
   */
  int require_contiguous(PyArrayObject* ary)
  {
    int contiguous = 1;
    if (!array_is_contiguous(ary))
    {
      PyErr_SetString(PyExc_TypeError,
                      "Array must be contiguous.  A non-contiguous array was given");
      contiguous = 0;
    }
    return contiguous;
  }

  /* Require that a numpy array is not byte-swapped.  If the array is
   * not byte-swapped, return 1.  Otherwise, set the python error string
   * and return 0.
   */
  int require_native(PyArrayObject* ary)
  {
    int native = 1;
    if (!array_is_native(ary))
    {
      PyErr_SetString(PyExc_TypeError,
                      "Array must have native byteorder.  "
                      "A byte-swapped array was given");
      native = 0;
    }
    return native;
  }

  /* Require the given PyArrayObject to have a specified number of
   * dimensions.  If the array has the specified number of dimensions,
   * return 1.  Otherwise, set the python error string and return 0.
   */
  int require_dimensions(PyArrayObject* ary,
                         int            exact_dimensions)
  {
    int success = 1;
    if (array_numdims(ary) != exact_dimensions)
    {
      PyErr_Format(PyExc_TypeError,
                   "Array must have %d dimensions.  Given array has %d dimensions",
                   exact_dimensions,
                   array_numdims(ary));
      success = 0;
    }
    return success;
  }

  /* Require the given PyArrayObject to have one of a list of specified
   * number of dimensions.  If the array has one of the specified number
   * of dimensions, return 1.  Otherwise, set the python error string
   * and return 0.
   */
  int require_dimensions_n(PyArrayObject* ary,
                           int*           exact_dimensions,
                           int            n)
  {
    int success = 0;
    int i = 0;
    char dims_str[255] = "";
    char s[255];
    for (i = 0; i < n && !success; i++)
    {
      if (array_numdims(ary) == exact_dimensions[i])
      {
        success = 1;
      }
    }
    if (!success)
    {
      for (i = 0; i < n-1; i++)
      {
        sprintf(s, "%d, ", exact_dimensions[i]);
        strcat(dims_str,s);
      }
      sprintf(s, " or %d", exact_dimensions[n-1]);
      strcat(dims_str,s);
      PyErr_Format(PyExc_TypeError,
                   "Array must have %s dimensions.  Given array has %d dimensions",
                   dims_str,
                   array_numdims(ary));
    }
    return success;
  }

  /* Require the given PyArrayObject to have a specified shape.  If the
   * array has the specified shape, return 1.  Otherwise, set the python
   * error string and return 0.
   */
  int require_size(PyArrayObject* ary,
                   npy_intp*      size,
                   int            n)
  {
    int i = 0;
    int success = 1;
    int len = 0;
    char desired_dims[255] = "[";
    char s[255];
    char actual_dims[255] = "[";
    for(i=0; i < n;i++)
    {
      if (size[i] != -1 &&  size[i] != array_size(ary,i))
      {
        success = 0;
      }
    }
    if (!success)
    {
      for (i = 0; i < n; i++)
      {
        if (size[i] == -1)
        {
          sprintf(s, "*,");
        }
        else
        {
          sprintf(s, "%ld,", (long int)size[i]);
        }
        strcat(desired_dims,s);
      }
      len = strlen(desired_dims);
      desired_dims[len-1] = ']';
      for (i = 0; i < n; i++)
      {
        sprintf(s, "%ld,", (long int)array_size(ary,i));
        strcat(actual_dims,s);
      }
      len = strlen(actual_dims);
      actual_dims[len-1] = ']';
      PyErr_Format(PyExc_TypeError,
                   "Array must have shape of %s.  Given array has shape of %s",
                   desired_dims,
                   actual_dims);
    }
    return success;
  }

  /* Require the given PyArrayObject to to be Fortran ordered.  If the
   * the PyArrayObject is already Fortran ordered, do nothing.  Else,
   * set the Fortran ordering flag and recompute the strides.
   */
  int require_fortran(PyArrayObject* ary)
  {
    int success = 1;
    int nd = array_numdims(ary);
    int i = 0;
    npy_intp * strides = array_strides(ary);
    if (array_is_fortran(ary)) return success;
    /* Set the Fortran ordered flag */
    array_enableflags(ary,NPY_ARRAY_FARRAY);
    /* Recompute the strides */
    strides[0] = strides[nd-1];
    for (i=1; i < nd; ++i)
      strides[i] = strides[i-1] * array_size(ary,i-1);
    return success;
  }


#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif



  static void collectStatsIterationCallback(void *env,
                            int size, double* z,
                            double* Fz,
                            double error,
                            void* extra_data)
  {
    // A little bit of black magic
    PyObject* py_tuple;
    if (extra_data)
    {
      switch (*(int*)extra_data)
      {
        case NEWTON_STATS_ITERATION:
        {
          newton_stats* stats = (newton_stats*) extra_data;
          py_tuple = PyTuple_New(3);
          PyObject* py_merit_value = PyFloat_FromDouble(stats->merit_value);
          PyTuple_SetItem(py_tuple, 0, py_merit_value);
          PyObject* py_alpha =  PyFloat_FromDouble(stats->alpha);
          PyTuple_SetItem(py_tuple, 1, py_alpha);
          PyObject* py_status = PyTuple_New(2);
          PyObject* py_newton_step;
          if (stats->status & NEWTON_STATS_NEWTON_STEP)
          {
            Py_INCREF(Py_True);
            py_newton_step = Py_True;
          }
          else
          {
            Py_INCREF(Py_False);
            py_newton_step = Py_False;
          }
          PyTuple_SetItem(py_status, 0, py_newton_step);

          PyObject* py_desc_dir;
          if (stats->status & NEWTON_STATS_DESC_DIR)
          {
            Py_INCREF(Py_True);
            py_desc_dir = Py_True;
          }
          else
          {
            Py_INCREF(Py_False);
            py_desc_dir = Py_False;
          }
          PyTuple_SetItem(py_status, 1, py_desc_dir);

          PyTuple_SetItem(py_tuple, 2, py_status);
          break;
        }

        default:
          py_tuple = PyTuple_New(0);
      }
    }
    else
    {
      py_tuple = PyTuple_New(0);
    }
    if (PyCallable_Check((PyObject*) env))
    {

      npy_intp dim[1];
      dim[0] = size;

      PyObject* py_z = FPyArray_SimpleNewFromData(1, dim,
                                                  NPY_DOUBLE,
                                                  z);

      PyObject* py_Fz = FPyArray_SimpleNewFromData(1, dim,
                                                   NPY_DOUBLE,
                                                   Fz);

      PyObject* py_error = PyFloat_FromDouble(error);

      PyObject* py_args = PyTuple_New(4);
      PyTuple_SetItem(py_args, 0, py_z);
      PyTuple_SetItem(py_args, 1, py_Fz);
      PyTuple_SetItem(py_args, 2, py_error);
      PyTuple_SetItem(py_args, 3, py_tuple);

      PyGILState_STATE gstate;
      gstate = PyGILState_Ensure();

      PyObject* py_out = PyObject_CallObject((PyObject*) env, py_args);

      Py_DECREF(py_args);
      Py_XDECREF(py_out);

      PyGILState_Release(gstate);
    }
    else
    {
      PyErr_SetString(PyExc_TypeError,"Expecting a callable callback");
    }
  };



#include "SolverOptions.h"

SWIGINTERN struct SolverOptions *new_SolverOptions__SWIG_0(enum FRICTION_SOLVER id){
    SolverOptions *SO;
    SO = (SolverOptions *) malloc(sizeof(SolverOptions));

    /* cf Friction_cst.h */
    if(id >= 400 && id < 500)
    {
      fc2d_setDefaultSolverOptions(SO, id);
    }
    else if (id >= 500 && id < 600)
    {
      fc3d_setDefaultSolverOptions(SO, id);
    }
    else if (id >= 600 && id < 700)
    {
      gfc3d_setDefaultSolverOptions(SO, id);
    }
    else
    {
      SWIG_Error(SWIG_RuntimeError, "Unknown friction contact problem solver");
      free(SO);
      return NULL;
    }


    return SO;
  }
SWIGINTERN struct SolverOptions *new_SolverOptions__SWIG_1(SecondOrderConeLinearComplementarityProblem *soclcp,enum SOCLCP_SOLVER id){
    SolverOptions *SO;
    SO = (SolverOptions *) malloc(sizeof(SolverOptions));

    if (id >= 1100 && id < 1200)
    {
      soclcp_setDefaultSolverOptions(SO, id);
    }
    else
    {
      SWIG_Error(SWIG_RuntimeError, "Unknown SOCLCP solver");
      free(SO);
      return NULL;
    }


    return SO;
  }
SWIGINTERN struct SolverOptions *new_SolverOptions__SWIG_2(void){
    SolverOptions *SO;
    SO = (SolverOptions *) malloc(sizeof(SolverOptions));
    return SO;
  }
SWIGINTERN struct SolverOptions *new_SolverOptions__SWIG_3(LinearComplementarityProblem *lcp,enum LCP_SOLVER id){
    SolverOptions *SO;
    SO = (SolverOptions *) malloc(sizeof(SolverOptions));
    solver_options_set(SO, id);
    return SO;
  }
SWIGINTERN struct SolverOptions *new_SolverOptions__SWIG_4(MixedLinearComplementarityProblem *mlcp,enum MLCP_SOLVER id){
    SolverOptions *SO;
    SO = (SolverOptions *) malloc(sizeof(SolverOptions));
    SO->solverId=id;
    mixedLinearComplementarity_setDefaultSolverOptions(mlcp, SO);
    return SO;
  }
SWIGINTERN struct SolverOptions *new_SolverOptions__SWIG_5(MixedComplementarityProblem *mlcp,enum MCP_SOLVER id){
    SolverOptions *SO;
    SO = (SolverOptions *) malloc(sizeof(SolverOptions));
    SO->solverId=id;
    mixedComplementarity_setDefaultSolverOptions(mlcp, SO);
    return SO;
  }
SWIGINTERN struct SolverOptions *new_SolverOptions__SWIG_6(MixedComplementarityProblem2 *mcp,enum MCP_SOLVER id){
    SolverOptions *SO;
    SO = (SolverOptions *) malloc(sizeof(SolverOptions));
    solver_options_set(SO, id);
    return SO;
  }
SWIGINTERN struct SolverOptions *new_SolverOptions__SWIG_7(NonlinearComplementarityProblem *ncp,enum NCP_SOLVER id){
    SolverOptions *SO;
    SO = (SolverOptions *) malloc(sizeof(SolverOptions));
    solver_options_set(SO, id);
    return SO;
  }
SWIGINTERN struct SolverOptions *new_SolverOptions__SWIG_8(VariationalInequality *vi,enum VI_SOLVER id){
    SolverOptions *SO;
    SO = (SolverOptions *) malloc(sizeof(SolverOptions));
    solver_options_set(SO, id);
    return SO;
  }
SWIGINTERN struct SolverOptions *new_SolverOptions__SWIG_9(AffineVariationalInequalities *avi,enum AVI_SOLVER id){
    SolverOptions *SO;
    SO = (SolverOptions *) malloc(sizeof(SolverOptions));
    SO->solverId=id;
    solver_options_set(SO, id);
    return SO;
  }
SWIGINTERN void delete_SolverOptions(struct SolverOptions *self){
    solver_options_delete(self);
    free(self);
  }

SWIGINTERN swig_type_info*
SWIG_pchar_descriptor(void)
{
  static int init = 0;
  static swig_type_info* info = 0;
  if (!init) {
    info = SWIG_TypeQuery("_p_char");
    init = 1;
  }
  return info;
}


SWIGINTERNINLINE PyObject *
SWIG_FromCharPtrAndSize(const char* carray, size_t size)
{
  if (carray) {
    if (size > INT_MAX) {
      swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
      return pchar_descriptor ? 
	SWIG_InternalNewPointerObj((char *)(carray), pchar_descriptor, 0) : SWIG_Py_Void();
    } else {
#if PY_VERSION_HEX >= 0x03000000
#if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
      return PyBytes_FromStringAndSize(carray, (Py_ssize_t)(size));
#else
#if PY_VERSION_HEX >= 0x03010000
      return PyUnicode_DecodeUTF8(carray, (Py_ssize_t)(size), "surrogateescape");
#else
      return PyUnicode_FromStringAndSize(carray, (Py_ssize_t)(size));
#endif
#endif
#else
      return PyString_FromStringAndSize(carray, (Py_ssize_t)(size));
#endif
    }
  } else {
    return SWIG_Py_Void();
  }
}


SWIGINTERNINLINE PyObject * 
SWIG_FromCharPtr(const char *cptr)
{ 
  return SWIG_FromCharPtrAndSize(cptr, (cptr ? strlen(cptr) : 0));
}


SWIGINTERN int
SWIG_AsCharPtrAndSize(PyObject *obj, char** cptr, size_t* psize, int *alloc)
{
#if PY_VERSION_HEX>=0x03000000
#if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
  if (PyBytes_Check(obj))
#else
  if (PyUnicode_Check(obj))
#endif
#else  
  if (PyString_Check(obj))
#endif
  {
    char *cstr; Py_ssize_t len;
#if PY_VERSION_HEX>=0x03000000
#if !defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
    if (!alloc && cptr) {
        /* We can't allow converting without allocation, since the internal
           representation of string in Python 3 is UCS-2/UCS-4 but we require
           a UTF-8 representation.
           TODO(bhy) More detailed explanation */
        return SWIG_RuntimeError;
    }
    obj = PyUnicode_AsUTF8String(obj);
    if(alloc) *alloc = SWIG_NEWOBJ;
#endif
    PyBytes_AsStringAndSize(obj, &cstr, &len);
#else
    PyString_AsStringAndSize(obj, &cstr, &len);
#endif
    if (cptr) {
      if (alloc) {
	/* 
	   In python the user should not be able to modify the inner
	   string representation. To warranty that, if you define
	   SWIG_PYTHON_SAFE_CSTRINGS, a new/copy of the python string
	   buffer is always returned.

	   The default behavior is just to return the pointer value,
	   so, be careful.
	*/ 
#if defined(SWIG_PYTHON_SAFE_CSTRINGS)
	if (*alloc != SWIG_OLDOBJ) 
#else
	if (*alloc == SWIG_NEWOBJ) 
#endif
	{
	  *cptr = (char *)memcpy(malloc((len + 1)*sizeof(char)), cstr, sizeof(char)*(len + 1));
	  *alloc = SWIG_NEWOBJ;
	} else {
	  *cptr = cstr;
	  *alloc = SWIG_OLDOBJ;
	}
      } else {
#if PY_VERSION_HEX>=0x03000000
#if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
	*cptr = PyBytes_AsString(obj);
#else
	assert(0); /* Should never reach here with Unicode strings in Python 3 */
#endif
#else
	*cptr = SWIG_Python_str_AsChar(obj);
#endif
      }
    }
    if (psize) *psize = len + 1;
#if PY_VERSION_HEX>=0x03000000 && !defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
    Py_XDECREF(obj);
#endif
    return SWIG_OK;
  } else {
#if defined(SWIG_PYTHON_2_UNICODE)
#if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
#error "Cannot use both SWIG_PYTHON_2_UNICODE and SWIG_PYTHON_STRICT_BYTE_CHAR at once"
#endif
#if PY_VERSION_HEX<0x03000000
    if (PyUnicode_Check(obj)) {
      char *cstr; Py_ssize_t len;
      if (!alloc && cptr) {
        return SWIG_RuntimeError;
      }
      obj = PyUnicode_AsUTF8String(obj);
      if (PyString_AsStringAndSize(obj, &cstr, &len) != -1) {
        if (cptr) {
          if (alloc) *alloc = SWIG_NEWOBJ;
          *cptr = (char *)memcpy(malloc((len + 1)*sizeof(char)), cstr, sizeof(char)*(len + 1));
        }
        if (psize) *psize = len + 1;

        Py_XDECREF(obj);
        return SWIG_OK;
      } else {
        Py_XDECREF(obj);
      }
    }
#endif
#endif

    swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
    if (pchar_descriptor) {
      void* vptr = 0;
      if (SWIG_ConvertPtr(obj, &vptr, pchar_descriptor, 0) == SWIG_OK) {
	if (cptr) *cptr = (char *) vptr;
	if (psize) *psize = vptr ? (strlen((char *)vptr) + 1) : 0;
	if (alloc) *alloc = SWIG_OLDOBJ;
	return SWIG_OK;
      }
    }
  }
  return SWIG_TypeError;
}





 static unsigned int isqrt(unsigned int n)
  {
    unsigned int c = 0x8000;
    unsigned int g = 0x8000;

    for(;;)
    {
      if(g*g > n)
      g ^= c;
      c >>= 1;
      if(c == 0)
        return g;
      g |= c;
    }
  }

  static int compiled_in_debug_mode()
  {
#ifdef NDEBUG
    return 0;
#else
    return 1;
#endif
  }


#ifdef __cplusplus
  extern "C" {
#endif
  // this can't be static --xhub
  void set_cstruct(uintptr_t p_env, void* p_struct);
  void set_cstruct(uintptr_t p_env, void* p_struct)
  {
    *(void**)p_env = p_struct;
  }
#ifdef __cplusplus
}
#endif


SWIGINTERNINLINE PyObject*
  SWIG_From_unsigned_SS_int  (unsigned int value)
{
  return PyInt_FromSize_t((size_t) value);
}


#if defined(LLONG_MAX) && !defined(SWIG_LONG_LONG_AVAILABLE)
#  define SWIG_LONG_LONG_AVAILABLE
#endif


#ifdef SWIG_LONG_LONG_AVAILABLE
SWIGINTERN int
SWIG_AsVal_unsigned_SS_long_SS_long (PyObject *obj, unsigned long long *val)
{
  int res = SWIG_TypeError;
  if (PyLong_Check(obj)) {
    unsigned long long v = PyLong_AsUnsignedLongLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
      res = SWIG_OverflowError;
    }
  } else {
    unsigned long v;
    res = SWIG_AsVal_unsigned_SS_long (obj,&v);
    if (SWIG_IsOK(res)) {
      if (val) *val = v;
      return res;
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    const double mant_max = 1LL << DBL_MANT_DIG;
    double d;
    res = SWIG_AsVal_double (obj,&d);
    if (SWIG_IsOK(res) && !SWIG_CanCastAsInteger(&d, 0, mant_max))
      return SWIG_OverflowError;
    if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, 0, mant_max)) {
      if (val) *val = (unsigned long long)(d);
      return SWIG_AddCast(res);
    }
    res = SWIG_TypeError;
  }
#endif
  return res;
}
#endif


SWIGINTERNINLINE int
SWIG_AsVal_size_t (PyObject * obj, size_t *val)
{
  int res = SWIG_TypeError;
#ifdef SWIG_LONG_LONG_AVAILABLE
  if (sizeof(size_t) <= sizeof(unsigned long)) {
#endif
    unsigned long v;
    res = SWIG_AsVal_unsigned_SS_long (obj, val ? &v : 0);
    if (SWIG_IsOK(res) && val) *val = (size_t)(v);
#ifdef SWIG_LONG_LONG_AVAILABLE
  } else if (sizeof(size_t) <= sizeof(unsigned long long)) {
    unsigned long long v;
    res = SWIG_AsVal_unsigned_SS_long_SS_long (obj, val ? &v : 0);
    if (SWIG_IsOK(res) && val) *val = (size_t)(v);
  }
#endif
  return res;
}


SWIGINTERNINLINE PyObject* 
SWIG_From_unsigned_SS_long  (unsigned long value)
{
  return (value > LONG_MAX) ?
    PyLong_FromUnsignedLong(value) : PyInt_FromLong((long)(value));
}


#ifdef SWIG_LONG_LONG_AVAILABLE
SWIGINTERNINLINE PyObject* 
SWIG_From_unsigned_SS_long_SS_long  (unsigned long long value)
{
  return (value > LONG_MAX) ?
    PyLong_FromUnsignedLongLong(value) : PyInt_FromLong((long)(value));
}
#endif


SWIGINTERNINLINE PyObject *
SWIG_From_size_t  (size_t value)
{    
#ifdef SWIG_LONG_LONG_AVAILABLE
  if (sizeof(size_t) <= sizeof(unsigned long)) {
#endif
    return SWIG_From_unsigned_SS_long  ((unsigned long)(value));
#ifdef SWIG_LONG_LONG_AVAILABLE
  } else {
    /* assume sizeof(size_t) <= sizeof(unsigned long long) */
    return SWIG_From_unsigned_SS_long_SS_long  ((unsigned long long)(value));
  }
#endif
}

SWIGINTERN void delete_SparseBlockStructuredMatrix(struct SparseBlockStructuredMatrix *self){
   SBM_free(self);
   free(self);
 }

  #define SWIG_From_double   PyFloat_FromDouble 


SWIGINTERN int
SWIG_AsVal_bool (PyObject *obj, bool *val)
{
  int r;
  if (!PyBool_Check(obj))
    return SWIG_ERROR;
  r = PyObject_IsTrue(obj);
  if (r == -1)
    return SWIG_ERROR;
  if (val) *val = r ? true : false;
  return SWIG_OK;
}


  static int cs_convert_from_scipy_sparse(PyObject* obj, CSparseMatrix** m, PyArrayObject** array_data_, int* array_data_ctrl_, PyArrayObject** array_i_, int* array_i_ctrl_, PyArrayObject** array_p_, int* array_p_ctrl_, int* alloc_ctrl)
  {

  assert(m);
  /* get sys.modules dict */
  PyObject* sys_mod_dict = PyImport_GetModuleDict();
  /* get the scipy module object */ 
  PyObject* scipy_mod = PyMapping_GetItemString(sys_mod_dict, (char *)"scipy.sparse");

  if (!scipy_mod) 
  { 
    PyErr_SetString(PyExc_RuntimeError, "Did you import scipy.sparse ?");
    return 0;
  }

  bool isspmat = is_Pyobject_scipy_sparse_matrix(obj, scipy_mod);
  if (isspmat == false)
  {
    return -1;
  }
  else
  {
    PyObject* shape_ = PyObject_GetAttrString(obj, "shape");

    unsigned nrows, ncols;
       PyObject *_TEMPnrows = PySequence_GetItem(shape_,0);                    if (!PyInt_Check(_TEMPnrows))                                            {                                                                          Py_XDECREF(_TEMPnrows);                                                  PyErr_SetString(PyExc_RuntimeError, "expecting an int for ""nrows");            PyObject_Print(shape_, stderr, 0);                                          return 0;                                                              }                                                                        nrows = PyInt_AsLong(_TEMPnrows);                                      Py_DECREF(_TEMPnrows);
       PyObject *_TEMPncols = PySequence_GetItem(shape_,1);                    if (!PyInt_Check(_TEMPncols))                                            {                                                                          Py_XDECREF(_TEMPncols);                                                  PyErr_SetString(PyExc_RuntimeError, "expecting an int for ""ncols");            PyObject_Print(shape_, stderr, 0);                                          return 0;                                                              }                                                                        ncols = PyInt_AsLong(_TEMPncols);                                      Py_DECREF(_TEMPncols);

    Py_DECREF(shape_);


    PyObject* res;

    res = PyObject_CallMethodObjArgs(scipy_mod, PyString_FromString("isspmatrix_csc"), obj, NULL);
    bool is_csc = (res == Py_True);
    Py_DECREF(res);

    if (is_csc)
    {
      // csc
      //PyErr_Warn(PyExc_UserWarning, "The matrix is csc");
      
      PyObject* nnz_ = PyObject_GetAttrString(obj, "nnz");
      size_t nzmax = PyInt_AsLong(nnz_);
      Py_DECREF(nnz_);

      CSparseMatrix* M = (CSparseMatrix*) calloc(1, sizeof(CSparseMatrix));
      if(!M) { PyErr_SetString(PyExc_RuntimeError, "Failed to allocate a cs_sparse"); return 0; }

      M->nz = -1;
      M->m = nrows;
      M->n = ncols;
      M->nzmax = nzmax;
      *m = M;
      if(!M) { PyErr_SetString(PyExc_RuntimeError, "Allocation of the csc matrix failed"); return 0; };

      PyObject* data_ = PyObject_GetAttrString(obj, "data");
      PyObject* indices_ = PyObject_GetAttrString(obj, "indices");
      PyObject* indptr_ = PyObject_GetAttrString(obj, "indptr");

      *array_data_ = obj_to_array_allow_conversion(data_, NPY_DOUBLE, array_data_ctrl_);
      if (!*array_data_) { PyErr_SetString(PyExc_RuntimeError, "Could not get a pointer to the data array");  PyObject_Print(data_, stderr, 0); return 0; }

      M->x = (double*)array_data(*array_data_);

      bool alloc_p = false;
      /*@SWIG:/scratch/huber/siconos/siconos/numerics/swig/Numerics_NM_python.i,215,%SAFE_CAST_INT@*/
{
    int array_pyvartype_ = PyArray_TYPE((PyArrayObject *)indptr_);
    switch (array_pyvartype_)
    {
      case NPY_INT32:
      {
        *array_p_ = obj_to_array_allow_conversion(indptr_, NPY_INT32, array_p_ctrl_);
        if (!*array_p_) { PyErr_SetString(PyExc_RuntimeError, "Could not get array for variable""indptr_"); PyObject_Print(indptr_, stderr, 0); return 0; }

#ifdef _SICONOS_INT64
        PyErr_Warn(PyExc_UserWarning, "Performance warning: the vector of indices or pointers is in int32, but siconos has 64-bits integers: we have to perform a conversion. Consider given sparse matrix in the right format");
        M->p = (CS_INT*) malloc((M->n + 1) * sizeof(CS_INT));
        if(!M->p) { PyErr_SetString(PyExc_RuntimeError, "Allocation of i or p failed (triggered by conversion to int32)"); return 0; }
        
        for(unsigned i = 0; i < (M->n + 1); ++i)
        {
          M->p[i] = ((int32_t *) array_data(*array_p_)) [i];
        }
        if (*array_p_ctrl_) Py_DECREF(*array_p_);
        *array_p_ctrl_ = 0;
        alloc_p = true;
#else
        M->p = (CS_INT *) array_data(*array_p_);
#endif
        break;
      }
      case NPY_INT64:
      {
        *array_p_ = obj_to_array_allow_conversion(indptr_, NPY_INT64, array_p_ctrl_);
        if (!*array_p_) { PyErr_SetString(PyExc_RuntimeError, "Could not get array for variable ""indptr_");  PyObject_Print(indptr_, stderr, 0); return 0; }

#ifdef _SICONOS_INT64
        M->p = (CS_INT*) array_data(*array_p_);
#else
        PyErr_Warn(PyExc_UserWarning, "Performance warning: the vector of indices or pointers is in int64, but siconos has 32-bits integers: we have to perform a conversion. Consider given sparse matrix in the right format");
        M->p = (CS_INT*) malloc((M->n + 1) * sizeof(CS_INT));
        if(!M->p) { PyErr_SetString(PyExc_RuntimeError, "Allocation of i or p failed (triggered by conversion to int64)"); return 0; }
        for(unsigned i = 0; i < (M->n + 1); ++i)
        {
          M->p[i] = ((int64_t *) array_data(*array_p_)) [i];
        }
        if (*array_p_ctrl_) Py_DECREF(*array_p_);
        *array_p_ctrl_ = 0;
        alloc_p = true;
#endif
        break;
      }
      default:
      {
        PyObject *errmsg;
        errmsg = PyUString_FromString("Unknown type ");
        PyUString_ConcatAndDel(&errmsg, PyObject_Repr((PyObject *)PyArray_DESCR((PyArrayObject *)indptr_)));
        PyUString_ConcatAndDel(&errmsg, PyUString_FromFormat(" for variable ""indptr_"));
        PyErr_SetObject(PyExc_TypeError, errmsg);
        Py_DECREF(errmsg);
        return 0;
      }
    }
}
/*@SWIG@*/;
      if (alloc_p) { *alloc_ctrl |= ALLOC_CTRL_P; };
      bool alloc_i = false;
      /*@SWIG:/scratch/huber/siconos/siconos/numerics/swig/Numerics_NM_python.i,215,%SAFE_CAST_INT@*/
{
    int array_pyvartype_ = PyArray_TYPE((PyArrayObject *)indices_);
    switch (array_pyvartype_)
    {
      case NPY_INT32:
      {
        *array_i_ = obj_to_array_allow_conversion(indices_, NPY_INT32, array_i_ctrl_);
        if (!*array_i_) { PyErr_SetString(PyExc_RuntimeError, "Could not get array for variable""indices_"); PyObject_Print(indices_, stderr, 0); return 0; }

#ifdef _SICONOS_INT64
        PyErr_Warn(PyExc_UserWarning, "Performance warning: the vector of indices or pointers is in int32, but siconos has 64-bits integers: we have to perform a conversion. Consider given sparse matrix in the right format");
        M->i = (CS_INT*) malloc(nzmax * sizeof(CS_INT));
        if(!M->i) { PyErr_SetString(PyExc_RuntimeError, "Allocation of i or p failed (triggered by conversion to int32)"); return 0; }
        
        for(unsigned i = 0; i < nzmax; ++i)
        {
          M->i[i] = ((int32_t *) array_data(*array_i_)) [i];
        }
        if (*array_i_ctrl_) Py_DECREF(*array_i_);
        *array_i_ctrl_ = 0;
        alloc_i = true;
#else
        M->i = (CS_INT *) array_data(*array_i_);
#endif
        break;
      }
      case NPY_INT64:
      {
        *array_i_ = obj_to_array_allow_conversion(indices_, NPY_INT64, array_i_ctrl_);
        if (!*array_i_) { PyErr_SetString(PyExc_RuntimeError, "Could not get array for variable ""indices_");  PyObject_Print(indices_, stderr, 0); return 0; }

#ifdef _SICONOS_INT64
        M->i = (CS_INT*) array_data(*array_i_);
#else
        PyErr_Warn(PyExc_UserWarning, "Performance warning: the vector of indices or pointers is in int64, but siconos has 32-bits integers: we have to perform a conversion. Consider given sparse matrix in the right format");
        M->i = (CS_INT*) malloc(nzmax * sizeof(CS_INT));
        if(!M->i) { PyErr_SetString(PyExc_RuntimeError, "Allocation of i or p failed (triggered by conversion to int64)"); return 0; }
        for(unsigned i = 0; i < nzmax; ++i)
        {
          M->i[i] = ((int64_t *) array_data(*array_i_)) [i];
        }
        if (*array_i_ctrl_) Py_DECREF(*array_i_);
        *array_i_ctrl_ = 0;
        alloc_i = true;
#endif
        break;
      }
      default:
      {
        PyObject *errmsg;
        errmsg = PyUString_FromString("Unknown type ");
        PyUString_ConcatAndDel(&errmsg, PyObject_Repr((PyObject *)PyArray_DESCR((PyArrayObject *)indices_)));
        PyUString_ConcatAndDel(&errmsg, PyUString_FromFormat(" for variable ""indices_"));
        PyErr_SetObject(PyExc_TypeError, errmsg);
        Py_DECREF(errmsg);
        return 0;
      }
    }
}
/*@SWIG@*/;
      if (alloc_i) { *alloc_ctrl |= ALLOC_CTRL_I; };

      return 1;
    }
//#define WITH_CSR












































    res = PyObject_CallMethodObjArgs(scipy_mod, PyString_FromString("isspmatrix_coo"), obj, NULL);
    bool is_coo = (res == Py_True);
    Py_DECREF(res);

    PyObject* coo;
    int coo_new_alloc;
    if (!is_coo)
    {
      PyErr_Warn(PyExc_UserWarning, "Performance warning: the given sparse matrix is neither csc or coo (most probably csr), we have to perform a conversion to coo");
      coo = PyObject_CallMethodObjArgs(scipy_mod, PyString_FromString("coo_matrix"), obj, NULL);
      if (!coo) { if (!PyErr_Occurred()) { PyErr_SetString(PyExc_RuntimeError, "Conversion to coo failed!"); }; return 0; }
      coo_new_alloc = 1;
    }
    else
    {
      coo = obj;
      coo_new_alloc = 0;
    }

    // triplet
    PyObject* nnz_ = PyObject_GetAttrString(coo, "nnz");
    size_t nnz = PyInt_AsLong(nnz_);
    Py_DECREF(nnz_);


    CSparseMatrix* M = (CSparseMatrix*) calloc(1, sizeof(CSparseMatrix));
    if(!M) { PyErr_SetString(PyExc_RuntimeError, "Failed to allocate a cs_sparse"); return 0; }

    M->m = nrows;
    M->n = ncols;
    M->nzmax = nnz;
    *m = M;
    M->nz = nnz;

    if(!M) { PyErr_SetString(PyExc_RuntimeError, "Allocation of the triplet matrix failed"); return 0; }

    PyObject* data_ = PyObject_GetAttrString(coo, "data");
    PyObject* row_ = PyObject_GetAttrString(coo, "row");
    PyObject* col_ = PyObject_GetAttrString(coo, "col");

    *array_data_ = obj_to_array_allow_conversion(data_, NPY_DOUBLE, array_data_ctrl_);
    if (!*array_data_) { PyErr_SetString(PyExc_RuntimeError, "Could not get a pointer to the data array");  PyObject_Print(data_, stderr, 0); return 0; }

    M->x = (double*)array_data(*array_data_);

    bool alloc_p = false;
    /*@SWIG:/scratch/huber/siconos/siconos/numerics/swig/Numerics_NM_python.i,215,%SAFE_CAST_INT@*/
{
    int array_pyvartype_ = PyArray_TYPE((PyArrayObject *)col_);
    switch (array_pyvartype_)
    {
      case NPY_INT32:
      {
        *array_p_ = obj_to_array_allow_conversion(col_, NPY_INT32, array_p_ctrl_);
        if (!*array_p_) { PyErr_SetString(PyExc_RuntimeError, "Could not get array for variable""col_"); PyObject_Print(col_, stderr, 0); return 0; }

#ifdef _SICONOS_INT64
        PyErr_Warn(PyExc_UserWarning, "Performance warning: the vector of indices or pointers is in int32, but siconos has 64-bits integers: we have to perform a conversion. Consider given sparse matrix in the right format");
        M->p = (CS_INT*) malloc(nnz * sizeof(CS_INT));
        if(!M->p) { PyErr_SetString(PyExc_RuntimeError, "Allocation of i or p failed (triggered by conversion to int32)"); return 0; }
        
        for(unsigned i = 0; i < nnz; ++i)
        {
          M->p[i] = ((int32_t *) array_data(*array_p_)) [i];
        }
        if (*array_p_ctrl_) Py_DECREF(*array_p_);
        *array_p_ctrl_ = 0;
        alloc_p = true;
#else
        M->p = (CS_INT *) array_data(*array_p_);
#endif
        break;
      }
      case NPY_INT64:
      {
        *array_p_ = obj_to_array_allow_conversion(col_, NPY_INT64, array_p_ctrl_);
        if (!*array_p_) { PyErr_SetString(PyExc_RuntimeError, "Could not get array for variable ""col_");  PyObject_Print(col_, stderr, 0); return 0; }

#ifdef _SICONOS_INT64
        M->p = (CS_INT*) array_data(*array_p_);
#else
        PyErr_Warn(PyExc_UserWarning, "Performance warning: the vector of indices or pointers is in int64, but siconos has 32-bits integers: we have to perform a conversion. Consider given sparse matrix in the right format");
        M->p = (CS_INT*) malloc(nnz * sizeof(CS_INT));
        if(!M->p) { PyErr_SetString(PyExc_RuntimeError, "Allocation of i or p failed (triggered by conversion to int64)"); return 0; }
        for(unsigned i = 0; i < nnz; ++i)
        {
          M->p[i] = ((int64_t *) array_data(*array_p_)) [i];
        }
        if (*array_p_ctrl_) Py_DECREF(*array_p_);
        *array_p_ctrl_ = 0;
        alloc_p = true;
#endif
        break;
      }
      default:
      {
        PyObject *errmsg;
        errmsg = PyUString_FromString("Unknown type ");
        PyUString_ConcatAndDel(&errmsg, PyObject_Repr((PyObject *)PyArray_DESCR((PyArrayObject *)col_)));
        PyUString_ConcatAndDel(&errmsg, PyUString_FromFormat(" for variable ""col_"));
        PyErr_SetObject(PyExc_TypeError, errmsg);
        Py_DECREF(errmsg);
        return 0;
      }
    }
}
/*@SWIG@*/;
    if (alloc_p) { *alloc_ctrl |= ALLOC_CTRL_P; };
    bool alloc_i = false;
    /*@SWIG:/scratch/huber/siconos/siconos/numerics/swig/Numerics_NM_python.i,215,%SAFE_CAST_INT@*/
{
    int array_pyvartype_ = PyArray_TYPE((PyArrayObject *)row_);
    switch (array_pyvartype_)
    {
      case NPY_INT32:
      {
        *array_i_ = obj_to_array_allow_conversion(row_, NPY_INT32, array_i_ctrl_);
        if (!*array_i_) { PyErr_SetString(PyExc_RuntimeError, "Could not get array for variable""row_"); PyObject_Print(row_, stderr, 0); return 0; }

#ifdef _SICONOS_INT64
        PyErr_Warn(PyExc_UserWarning, "Performance warning: the vector of indices or pointers is in int32, but siconos has 64-bits integers: we have to perform a conversion. Consider given sparse matrix in the right format");
        M->i = (CS_INT*) malloc(nnz * sizeof(CS_INT));
        if(!M->i) { PyErr_SetString(PyExc_RuntimeError, "Allocation of i or p failed (triggered by conversion to int32)"); return 0; }
        
        for(unsigned i = 0; i < nnz; ++i)
        {
          M->i[i] = ((int32_t *) array_data(*array_i_)) [i];
        }
        if (*array_i_ctrl_) Py_DECREF(*array_i_);
        *array_i_ctrl_ = 0;
        alloc_i = true;
#else
        M->i = (CS_INT *) array_data(*array_i_);
#endif
        break;
      }
      case NPY_INT64:
      {
        *array_i_ = obj_to_array_allow_conversion(row_, NPY_INT64, array_i_ctrl_);
        if (!*array_i_) { PyErr_SetString(PyExc_RuntimeError, "Could not get array for variable ""row_");  PyObject_Print(row_, stderr, 0); return 0; }

#ifdef _SICONOS_INT64
        M->i = (CS_INT*) array_data(*array_i_);
#else
        PyErr_Warn(PyExc_UserWarning, "Performance warning: the vector of indices or pointers is in int64, but siconos has 32-bits integers: we have to perform a conversion. Consider given sparse matrix in the right format");
        M->i = (CS_INT*) malloc(nnz * sizeof(CS_INT));
        if(!M->i) { PyErr_SetString(PyExc_RuntimeError, "Allocation of i or p failed (triggered by conversion to int64)"); return 0; }
        for(unsigned i = 0; i < nnz; ++i)
        {
          M->i[i] = ((int64_t *) array_data(*array_i_)) [i];
        }
        if (*array_i_ctrl_) Py_DECREF(*array_i_);
        *array_i_ctrl_ = 0;
        alloc_i = true;
#endif
        break;
      }
      default:
      {
        PyObject *errmsg;
        errmsg = PyUString_FromString("Unknown type ");
        PyUString_ConcatAndDel(&errmsg, PyObject_Repr((PyObject *)PyArray_DESCR((PyArrayObject *)row_)));
        PyUString_ConcatAndDel(&errmsg, PyUString_FromFormat(" for variable ""row_"));
        PyErr_SetObject(PyExc_TypeError, errmsg);
        Py_DECREF(errmsg);
        return 0;
      }
    }
}
/*@SWIG@*/;
    if (alloc_i) { *alloc_ctrl |= ALLOC_CTRL_I; };

    if (coo_new_alloc)
    {
      Py_DECREF(coo);
    }

    return 1;
  }
  }

  static int NM_convert_from_scipy_sparse(PyObject* obj, NumericsMatrix* m, PyArrayObject** array_data_, int* array_data_ctrl_, PyArrayObject** array_i_, int* array_i_ctrl_, PyArrayObject** array_p_, int* array_p_ctrl_, int* alloc_ctrl)
  {
    CSparseMatrix* csm = NULL;
    int res = cs_convert_from_scipy_sparse(obj, &csm, array_data_, array_data_ctrl_, array_i_, array_i_ctrl_, array_p_, array_p_ctrl_, alloc_ctrl);
    if (res > 0)
    {
      m->storageType = NM_SPARSE;
      m->matrix2 = NSM_new();

      if (csm->nz > 0)
      {
        m->matrix2->triplet = csm;
        m->matrix2->origin = NSM_TRIPLET;
      }
      else if (csm->nz == -1)
      {
        m->matrix2->csc = csm;
        m->matrix2->origin = NSM_CSC;
      }
      else if (csm->nz == -2)
      {
        m->matrix2->csr = csm;
        m->matrix2->origin = NSM_CSR;
      }
      else
      {
        PyErr_SetString(PyExc_RuntimeError, "Unknown CSparseMatrix from cs_convert_from_scipy_sparse");
        return 0;
      }

      NM_update_size(m);
    }

    return res;
  }


  static NumericsMatrix* NM_convert_from_python(PyObject* obj, NumericsMatrix** tmpmat, PyArrayObject** array_data_, int* array_ctrl, PyArrayObject** array_i_, int* array_i_ctrl_, PyArrayObject** array_p_, int* array_p_ctrl_, int* alloc_ctrl)
  {
  void* argp = NULL;
  NumericsMatrix* out = NULL;
  int res = SWIG_ConvertPtr(obj, &argp, SWIGTYPE_p_NumericsMatrix,  0 );
  if (SWIG_IsOK(res))
  {
    out = (NumericsMatrix *)argp;
  }
  else
  {
    *tmpmat = NM_new();
    out = *tmpmat;
    if (is_array(obj) || sane_pyseq_check(obj))
    {
      PyArrayObject* array_data = obj_to_array_fortran_allow_conversion(obj, NPY_DOUBLE, array_ctrl);

      if (!array_data)
      {
        PyErr_SetString(PyExc_TypeError, "Could not get array obj from the python object");
        PyObject_Print(obj, stderr, 0);
        goto fail;
      }

      if (!require_dimensions(array_data, 2) || !require_native(array_data) || !require_fortran(array_data))
      {
        PyErr_SetString(PyExc_TypeError, "The given object does not have the right structure. We expect a 2 dimensional array (or list, tuple, ...)");
        PyObject_Print(obj, stderr, 0);
        goto fail;
      }

      out->storageType = NM_DENSE;
      out->size0 =  array_size(array_data, 0);
      out->size1 =  array_size(array_data, 1);
      out->matrix0 = (double *)array_data(array_data);

      *array_data_ = array_data;
    }
    else
    {
      int sp_conv = NM_convert_from_scipy_sparse(obj, out, array_data_, array_ctrl, array_i_, array_i_ctrl_, array_p_, array_p_ctrl_, alloc_ctrl);
      if (!sp_conv) { goto fail; }
      else if (sp_conv < 0)
      {
        if (SWIG_IsOK(SWIG_ConvertPtr(obj, &argp, SWIGTYPE_p_SparseBlockStructuredMatrix,  0 )))
        {
          out->matrix1 = (SparseBlockStructuredMatrix *)argp;
          out->storageType = NM_SPARSE_BLOCK;
          NM_update_size(out);
        }
        else
        {
          PyObject_Print(obj, stderr, 0);
          PyErr_SetString(PyExc_TypeError, "Cannot build a NumericsMatrix from the given python object");
          goto fail;
        }
      }
    }
  }

  return out;

fail:
  if (*tmpmat) { free(*tmpmat); *tmpmat = NULL; }
  return NULL;
  }

static PyObject* cs_sparse_to_csr_matrix(CSparseMatrix *M, bool copy)
{
  CS_TO_SCIPY(csr, M->m, copy);
}

static PyObject* cs_sparse_to_csc_matrix(CSparseMatrix *M, bool copy)
{
  CS_TO_SCIPY(csc, M->n, copy);
}

static PyObject* cs_sparse_to_coo_matrix(CSparseMatrix *M, bool copy)
{
  if (!M)
  {
    Py_INCREF(Py_None);
    return Py_None;
  }
  else
  {
    /* get sys.modules dict */
    PyObject* sys_mod_dict = PyImport_GetModuleDict();

    /* get the csr module object */
    PyObject* scipy_mod = PyMapping_GetItemString(sys_mod_dict, (char *)"scipy.sparse.coo");\

    if (!scipy_mod)
    {
      PyErr_SetString(PyExc_RuntimeError, "Did you import scipy.sparse.coo?");
      return NULL;
    }

    npy_intp this_M_x_dims[1] = { M->nz };
    npy_intp this_M_i_dims[1] = { M->nz };
    npy_intp this_M_p_dims[1] = { M->nz };

    double* data_p;
    if (copy)
    {
      data_p = (double*)malloc(M->nz * sizeof(double));
      memcpy(data_p, M->x, M->nz * sizeof(double));
    }
    else
    {
      data_p = M->x;
    }

    PyObject* out_data = PyArray_SimpleNewFromData(1, this_M_x_dims, NPY_DOUBLE, data_p);
    if(!out_data) { PyErr_SetString(PyExc_RuntimeError, "Could not extract M->x"); return NULL; };
    if (copy) { PyArray_UpdateFlags((PyArrayObject*)out_data, NPY_ARRAY_OWNDATA); }

    PyObject* row_indices;
    PyObject* col_indices;

    INT_TO_NPY_INT(this_M_i_dims, M->i, row_indices, copy);
    INT_TO_NPY_INT(this_M_p_dims, M->p, col_indices, copy);

    PyObject* out_indx = PyTuple_Pack(2, row_indices, col_indices);
    if(!out_indx) { PyErr_SetString(PyExc_RuntimeError, "Could not build (row, col)"); return NULL; };
    PyObject* out_all =  PyTuple_Pack(2, out_data, out_indx);
    if(!out_all) { PyErr_SetString(PyExc_RuntimeError, "Could not build (data, (row, col))"); return NULL; };

    /* Warning ! m is the number of rows, n the number of columns ! --xhub */ \
    PyObject* out_shape = PyTuple_Pack(2, PyInt_FromLong(M->m), PyInt_FromLong(M->n)); \
    if(!out_shape) {  PyErr_SetString(PyExc_RuntimeError, "Could not extract M->m or M->n"); return NULL; }; \

    PyObject* out_nnz = PyInt_FromLong(M->nz);
    if(!out_nnz) {  PyErr_SetString(PyExc_RuntimeError, "Could not extract M->nz"); return NULL; };

    /* call the class inside the csr module */
    PyObject* out_mat = PyObject_CallMethodObjArgs(scipy_mod, PyString_FromString((char *) "coo_matrix"), out_all, out_shape, NULL);

   Py_DECREF(out_indx);
   Py_DECREF(out_all);

    if(out_mat)
    {
      _sn_check_nnz(&out_mat, M);
      _sn_check_shape(&out_mat, M);

      return out_mat;
    }
    else
    {
      PyErr_SetString(PyExc_RuntimeError, "Could not create coo matrix");
      return NULL;
    }

  }

}

  static PyObject* NM_to_python(NumericsMatrix* m)
  {
  if (m)
  {
    npy_intp dims[2];
    dims[0] = m->size0;
    dims[1] = m->size1;
    if (m->matrix0)
    {
      PyObject *obj = FPyArray_SimpleNewFromData(2, dims, NPY_DOUBLE, m->matrix0);
      PyArrayObject *array = (PyArrayObject*) obj;
      if (!array) { PyErr_SetString(PyExc_RuntimeError, "Could not create an array from matrix0. Please file a bug"); return NULL; }
      return obj;
    }
    else if(m->matrix1)
    {
      // matrix is sparse : return opaque pointer
      return SWIG_NewPointerObj(SWIG_as_voidptr(m->matrix1), SWIGTYPE_p_SparseBlockStructuredMatrix, 0);
    }
    else if(m->matrix2)
    {
      switch(m->matrix2->origin)
      {
      case NSM_CSC:
      {
       return cs_sparse_to_csc_matrix(NM_csc(m), false);
      }
      case NSM_TRIPLET:
      {
        return cs_sparse_to_coo_matrix(NM_triplet(m), false);
      }
      case NSM_CSR:
      {
        return cs_sparse_to_csr_matrix(NM_csr(m), false);
      }
      default:
      {
        PyErr_SetString(PyExc_RuntimeError, "The given sparse matrix has no valid origin. Please file a bug");
        return NULL;
      }
      }
    }
    else
    {
      PyErr_SetString(PyExc_RuntimeError, "The given matrix is of unknown type. Please file a bug");
      return NULL;
    }
  }
  else
  {
     Py_INCREF(Py_None);
     return  Py_None;
  }
  }



SWIGINTERN struct NumericsMatrix *new_NumericsMatrix(PyObject *o){
    NumericsMatrix *M;
    /*@SWIG:/scratch/huber/siconos/siconos/numerics/swig/numerics_NM.i,7,%NM_convert_from_target@*/
{
 PyArrayObject* array_ = NULL;
 int array_ctrl_ = 0;
 PyArrayObject* array_i_ = NULL;
 int array_i_ctrl_ = 0;
 PyArrayObject* array_p_ = NULL;
 int array_p_ctrl_ = 0;
 int alloc_ctrl_ = 0;
 NumericsMatrix *nummat = NULL;


   NumericsMatrix* Mtmp = NM_convert_from_python(o, &nummat, &array_, &array_ctrl_, &array_i_, &array_i_ctrl_, &array_p_, &array_p_ctrl_, &alloc_ctrl_);






   if (!Mtmp) { return NULL; }

  *(&M) = NM_create(Mtmp->storageType, Mtmp->size0, Mtmp->size1);
  NM_copy(Mtmp, *(&M));

  if(array_ctrl_ && array_) { Py_DECREF(array_); };
  if(array_i_ctrl_ && array_i_) { Py_DECREF(array_i_); };
  if(array_p_ctrl_ && array_p_) { Py_DECREF(array_p_); };

  if (nummat)
  {
    if (!NM_clean(nummat, alloc_ctrl_)) { return NULL; }
    free(nummat);
  }

}
/*@SWIG@*/
    return M;
  }
SWIGINTERN void NumericsMatrix_set_matrix0(struct NumericsMatrix *self,int i,int j,double v){
    assert(self->matrix0);
    self->matrix0[i+j*self->size1] = v;
  }
SWIGINTERN double NumericsMatrix_get_matrix0(struct NumericsMatrix *self,int i,int j){
    assert(self->matrix0);
    return self->matrix0[i+j*self->size1];
  }
SWIGINTERN PyObject *NumericsMatrix___setitem__(struct NumericsMatrix *self,PyObject *index,double v){
    int i, j;
    if (!self->matrix0)
    {
      PyErr_SetString(PyExc_RuntimeError, "The given matrix is not dense (matrix0 == NULL). For now only items on dense matrices can be set.");
      return NULL;
    }
    if (!PyArg_ParseTuple(index, "ii:NumericsMatrix__setitem__",&i,&j)) return NULL;
    NumericsMatrix_set_matrix0(self,i,j,v);
    return Py_BuildValue("");
  }
SWIGINTERN PyObject *NumericsMatrix___getitem__(struct NumericsMatrix *self,PyObject *index){
    int i, j;
    if (!self->matrix0)
    {
      PyErr_SetString(PyExc_RuntimeError, "The given matrix is not dense (matrix0 == NULL). For now only items on dense matrices can be requested.");
      return NULL;
    }
    if (!PyArg_ParseTuple(index, "ii:NumericsMatrix__getitem__",&i,&j)) return NULL;
    return SWIG_From_double(NumericsMatrix_get_matrix0(self,i,j));
  }
SWIGINTERN int NumericsMatrix___len__(struct NumericsMatrix *self){
    return self->size0 * self->size1;
  }
SWIGINTERN void delete_NumericsMatrix(struct NumericsMatrix *self){
    NM_free(self);
    free(self);
  }

  
  #include "mlcp_cst.h"
  #include "MixedLinearComplementarityProblem.h"
  #include "MLCP_Solvers.h"
  #include "SiconosCompat.h"
  
  
SWIGINTERN struct MixedLinearComplementarityProblem *new_MixedLinearComplementarityProblem__SWIG_0(void){
     MixedLinearComplementarityProblem* MLCP = newMLCP();
     return MLCP;
   }
SWIGINTERN struct MixedLinearComplementarityProblem *new_MixedLinearComplementarityProblem__SWIG_1(PyObject *dim,PyObject *o1,PyObject *o2){

      int is_new_object2=0;
      PyArrayObject* vector = obj_to_sn_vector(o2, &is_new_object2);

      MixedLinearComplementarityProblem *MLCP = newMLCP();
      // return pointer : free by std swig destructor

      /*@SWIG:/scratch/huber/siconos/siconos/numerics/swig/numerics_NM.i,7,%NM_convert_from_target@*/
{
 PyArrayObject* array_ = NULL;
 int array_ctrl_ = 0;
 PyArrayObject* array_i_ = NULL;
 int array_i_ctrl_ = 0;
 PyArrayObject* array_p_ = NULL;
 int array_p_ctrl_ = 0;
 int alloc_ctrl_ = 0;
 NumericsMatrix *nummat = NULL;


   NumericsMatrix* Mtmp = NM_convert_from_python(o1, &nummat, &array_, &array_ctrl_, &array_i_, &array_i_ctrl_, &array_p_, &array_p_ctrl_, &alloc_ctrl_);






   if (!Mtmp) { return NULL; }

  *((&MLCP->M)) = NM_create(Mtmp->storageType, Mtmp->size0, Mtmp->size1);
  NM_copy(Mtmp, *((&MLCP->M)));

  if(array_ctrl_ && array_) { Py_DECREF(array_); };
  if(array_i_ctrl_ && array_i_) { Py_DECREF(array_i_); };
  if(array_p_ctrl_ && array_p_) { Py_DECREF(array_p_); };

  if (nummat)
  {
    if (!NM_clean(nummat, alloc_ctrl_)) { return NULL; }
    free(nummat);
  }

}
/*@SWIG@*/;

      if (MLCP->M->size0 != MLCP->M->size1)
      {
        SWIG_Error(SWIG_ValueError, "A non square matrix has been given");
        freeMixedLinearComplementarityProblem(MLCP);
        return NULL;
      }

      sn_check_array_type(vector, return NULL);
      sn_check_size_mat_vec(MLCP->M->size0, vector, return NULL);


      SWIG_AsVal_int(dim, &MLCP->n);
      MLCP->m = MLCP->M->size0 - MLCP->n;
      MLCP->blocksRows = (int *) malloc(3*sizeof(int));
      MLCP->blocksIsComp = (int *) malloc(2*sizeof(int));


      MLCP->blocksRows[0]=0;
      MLCP->blocksRows[1]=MLCP->n;
      MLCP->blocksRows[2]=MLCP->n+MLCP->m;
      MLCP->blocksIsComp[0]=0;
      MLCP->blocksIsComp[1]=1;


      MLCP->isStorageType1 = 1;
      MLCP->isStorageType2 = 0;
      MLCP->A = NULL;
      MLCP->B = NULL;
      MLCP->C = NULL;
      MLCP->D = NULL;
      MLCP->a = NULL;
      MLCP->b = NULL;

      if (MLCP->M->size0 !=  array_size(vector,0))
      {
        SWIG_Error(SWIG_ValueError, "Matrix and vector of incompatible lengths");
        return NULL;
      }
      set_vec_from_target(MLCP->q, vector, , return NULL);

      // python mem management
      if(is_new_object2 && vector) { Py_DECREF(vector); };

      return MLCP;

    }
SWIGINTERN void delete_MixedLinearComplementarityProblem(struct MixedLinearComplementarityProblem *self){
    freeMixedLinearComplementarityProblem(self);
  }

  #include "LinearComplementarityProblem.h"
  #include "LCP_Solvers.h"
  #include "lcp_cst.h"
  
SWIGINTERN struct LinearComplementarityProblem *new_LinearComplementarityProblem(PyObject *M,PyObject *q){

      int is_new_object2=0;
      PyArrayObject* vector = obj_to_sn_vector(q, &is_new_object2);

      LinearComplementarityProblem* LC = newLCP();
      /*@SWIG:/scratch/huber/siconos/siconos/numerics/swig/numerics_NM.i,7,%NM_convert_from_target@*/
{
 PyArrayObject* array_ = NULL;
 int array_ctrl_ = 0;
 PyArrayObject* array_i_ = NULL;
 int array_i_ctrl_ = 0;
 PyArrayObject* array_p_ = NULL;
 int array_p_ctrl_ = 0;
 int alloc_ctrl_ = 0;
 NumericsMatrix *nummat = NULL;


   NumericsMatrix* Mtmp = NM_convert_from_python(M, &nummat, &array_, &array_ctrl_, &array_i_, &array_i_ctrl_, &array_p_, &array_p_ctrl_, &alloc_ctrl_);






   if (!Mtmp) { return NULL; }

  *((&LC->M)) = NM_create(Mtmp->storageType, Mtmp->size0, Mtmp->size1);
  NM_copy(Mtmp, *((&LC->M)));

  if(array_ctrl_ && array_) { Py_DECREF(array_); };
  if(array_i_ctrl_ && array_i_) { Py_DECREF(array_i_); };
  if(array_p_ctrl_ && array_p_) { Py_DECREF(array_p_); };

  if (nummat)
  {
    if (!NM_clean(nummat, alloc_ctrl_)) { return NULL; }
    free(nummat);
  }

}
/*@SWIG@*/;
      int size0 = LC->M->size0;
      sn_check_array_type(vector, return NULL);
      sn_check_size_mat_vec(LC->M->size0, vector, return NULL);

      LC->size = size0;
      set_vec_from_target(LC->q, vector, NULL, return NULL);

      // python mem management
      if(is_new_object2 && vector) { Py_DECREF(vector); };

      return LC;

    }
SWIGINTERN void delete_LinearComplementarityProblem(struct LinearComplementarityProblem *self){
    freeLinearComplementarityProblem(self);
  }

#include "AffineVariationalInequalities.h"
#include "AVI_Solvers.h"
#include "AVI_cst.h"
#include "VariationalInequality_Solvers.h"

SWIGINTERN struct AffineVariationalInequalities *new_AffineVariationalInequalities__SWIG_0(void){
     AffineVariationalInequalities* avi = newAVI();
     return avi;
   }
SWIGINTERN struct AffineVariationalInequalities *new_AffineVariationalInequalities__SWIG_1(PyObject *mat,PyObject *vec){


     AffineVariationalInequalities* avi = newAVI();

     int is_new_object2=0;
     PyArrayObject* vector = obj_to_sn_vector(vec, &is_new_object2); 

     /*@SWIG:/scratch/huber/siconos/siconos/numerics/swig/numerics_NM.i,7,%NM_convert_from_target@*/
{
 PyArrayObject* array_ = NULL;
 int array_ctrl_ = 0;
 PyArrayObject* array_i_ = NULL;
 int array_i_ctrl_ = 0;
 PyArrayObject* array_p_ = NULL;
 int array_p_ctrl_ = 0;
 int alloc_ctrl_ = 0;
 NumericsMatrix *nummat = NULL;


   NumericsMatrix* Mtmp = NM_convert_from_python(mat, &nummat, &array_, &array_ctrl_, &array_i_, &array_i_ctrl_, &array_p_, &array_p_ctrl_, &alloc_ctrl_);






   if (!Mtmp) { return NULL; }

  *((&avi->M)) = NM_create(Mtmp->storageType, Mtmp->size0, Mtmp->size1);
  NM_copy(Mtmp, *((&avi->M)));

  if(array_ctrl_ && array_) { Py_DECREF(array_); };
  if(array_i_ctrl_ && array_i_) { Py_DECREF(array_i_); };
  if(array_p_ctrl_ && array_p_) { Py_DECREF(array_p_); };

  if (nummat)
  {
    if (!NM_clean(nummat, alloc_ctrl_)) { return NULL; }
    free(nummat);
  }

}
/*@SWIG@*/;

     if (avi->M->size0 != avi->M->size1)
     {
       SWIG_Error(SWIG_ValueError, "A non square matrix has been given");
       freeAVI(avi);
       return NULL;
     }

     sn_check_array_type(vector, return NULL);
     sn_check_size_mat_vec(avi->M->size0, vector, return NULL);

     avi->size = avi->M->size0;
     set_vec_from_target(avi->q, vector, , return NULL);

      // python mem management
      if(is_new_object2 && vector) { Py_DECREF(vector); };

     return avi;
   }
SWIGINTERN void AffineVariationalInequalities_set_polyhedron(struct AffineVariationalInequalities *self,PyObject *H_mat,PyObject *K_vec){
     self->poly.split = (polyhedron*) malloc(sizeof(polyhedron));
      int is_new_object2=0;
      /*@SWIG:/scratch/huber/siconos/siconos/numerics/swig/numerics_NM.i,7,%NM_convert_from_target@*/
{
 PyArrayObject* array_ = NULL;
 int array_ctrl_ = 0;
 PyArrayObject* array_i_ = NULL;
 int array_i_ctrl_ = 0;
 PyArrayObject* array_p_ = NULL;
 int array_p_ctrl_ = 0;
 int alloc_ctrl_ = 0;
 NumericsMatrix *nummat = NULL;


   NumericsMatrix* Mtmp = NM_convert_from_python(H_mat, &nummat, &array_, &array_ctrl_, &array_i_, &array_i_ctrl_, &array_p_, &array_p_ctrl_, &alloc_ctrl_);






   if (!Mtmp) { PyErr_PrintEx(0); }

  *((&self->poly.split->H)) = NM_create(Mtmp->storageType, Mtmp->size0, Mtmp->size1);
  NM_copy(Mtmp, *((&self->poly.split->H)));

  if(array_ctrl_ && array_) { Py_DECREF(array_); };
  if(array_i_ctrl_ && array_i_) { Py_DECREF(array_i_); };
  if(array_p_ctrl_ && array_p_) { Py_DECREF(array_p_); };

  if (nummat)
  {
    if (!NM_clean(nummat, alloc_ctrl_)) { PyErr_PrintEx(0); }
    free(nummat);
  }

}
/*@SWIG@*/;

      if (self->poly.split->H->size1 != self->size)
      {
        SWIG_Error(SWIG_TypeError, "The matrix does not have the right number of column");
        PyErr_PrintEx(0);
      }

      PyArrayObject* vector = obj_to_sn_vector(K_vec, &is_new_object2); 
      sn_check_array_type(vector, PyErr_PrintEx(0));
      sn_check_size_mat_vec(self->poly.split->H->size0, vector, PyErr_PrintEx(0));

      set_vec_from_target(self->poly.split->K, vector, , PyErr_PrintEx(0));

      self->poly.split->size_ineq = self->poly.split->H->size0;
      self->poly.split->size_eq = 0;
      self->poly.split->Heq = NULL;
      self->poly.split->Keq = NULL;

   }
SWIGINTERN void delete_AffineVariationalInequalities(struct AffineVariationalInequalities *self){
    freeAVI(self);
  }


  static MixedLinearComplementarityProblem* mixedLinearComplementarityProblemFromFile
    (const char * filename)
  {
    FILE * finput = fopen(filename, "r");
    if (finput)
    {
      MixedLinearComplementarityProblem* problem =
        (MixedLinearComplementarityProblem *) malloc(sizeof(MixedLinearComplementarityProblem));
      if (mixedLinearComplementarity_newFromFile(problem,finput))
      {
      fprintf(stderr, "mixedLinearComplementarityProblemFromFile: cannot load %s\n",filename);
      free(problem);
      fclose(finput);
      return 0;
      }
      else
      {
        fclose(finput);
        return problem;
      }
    }
    else
    {
      fclose(finput);
      fprintf(stderr, "mixedLinearComplementarityProblemFromFile: cannot open %s\n",filename);
      return 0;
    }
  }



enum {ENV_IS_C_STRUCT = -1, ENV_IS_UNKNOWN, ENV_IS_PYTHON_CLASS, ENV_IS_PYTHON_FUNCTIONS, ENV_IS_PYTHON_FUNCTIONS_WITH_PROJ, ENV_IS_MATLAB_FUNCTION_HANDLES, ENV_IS_MATLAB_FUNCTION_NAMES};

#define CALL_COMPUTE_FN_NAME(FN_NAME, PNAME) FN_NAME ## PNAME


#include "VariationalInequality.h"
#include <open_lib.h>

static PyObject *my_callback_NablaFmcp = NULL;

static PyObject * set_my_callback_NablaFmcp(PyObject *o)
{
  PyObject *result = NULL;
  if (!PyCallable_Check(o)) {
    PyErr_SetString(PyExc_TypeError, "parameter must be callable");
    return NULL;
  }
  Py_XINCREF(o);         /* Add a reference to new callback */
  Py_XDECREF(my_callback_NablaFmcp);  /* Dispose of previous callback */
  my_callback_NablaFmcp = o;       /* Remember new callback */
  
  /* Boilerplate to return "None" */
  Py_INCREF(Py_None);
  result = Py_None;

  return result;
}

static void  my_call_to_callback_NablaFmcp (int size, double *z, double *nablaF)
{  
//  printf("I am in my_call_to_callback_NablaFmcp (int size, double *z, double *NablaF)\n");

  npy_intp this_matrix_dim[1];
  this_matrix_dim[0]=size;
  
  PyObject* pyarray = FPyArray_SimpleNewFromData(1,this_matrix_dim, NPY_DOUBLE, z);   
  PyObject* tuple = PyTuple_New(1);
  PyTuple_SetItem(tuple, 0, pyarray);  
  PyArrayObject* result; 

  if (PyCallable_Check(my_callback_NablaFmcp))
  {
    result = (PyArrayObject*)PyObject_CallObject(my_callback_NablaFmcp, tuple);
  }
  else
  {
    PyErr_SetString(PyExc_TypeError, "parameter must be callable");
    PyErr_PrintEx(0);
    return;
  }

   // PyTuple_SetItem steals a reference to the object
   // I'm leaving this commented so that people don't do the mistake twice -- xhub
   //Py_DECREF(pyarray);
   Py_DECREF(tuple);

//Comment :  it will be safier to use  obj_to_array_fortran_allow_conversion

  if (is_array(result))
  {
    if (array_size(result,0) != size || array_size(result,1) != size )
    {
      char message[240];
      sprintf(message, "Wrong size for  the return value of callback function. Expected size is %i x %i", size,size);
      PyErr_SetString(PyExc_RuntimeError,message);
    }
    else if (array_numdims(result) != 2)
    {
      char message[240];
      sprintf(message, "Wrong dimension for  the return value of callback function. Expected dimension is 2");
      PyErr_SetString(PyExc_RuntimeError,message);
    }
    else
    { 

      int is_new_object0=0;      
      PyArrayObject* result2 = make_fortran((PyArrayObject *)result, &is_new_object0);
      // if (is_new_object0)
      // {
      //   Py_DECREF(result);
      //   printf ("the object is new !!\n");
      // }
      memcpy(nablaF, (double *)array_data(result2), size*size * sizeof(double));
      
    }
   Py_DECREF(result);
  }
  else
  {      
    const char * desired_type = typecode_string(NPY_DOUBLE);
    const char * actual_type  = pytype_string((PyObject*)result);
    PyErr_Format(PyExc_TypeError,
                 "Array of type '%s' required as return value fo callback function. A '%s' was returned",
                   desired_type, actual_type);
    if (result != NULL) Py_DECREF(result); // things can go really south ...
  }

  return;

}

static PyObject *my_callback_Fmcp = NULL;

static PyObject * set_my_callback_Fmcp(PyObject *o1)
{
  PyObject *result = NULL;
  if (!PyCallable_Check(o1)) {
    PyErr_SetString(PyExc_TypeError, "parameter must be callable");
    return NULL;
  }
  Py_XINCREF(o1);         /* Add a reference to new callback */
  Py_XDECREF(my_callback_Fmcp);  /* Dispose of previous callback */
  my_callback_Fmcp = o1;       /* Remember new callback */
  
  /* Boilerplate to return "None" */
  Py_INCREF(Py_None);
  result = Py_None;

  return result;
}

static void  my_call_to_callback_Fmcp (int size, double *z, double *F)
{

//  printf("I am in my_call_to_callback_Fmcp (int size, double *z, double *F)\n");

  npy_intp this_matrix_dim[1];
  this_matrix_dim[0]=size;
  
  PyObject* pyarray = FPyArray_SimpleNewFromData(1,this_matrix_dim, NPY_DOUBLE, z);   
  PyObject* tuple = PyTuple_New(1);
  PyTuple_SetItem(tuple, 0, pyarray);  
  PyArrayObject* result; 

  if (PyCallable_Check(my_callback_Fmcp))
  {
    result = (PyArrayObject*)PyObject_CallObject(my_callback_Fmcp, tuple);
  }
  else
  {
    PyErr_SetString(PyExc_TypeError, "parameter must be callable");
    PyErr_PrintEx(0);
    return;
  }

  // PyTuple_SetItem steals a reference to the object
  // I'm leaving this commented so that people don't do the mistake twice -- xhub
  //Py_DECREF(pyarray);
  Py_DECREF(tuple);

  if (is_array(result))
  {
    if (array_size(result,0) != size)
    {
      char message[240];
      sprintf(message, "Wrong size for  the return value of callback function. Expected size is %i", size);
      PyErr_SetString(PyExc_RuntimeError,message);
    }
    else if (array_numdims(result) != 1)
    {
      char message[240];
      sprintf(message, "Wrong dimension for  the return value of callback function. Expected dimension is 1");
      PyErr_SetString(PyExc_RuntimeError,message);
    }
    else
    { 
      int is_new_object0=0;      
      PyArrayObject* result2 = make_fortran((PyArrayObject *)result, &is_new_object0);
      memcpy(F, (double *)array_data(result2), size * sizeof(double));
    }
    Py_DECREF(result);
  }
  else
  {
    const char * desired_type = typecode_string(NPY_DOUBLE);
    const char * actual_type  = pytype_string((PyObject*)result);
    PyErr_Format(PyExc_TypeError,
                 "Array of type '%s' required as return value fo callback function. A '%s' was returned",
                   desired_type, actual_type);
    if (result != NULL) Py_DECREF(result); // things can go really south ...
  }
  
  return;

}

  static void call_py_compute_Fmcp(void *env, int n, double* z, double* Fmcp)
  {
    npy_intp dim[1];
    dim[0] = n;

    PyObject* py_z = FPyArray_SimpleNewFromData(1, dim, NPY_DOUBLE, z);
    PyObject* py_Fmcp = FPyArray_SimpleNewFromData(1, dim, NPY_DOUBLE, Fmcp);

    PyObject* py_n = PyInt_FromLong(n);

    PY_CALL_METHOD_OR_FUNCTION(env, "compute_Fmcp", env_compute_function, py_n, py_z, py_Fmcp)

    Py_DECREF(py_n);
    Py_DECREF(py_z);
    Py_DECREF(py_Fmcp);

  };

  static void call_py_compute_nabla_Fmcp(void *env, int n, double* z, NumericsMatrix* nabla_Fmcp)
  {
    npy_intp dim[1];
    dim[0] = n;

    npy_intp dim2[2];
    dim2[0] = n;
    dim2[1] = n;

    PyObject* py_z = FPyArray_SimpleNewFromData(1, dim, NPY_DOUBLE, z);
    assert(nabla_Fmcp->matrix0 && "only dense matrix is supported");
    PyObject* py_nabla_Fmcp = FPyArray_SimpleNewFromData(2, dim2, NPY_DOUBLE, nabla_Fmcp->matrix0);

    PyObject* py_n = PyInt_FromLong(n);

    PY_CALL_METHOD_OR_FUNCTION(env, "compute_nabla_Fmcp", env_compute_jacobian, py_n, py_z, py_nabla_Fmcp)

    Py_DECREF(py_n);
    Py_DECREF(py_z);
    Py_DECREF(py_nabla_Fmcp);

  };

  static void call_py_compute_Fvi(void *problem, int n, double* z, double* F)
  {
    npy_intp dim[1];
    dim[0] = n;

    void* env = VI_get_env(problem);

    PyObject* py_z = FPyArray_SimpleNewFromData(1, dim, NPY_DOUBLE, z);
    PyObject* py_F = FPyArray_SimpleNewFromData(1, dim, NPY_DOUBLE, F);

    PyObject* py_n = PyInt_FromLong(n);

    PY_CALL_METHOD_OR_FUNCTION(env, "compute_F", env_compute_function, py_n, py_z, py_F)

    Py_DECREF(py_z);
    Py_DECREF(py_F);
    Py_DECREF(py_n);
  };

  static void call_py_compute_nabla_Fvi(void * problem, int n, double* z, NumericsMatrix* nabla_F)
  {
    npy_intp dim[1];
    dim[0] = n;

    npy_intp dim2[2];
    dim2[0] = n;
    dim2[1] = n;

    void* env = VI_get_env(problem);

    PyObject* py_z = FPyArray_SimpleNewFromData(1, dim, NPY_DOUBLE, z);
    assert(nabla_F->matrix0 && "only dense matrix is supported");
    PyObject* py_nabla_F = FPyArray_SimpleNewFromData(2, dim2, NPY_DOUBLE, nabla_F->matrix0);

    PyObject* py_n = PyInt_FromLong(n);

    PY_CALL_METHOD_OR_FUNCTION(env, "compute_nabla_F", env_compute_jacobian, py_n, py_z, py_nabla_F)

    Py_DECREF(py_z);
    Py_DECREF(py_nabla_F);
    Py_DECREF(py_n);
  };

  static void call_py_compute_Fncp(void* env, int n, double* z, double* F)
  {
    npy_intp dim[1];
    dim[0] = n;

    PyObject* py_z = FPyArray_SimpleNewFromData(1, dim, NPY_DOUBLE, z);
    PyObject* py_F = FPyArray_SimpleNewFromData(1, dim, NPY_DOUBLE, F);

    PyObject* py_n = PyInt_FromLong(n);

    PY_CALL_METHOD_OR_FUNCTION(env, "compute_F", env_compute_function, py_n, py_z, py_F)

    Py_DECREF(py_z);
    Py_DECREF(py_F);
    Py_DECREF(py_n);
  };

  static void call_py_compute_nabla_Fncp(void* env, int n, double* z, NumericsMatrix* nabla_F)
  {
    npy_intp dim[1];
    dim[0] = n;

    npy_intp dim2[2];
    dim2[0] = n;
    dim2[1] = n;

    PyObject* py_z = FPyArray_SimpleNewFromData(1, dim, NPY_DOUBLE, z);
    assert(nabla_F->matrix0 && "only dense matrix is supported");
    PyObject* py_nabla_F = FPyArray_SimpleNewFromData(2, dim2, NPY_DOUBLE, nabla_F->matrix0);

    PyObject* py_n = PyInt_FromLong(n);

    PY_CALL_METHOD_OR_FUNCTION(env, "compute_nabla_F", env_compute_jacobian, py_n, py_z, py_nabla_F)

    Py_DECREF(py_z);
    Py_DECREF(py_nabla_F);
    Py_DECREF(py_n);
  };

  static void* get_c_functions(PyObject* lib_name, PyObject* f1_name, PyObject* f2_name, void** void_ptr1, void** void_ptr2)
  {

    // implementation note: if something related to the library opening fails,
    // the called functions "handle" it and exit.

    char* name_str;
    void* handle_lib;

#if PY_MAJOR_VERSION < 3
    name_str = PyString_AsString(lib_name);
#else
    PyObject* tmp_ascii;
    tmp_ascii = PyUnicode_AsASCIIString(lib_name);
    name_str = PyBytes_AsString(tmp_ascii);
#endif

    handle_lib = open_library(name_str, 0);

#if PY_MAJOR_VERSION < 3
    name_str = PyString_AsString(f1_name);
#else
    Py_DECREF(tmp_ascii);
    tmp_ascii = PyUnicode_AsASCIIString(f1_name);
    name_str = PyBytes_AsString(tmp_ascii);
#endif

    *void_ptr1 = get_function_address(handle_lib, name_str);

#if PY_MAJOR_VERSION < 3
    name_str = PyString_AsString(f2_name);
#else
    Py_DECREF(tmp_ascii);
    tmp_ascii = PyUnicode_AsASCIIString(f2_name);
    name_str = PyBytes_AsString(tmp_ascii);
#endif

    *void_ptr2 = get_function_address(handle_lib, name_str);

#if PY_MAJOR_VERSION >= 3
    Py_XDECREF(tmp_ascii);
#endif

    return handle_lib;
  }

/*  if (ptr == NULL)
  {
    PyErr_SetString("can not find procedure " + procedure);
    PyErr_PrintEx(0);
    exit(err);
  }
*/


#include "MixedComplementarityProblem.h"
#include "MCP_Solvers.h"
#include "MCP_cst.h"
  
SWIGINTERN struct MixedComplementarityProblem *new_MixedComplementarityProblem__SWIG_0(void){
     MixedComplementarityProblem* MCP;
     MCP =  (MixedComplementarityProblem *) malloc(sizeof(MixedComplementarityProblem));
     MCP->Fmcp=NULL;
     MCP->nablaFmcp=NULL;
     MCP->computeFmcp=NULL;
     MCP->computeNablaFmcp=NULL;
     return MCP;
   }
SWIGINTERN void MixedComplementarityProblem_set_computeFmcp(struct MixedComplementarityProblem *self,PyObject *o){
    set_my_callback_Fmcp(o);
    self->computeFmcp = (my_call_to_callback_Fmcp);
  }
SWIGINTERN void MixedComplementarityProblem_set_computeNablaFmcp(struct MixedComplementarityProblem *self,PyObject *o){

    set_my_callback_NablaFmcp(o);
    self->computeNablaFmcp = (my_call_to_callback_NablaFmcp);
  }
SWIGINTERN void MixedComplementarityProblem_test_call_to_callback(struct MixedComplementarityProblem *self){
    printf("I am in test_call_to_callback()\n");

    int size =   self->sizeEqualities +  self->sizeInequalities;

    double * z = (double *)malloc(size*sizeof(double));
    double * F = (double *)malloc(size*sizeof(double));
    double * nablaF = (double *)malloc(size*size*sizeof(double));

    for (int i=0; i < size; i++) z[i]=i;
    printf("Input \n");
    for (int i=0; i < size; i++) printf("z[%i] = %lf\t", i, z[i]);
    printf("\n");
    self->computeFmcp(size,z,F);
    if  (!PyErr_Occurred())
    {
      self->computeNablaFmcp(size,z,nablaF);
    }
    printf("Output \n");
    for (int i=0; i < size; i++) printf("F[%i] =  %lf\t", i, F[i]);
    printf("\n");
    for (int i=0; i < size*size; i++) printf("nablaF[%i] =  %lf\t", i, nablaF[i]);

    printf("\n");
    free(z);
    free(F);
    free(nablaF);



    printf("I leave test_call_to_callback()\n");
  }
SWIGINTERN struct MixedComplementarityProblem *new_MixedComplementarityProblem__SWIG_1(PyObject *sizeEq,PyObject *sizeIneq,PyObject *o1,PyObject *o2){
     MixedComplementarityProblem* MCP;
     MCP =  (MixedComplementarityProblem *) malloc(sizeof(MixedComplementarityProblem));

     SWIG_AsVal_int(sizeEq, &MCP->sizeEqualities);
     SWIG_AsVal_int(sizeIneq, &MCP->sizeInequalities);
     int size =  MCP->sizeEqualities +  MCP->sizeInequalities;

     if (size<1)
     {
       SWIG_Error(SWIG_RuntimeError, "sizeEqualities + sizeInequalities has to be positive");
       MCP->Fmcp = NULL;
       MCP->nablaFmcp = NULL;
       freeMixedComplementarityProblem(MCP);
       return NULL;
     }
     else
     {
       MCP->Fmcp = (double *) malloc(size*sizeof(double));
       MCP->nablaFmcp = (double *) malloc(size*size*sizeof(double));
     }

     if (PyCallable_Check(o1))
     {
       set_my_callback_Fmcp(o1);
       MCP->computeFmcp = (my_call_to_callback_Fmcp);
     }
     else
     {
       SWIG_Error(SWIG_TypeError, "argument 3 must be callable");
       free(MCP->Fmcp);
       free(MCP->nablaFmcp);
       MCP->Fmcp = NULL;
       MCP->nablaFmcp = NULL;
       freeMixedComplementarityProblem(MCP);
       return NULL;
     }


     if (PyCallable_Check(o2))
     {
       set_my_callback_NablaFmcp(o2);
       MCP->computeNablaFmcp = (my_call_to_callback_NablaFmcp);
     }
     else
     {
       SWIG_Error(SWIG_TypeError, "argument 4 must be callable");
       free(MCP->Fmcp);
       free(MCP->nablaFmcp);
       MCP->Fmcp = NULL;
       MCP->nablaFmcp = NULL;
       freeMixedComplementarityProblem(MCP);
       return NULL;
     }

     return MCP;
   }
SWIGINTERN void delete_MixedComplementarityProblem(struct MixedComplementarityProblem *self){
    free(self->Fmcp);
    free(self->nablaFmcp);
    self->Fmcp = NULL;
    self->nablaFmcp = NULL;
    freeMixedComplementarityProblem(self);
  }
SWIGINTERN void MixedComplementarityProblem2_call_compute_F(void *problem,int n,double *z,double *F){      PyObject* target_z;      C_to_target_lang1(target_z, n, z, PyErr_PrintEx(0));        PyObject* target_F;      C_to_target_lang1(target_F, n, F, PyErr_PrintEx(0));;        PyObject* target_n = SWIG_From_int(n);        void* env =  (void*)(problem);        PY_CALL_METHOD_OR_FUNCTION(env, "compute_F", env_compute_function, target_F, target_n, target_z);        sn_check_size_mat_vec(n, (PyArrayObject*)target_F, PyErr_PrintEx(0));        Py_DECREF(target_z);      Py_DECREF(target_F);      Py_DECREF(target_n);    }
SWIGINTERN void MixedComplementarityProblem2_call_compute_nabla_F(void *problem,int n,double *z,NumericsMatrix *nabla_F){      PyObject* target_z;      C_to_target_lang1(target_z, n, z, PyErr_PrintEx(0));        PyObject* target_nabla_F;      target_nabla_F = NM_to_python(nabla_F);;        PyObject* target_n = SWIG_From_int(n);        void* env = (void*)(problem);        PY_CALL_METHOD_OR_FUNCTION(env, "compute_nabla_F", env_compute_jacobian, target_nabla_F, target_n, target_z);        /*@SWIG:/scratch/huber/siconos/siconos/numerics/swig/Numerics_callback.i,3,%TARGET_MATRIX_FROM_CALL@*/
{
  switch(nabla_F->storageType)
  {
  case NM_DENSE:
  {
     {    if (CHECK_ARRAY_MATRIX((PyArrayObject*)(PyArrayObject*)target_nabla_F)) { SWIG_Error(SWIG_RuntimeError, "object is not a matrix"); PyErr_PrintEx(0); }    sn_check_size_mat(nabla_F->size0, nabla_F->size1, (PyArrayObject*)(PyArrayObject*)target_nabla_F, PyErr_PrintEx(0));    if (!nabla_F->matrix0) { SWIG_Error(SWIG_RuntimeError, "destination (dense) matrix is not allocated"); PyErr_PrintEx(0); }    memcpy(nabla_F->matrix0, array_data((PyArrayObject*)(PyArrayObject*)target_nabla_F), nabla_F->size0 * nabla_F->size1 * sizeof(double));  };
    break;
  }
  case NM_SPARSE_BLOCK:
  case NM_SPARSE:
  {
    // XXX Quite a bit of overhead here
    /*@SWIG:/scratch/huber/siconos/siconos/numerics/swig/numerics_NM.i,7,%NM_convert_from_target@*/
{
 PyArrayObject* array_ = NULL;
 int array_ctrl_ = 0;
 PyArrayObject* array_i_ = NULL;
 int array_i_ctrl_ = 0;
 PyArrayObject* array_p_ = NULL;
 int array_p_ctrl_ = 0;
 int alloc_ctrl_ = 0;
 NumericsMatrix *nummat = NULL;


   NumericsMatrix* Mtmp = NM_convert_from_python(target_nabla_F, &nummat, &array_, &array_ctrl_, &array_i_, &array_i_ctrl_, &array_p_, &array_p_ctrl_, &alloc_ctrl_);






   if (!Mtmp) { PyErr_PrintEx(0); }

  *(&(nabla_F)) = NM_create(Mtmp->storageType, Mtmp->size0, Mtmp->size1);
  NM_copy(Mtmp, *(&(nabla_F)));

  if(array_ctrl_ && array_) { Py_DECREF(array_); };
  if(array_i_ctrl_ && array_i_) { Py_DECREF(array_i_); };
  if(array_p_ctrl_ && array_p_) { Py_DECREF(array_p_); };

  if (nummat)
  {
    if (!NM_clean(nummat, alloc_ctrl_)) { PyErr_PrintEx(0); }
    free(nummat);
  }

}
/*@SWIG@*/;
    break;
  }
  default:
  {
    SWIG_Error(SWIG_TypeError, "TARGET_MATRIX_FROM_CALL :: unsupported storage type");
    PyErr_PrintEx(0);
  }
  }
}
/*@SWIG@*/;        Py_DECREF(target_z);      Py_DECREF(target_nabla_F);      Py_DECREF(target_n);    }
SWIGINTERN struct MixedComplementarityProblem2 *new_MixedComplementarityProblem2__SWIG_0(void){
     MixedComplementarityProblem2* MCP = newMCP();
     return MCP;
   }
SWIGINTERN struct MixedComplementarityProblem2 *new_MixedComplementarityProblem2__SWIG_1(PyObject *n1,PyObject *n2){
     MixedComplementarityProblem2* MCP = newMCP();

     SWIG_AsVal_int(n1, &MCP->n1);
     SWIG_AsVal_int(n2, &MCP->n2);
     int size =  MCP->n1 +  MCP->n2;

     if (size<1)
     {
       SWIG_Error(SWIG_RuntimeError, "sizeEqualities + sizeInequalities has to be positive");
       free(MCP);
       return NULL;
     }
     else
     {
     //TODO implement different types of matrices
       MCP->nabla_Fmcp = NM_create(NM_DENSE, size, size);
     }
     return MCP;
  }
SWIGINTERN struct MixedComplementarityProblem2 *new_MixedComplementarityProblem2__SWIG_2(PyObject *n1,PyObject *n2,PyObject *py_compute){
     MixedComplementarityProblem2* MCP = newMCP();

     MCP->compute_Fmcp = &call_py_compute_Fmcp;
     MCP->compute_nabla_Fmcp = &call_py_compute_nabla_Fmcp;
     SWIG_AsVal_int(n1, &MCP->n1);
     SWIG_AsVal_int(n2, &MCP->n2);
     int size =  MCP->n1 +  MCP->n2;

     if (size<1)
     {
       SWIG_Error(SWIG_RuntimeError, "sizeEqualities + sizeInequalities has to be positive");
       free(MCP);
       return NULL;
     }
     else
     {
       MCP->nabla_Fmcp = NM_create(NM_DENSE, size, size);
     }

     PyObject* method_compute_F = NULL;
     if (PyObject_HasAttrString(py_compute, "compute_F")) method_compute_F = PyObject_GetAttrString(py_compute, "compute_F");
     PyObject* method_compute_nabla_F = NULL;
     if (PyObject_HasAttrString(py_compute, "compute_nabla_F")) method_compute_nabla_F = PyObject_GetAttrString(py_compute, "compute_nabla_F");
     if (PyCallable_Check(method_compute_F) && PyCallable_Check(method_compute_nabla_F))
     {
       MCP->env = (void*) malloc(sizeof(class_env_python));
       class_env_python* mcp_env_python = (class_env_python*) MCP->env;
       mcp_env_python->id = ENV_IS_PYTHON_CLASS;
       mcp_env_python->class_object = py_compute;
       Py_DECREF(method_compute_F);
       Py_DECREF(method_compute_nabla_F);
     }
     else
     {
       Py_XDECREF(method_compute_F);
       Py_XDECREF(method_compute_nabla_F);
       SWIG_Error(SWIG_TypeError, "argument 2 must be have a method compute_F and a method compute_nabla_F");
       NM_free(MCP->nabla_Fmcp);
       free(MCP->nabla_Fmcp);
       free(MCP);
       return NULL;
     }

     return MCP;
   }
SWIGINTERN struct MixedComplementarityProblem2 *new_MixedComplementarityProblem2__SWIG_3(PyObject *n1,PyObject *n2,PyObject *compute_F,PyObject *compute_nabla_F){
     MixedComplementarityProblem2* MCP = newMCP();

     SWIG_AsVal_int(n1, &MCP->n1);
     SWIG_AsVal_int(n2, &MCP->n2);
     int size =  MCP->n1 +  MCP->n2;

     if (size<1)
     {
       SWIG_Error(SWIG_RuntimeError, "sizeEqualities + sizeInequalities has to be positive");
       free(MCP);
       return NULL;
     }
     else
     {
       MCP->nabla_Fmcp = NM_create(NM_DENSE, size, size);
     }

     /*@SWIG:/scratch/huber/siconos/siconos/wrap/swig/target_datatypes.i,62,check_save_target_fn@*/
  if (PyCallable_Check(compute_F))
  {
    MCP->compute_Fmcp = MixedComplementarityProblem2_call_compute_F;
    if (!MCP->env) MCP->env = malloc(sizeof(functions_env_python));
    functions_env_python* vi_env_python = (functions_env_python*) MCP->env;
    vi_env_python->id = ENV_IS_PYTHON_FUNCTIONS;
    vi_env_python->env_compute_function = compute_F;
  }
  else
  {
    SWIG_Error(SWIG_TypeError, "argument ""2" " must be callable");
    PyErr_PrintEx(0);
  }
/*@SWIG@*/;
     /*@SWIG:/scratch/huber/siconos/siconos/wrap/swig/target_datatypes.i,62,check_save_target_fn@*/
  if (PyCallable_Check(compute_nabla_F))
  {
    MCP->compute_nabla_Fmcp = MixedComplementarityProblem2_call_compute_nabla_F;
    if (!MCP->env) MCP->env = malloc(sizeof(functions_env_python));
    functions_env_python* vi_env_python = (functions_env_python*) MCP->env;
    vi_env_python->id = ENV_IS_PYTHON_FUNCTIONS;
    vi_env_python->env_compute_jacobian = compute_nabla_F;
  }
  else
  {
    SWIG_Error(SWIG_TypeError, "argument ""3" " must be callable");
    PyErr_PrintEx(0);
  }
/*@SWIG@*/;

     return MCP;
   }
SWIGINTERN void MixedComplementarityProblem2_set_compute_F_and_nabla_F_as_C_functions(struct MixedComplementarityProblem2 *self,PyObject *lib_name,PyObject *compute_F_name,PyObject *compute_nabla_F_name){
#if PY_MAJOR_VERSION < 3
    if(PyString_Check(lib_name) && PyString_Check(compute_F_name) && PyString_Check(compute_nabla_F_name))
#else
    if(PyUnicode_Check(lib_name) && PyUnicode_Check(compute_F_name) && PyUnicode_Check(compute_nabla_F_name))
#endif
    {
    void* p_compute_F;
    void* p_compute_nabla_F;

    // TODO: save this lib_handle somewhere and close it !
    get_c_functions(lib_name, compute_F_name, compute_nabla_F_name, &p_compute_F, &p_compute_nabla_F);

    self->compute_Fmcp = (ptrFunctionMCP2)p_compute_F;
    self->compute_nabla_Fmcp = (ptrFunctionMCP_nabla)p_compute_nabla_F;

    }
    else
    {
      SWIG_Error(SWIG_TypeError, "All arguments should be strings");
    }
  }
SWIGINTERN PyObject *MixedComplementarityProblem2_get_env_as_long(struct MixedComplementarityProblem2 *self){
      return SWIG_From_long((uintptr_t)&self->env);
    }
SWIGINTERN void delete_MixedComplementarityProblem2(struct MixedComplementarityProblem2 *self){
    if (self->env)
    {
      if(((env_target_lang*)self->env)->id > 0)
      {
        free(self->env);
        self->env = NULL;
      }
    }
    freeMCP(self);
  }

#include "NonlinearComplementarityProblem.h"
#include "NCP_Solvers.h"
#include "NCP_cst.h"
  
SWIGINTERN void NonlinearComplementarityProblem_call_compute_F(void *problem,int n,double *z,double *F){      PyObject* target_z;      C_to_target_lang1(target_z, n, z, PyErr_PrintEx(0));        PyObject* target_F;      C_to_target_lang1(target_F, n, F, PyErr_PrintEx(0));;        PyObject* target_n = SWIG_From_int(n);        void* env =  (void*)(problem);        PY_CALL_METHOD_OR_FUNCTION(env, "compute_F", env_compute_function, target_F, target_n, target_z);        sn_check_size_mat_vec(n, (PyArrayObject*)target_F, PyErr_PrintEx(0));        Py_DECREF(target_z);      Py_DECREF(target_F);      Py_DECREF(target_n);    }
SWIGINTERN void NonlinearComplementarityProblem_call_compute_nabla_F(void *problem,int n,double *z,NumericsMatrix *nabla_F){      PyObject* target_z;      C_to_target_lang1(target_z, n, z, PyErr_PrintEx(0));        PyObject* target_nabla_F;      target_nabla_F = NM_to_python(nabla_F);;        PyObject* target_n = SWIG_From_int(n);        void* env = (void*)(problem);        PY_CALL_METHOD_OR_FUNCTION(env, "compute_nabla_F", env_compute_jacobian, target_nabla_F, target_n, target_z);        /*@SWIG:/scratch/huber/siconos/siconos/numerics/swig/Numerics_callback.i,3,%TARGET_MATRIX_FROM_CALL@*/
{
  switch(nabla_F->storageType)
  {
  case NM_DENSE:
  {
     {    if (CHECK_ARRAY_MATRIX((PyArrayObject*)(PyArrayObject*)target_nabla_F)) { SWIG_Error(SWIG_RuntimeError, "object is not a matrix"); PyErr_PrintEx(0); }    sn_check_size_mat(nabla_F->size0, nabla_F->size1, (PyArrayObject*)(PyArrayObject*)target_nabla_F, PyErr_PrintEx(0));    if (!nabla_F->matrix0) { SWIG_Error(SWIG_RuntimeError, "destination (dense) matrix is not allocated"); PyErr_PrintEx(0); }    memcpy(nabla_F->matrix0, array_data((PyArrayObject*)(PyArrayObject*)target_nabla_F), nabla_F->size0 * nabla_F->size1 * sizeof(double));  };
    break;
  }
  case NM_SPARSE_BLOCK:
  case NM_SPARSE:
  {
    // XXX Quite a bit of overhead here
    /*@SWIG:/scratch/huber/siconos/siconos/numerics/swig/numerics_NM.i,7,%NM_convert_from_target@*/
{
 PyArrayObject* array_ = NULL;
 int array_ctrl_ = 0;
 PyArrayObject* array_i_ = NULL;
 int array_i_ctrl_ = 0;
 PyArrayObject* array_p_ = NULL;
 int array_p_ctrl_ = 0;
 int alloc_ctrl_ = 0;
 NumericsMatrix *nummat = NULL;


   NumericsMatrix* Mtmp = NM_convert_from_python(target_nabla_F, &nummat, &array_, &array_ctrl_, &array_i_, &array_i_ctrl_, &array_p_, &array_p_ctrl_, &alloc_ctrl_);






   if (!Mtmp) { PyErr_PrintEx(0); }

  *(&(nabla_F)) = NM_create(Mtmp->storageType, Mtmp->size0, Mtmp->size1);
  NM_copy(Mtmp, *(&(nabla_F)));

  if(array_ctrl_ && array_) { Py_DECREF(array_); };
  if(array_i_ctrl_ && array_i_) { Py_DECREF(array_i_); };
  if(array_p_ctrl_ && array_p_) { Py_DECREF(array_p_); };

  if (nummat)
  {
    if (!NM_clean(nummat, alloc_ctrl_)) { PyErr_PrintEx(0); }
    free(nummat);
  }

}
/*@SWIG@*/;
    break;
  }
  default:
  {
    SWIG_Error(SWIG_TypeError, "TARGET_MATRIX_FROM_CALL :: unsupported storage type");
    PyErr_PrintEx(0);
  }
  }
}
/*@SWIG@*/;        Py_DECREF(target_z);      Py_DECREF(target_nabla_F);      Py_DECREF(target_n);    }
SWIGINTERN struct NonlinearComplementarityProblem *new_NonlinearComplementarityProblem__SWIG_0(void){
     NonlinearComplementarityProblem* NCP = newNCP();
     return NCP;
   }
SWIGINTERN struct NonlinearComplementarityProblem *new_NonlinearComplementarityProblem__SWIG_1(PyObject *n){
     NonlinearComplementarityProblem* NCP = newNCP();

     SWIG_AsVal_unsigned_SS_int(n, &NCP->n);

     if (NCP->n<1)
     {
       SWIG_Error(SWIG_RuntimeError, "sizeInequalities has to be positive");
       free(NCP);
       return NULL;
     }
     else
     {
     //TODO implement different types of matrices
       NCP->nabla_F = NM_create(NM_DENSE, NCP->n, NCP->n);
     }
     return NCP;
  }
SWIGINTERN struct NonlinearComplementarityProblem *new_NonlinearComplementarityProblem__SWIG_2(PyObject *n,PyObject *py_compute){
     NonlinearComplementarityProblem* NCP = newNCP();

     NCP->compute_F = &call_py_compute_Fncp;
     NCP->compute_nabla_F = &call_py_compute_nabla_Fncp;
     SWIG_AsVal_unsigned_SS_int(n, &NCP->n);

     if (NCP->n<1)
     {
       SWIG_Error(SWIG_RuntimeError, "sizeInequalities has to be positive");
       free(NCP);
       return NULL;
     }
     else
     {
       NCP->nabla_F = NM_create(NM_DENSE, NCP->n, NCP->n);
     }

     PyObject* method_compute_F = NULL;
     if (PyObject_HasAttrString(py_compute, "compute_F")) method_compute_F = PyObject_GetAttrString(py_compute, "compute_F");
     PyObject* method_compute_nabla_F = NULL;
     if (PyObject_HasAttrString(py_compute, "compute_nabla_F")) method_compute_nabla_F = PyObject_GetAttrString(py_compute, "compute_nabla_F");

     if (PyCallable_Check(method_compute_F) && PyCallable_Check(method_compute_nabla_F))
     {
       NCP->env = (void*) malloc(sizeof(class_env_python));
       class_env_python* ncp_env_python = (class_env_python*) NCP->env;
       ncp_env_python->id = ENV_IS_PYTHON_CLASS;
       ncp_env_python->class_object = py_compute;
       Py_DECREF(method_compute_F);
       Py_DECREF(method_compute_nabla_F);
     }
     else
     {
       Py_XDECREF(method_compute_F);
       Py_XDECREF(method_compute_nabla_F);
       SWIG_Error(SWIG_TypeError, "argument 2 must be have a method compute_F and a method compute_nabla_F");
       NM_free(NCP->nabla_F);
       free(NCP->nabla_F);
       free(NCP);
       return NULL;
     }

     return NCP;
   }
SWIGINTERN struct NonlinearComplementarityProblem *new_NonlinearComplementarityProblem__SWIG_3(PyObject *n,PyObject *compute_F,PyObject *compute_nabla_F){
     NonlinearComplementarityProblem* NCP = newNCP();

     SWIG_AsVal_unsigned_SS_int(n, &NCP->n);

     if (NCP->n<1)
     {
       SWIG_Error(SWIG_RuntimeError, "sizeInequalities has to be positive");
       free(NCP);
       return NULL;
     }
     else
     {
       NCP->nabla_F = NM_create(NM_DENSE, NCP->n, NCP->n);
     }

     /*@SWIG:/scratch/huber/siconos/siconos/wrap/swig/target_datatypes.i,62,check_save_target_fn@*/
  if (PyCallable_Check(compute_F))
  {
    NCP->compute_F = NonlinearComplementarityProblem_call_compute_F;
    if (!NCP->env) NCP->env = malloc(sizeof(functions_env_python));
    functions_env_python* vi_env_python = (functions_env_python*) NCP->env;
    vi_env_python->id = ENV_IS_PYTHON_FUNCTIONS;
    vi_env_python->env_compute_function = compute_F;
  }
  else
  {
    SWIG_Error(SWIG_TypeError, "argument ""2" " must be callable");
    PyErr_PrintEx(0);
  }
/*@SWIG@*/;
     /*@SWIG:/scratch/huber/siconos/siconos/wrap/swig/target_datatypes.i,62,check_save_target_fn@*/
  if (PyCallable_Check(compute_nabla_F))
  {
    NCP->compute_nabla_F = NonlinearComplementarityProblem_call_compute_nabla_F;
    if (!NCP->env) NCP->env = malloc(sizeof(functions_env_python));
    functions_env_python* vi_env_python = (functions_env_python*) NCP->env;
    vi_env_python->id = ENV_IS_PYTHON_FUNCTIONS;
    vi_env_python->env_compute_jacobian = compute_nabla_F;
  }
  else
  {
    SWIG_Error(SWIG_TypeError, "argument ""3" " must be callable");
    PyErr_PrintEx(0);
  }
/*@SWIG@*/;

     return NCP;
   }
SWIGINTERN void NonlinearComplementarityProblem_set_compute_F_and_nabla_F_as_C_functions(struct NonlinearComplementarityProblem *self,PyObject *lib_name,PyObject *compute_F_name,PyObject *compute_nabla_F_name){
#if PY_MAJOR_VERSION < 3
    if(PyString_Check(lib_name) && PyString_Check(compute_F_name) && PyString_Check(compute_nabla_F_name))
#else
    if(PyUnicode_Check(lib_name) && PyUnicode_Check(compute_F_name) && PyUnicode_Check(compute_nabla_F_name))
#endif
    {
    void* p_compute_F;
    void* p_compute_nabla_F;

    // TODO: save this lib_handle somewhere and close it !
    get_c_functions(lib_name, compute_F_name, compute_nabla_F_name, &p_compute_F, &p_compute_nabla_F);

    self->compute_F = (ptrFunctionNCP)p_compute_F;
    self->compute_nabla_F = (ptrFunctionJacNCP)p_compute_nabla_F;

    }
    else
    {
      SWIG_Error(SWIG_TypeError, "All arguments should be strings");
    }
  }
SWIGINTERN PyObject *NonlinearComplementarityProblem_get_env_as_long(struct NonlinearComplementarityProblem *self){
      return SWIG_From_long((uintptr_t)&self->env);
    }
SWIGINTERN void delete_NonlinearComplementarityProblem(struct NonlinearComplementarityProblem *self){
    if (self->nabla_F)
    {
      NM_free(self->nabla_F);
      free(self->nabla_F);
    }
    if (self->env)
    {
      if(((env_target_lang*)self->env)->id > 0)
      {
        free(self->env);
      }
    }
    free(self);
  }

#include "VariationalInequality.h"
#include "VariationalInequality_Solvers.h"
#include "VI_cst.h"
#include "VariationalInequality_Solvers.h"

SWIGINTERN void VariationalInequality_call_compute_F(void *problem,int n,double *z,double *F){      PyObject* target_z;      C_to_target_lang1(target_z, n, z, PyErr_PrintEx(0));        PyObject* target_F;      C_to_target_lang1(target_F, n, F, PyErr_PrintEx(0));;        PyObject* target_n = SWIG_From_int(n);        void* env =  VI_get_env(problem);        PY_CALL_METHOD_OR_FUNCTION(env, "compute_F", env_compute_function, target_F, target_n, target_z);        sn_check_size_mat_vec(n, (PyArrayObject*)target_F, PyErr_PrintEx(0));        Py_DECREF(target_z);      Py_DECREF(target_F);      Py_DECREF(target_n);    }
SWIGINTERN void VariationalInequality_call_compute_nabla_F(void *problem,int n,double *z,NumericsMatrix *nabla_F){      PyObject* target_z;      C_to_target_lang1(target_z, n, z, PyErr_PrintEx(0));        PyObject* target_nabla_F;      target_nabla_F = NM_to_python(nabla_F);;        PyObject* target_n = SWIG_From_int(n);        void* env = VI_get_env(problem);        PY_CALL_METHOD_OR_FUNCTION(env, "compute_nabla_F", env_compute_jacobian, target_nabla_F, target_n, target_z);        /*@SWIG:/scratch/huber/siconos/siconos/numerics/swig/Numerics_callback.i,3,%TARGET_MATRIX_FROM_CALL@*/
{
  switch(nabla_F->storageType)
  {
  case NM_DENSE:
  {
     {    if (CHECK_ARRAY_MATRIX((PyArrayObject*)(PyArrayObject*)target_nabla_F)) { SWIG_Error(SWIG_RuntimeError, "object is not a matrix"); PyErr_PrintEx(0); }    sn_check_size_mat(nabla_F->size0, nabla_F->size1, (PyArrayObject*)(PyArrayObject*)target_nabla_F, PyErr_PrintEx(0));    if (!nabla_F->matrix0) { SWIG_Error(SWIG_RuntimeError, "destination (dense) matrix is not allocated"); PyErr_PrintEx(0); }    memcpy(nabla_F->matrix0, array_data((PyArrayObject*)(PyArrayObject*)target_nabla_F), nabla_F->size0 * nabla_F->size1 * sizeof(double));  };
    break;
  }
  case NM_SPARSE_BLOCK:
  case NM_SPARSE:
  {
    // XXX Quite a bit of overhead here
    /*@SWIG:/scratch/huber/siconos/siconos/numerics/swig/numerics_NM.i,7,%NM_convert_from_target@*/
{
 PyArrayObject* array_ = NULL;
 int array_ctrl_ = 0;
 PyArrayObject* array_i_ = NULL;
 int array_i_ctrl_ = 0;
 PyArrayObject* array_p_ = NULL;
 int array_p_ctrl_ = 0;
 int alloc_ctrl_ = 0;
 NumericsMatrix *nummat = NULL;


   NumericsMatrix* Mtmp = NM_convert_from_python(target_nabla_F, &nummat, &array_, &array_ctrl_, &array_i_, &array_i_ctrl_, &array_p_, &array_p_ctrl_, &alloc_ctrl_);






   if (!Mtmp) { PyErr_PrintEx(0); }

  *(&(nabla_F)) = NM_create(Mtmp->storageType, Mtmp->size0, Mtmp->size1);
  NM_copy(Mtmp, *(&(nabla_F)));

  if(array_ctrl_ && array_) { Py_DECREF(array_); };
  if(array_i_ctrl_ && array_i_) { Py_DECREF(array_i_); };
  if(array_p_ctrl_ && array_p_) { Py_DECREF(array_p_); };

  if (nummat)
  {
    if (!NM_clean(nummat, alloc_ctrl_)) { PyErr_PrintEx(0); }
    free(nummat);
  }

}
/*@SWIG@*/;
    break;
  }
  default:
  {
    SWIG_Error(SWIG_TypeError, "TARGET_MATRIX_FROM_CALL :: unsupported storage type");
    PyErr_PrintEx(0);
  }
  }
}
/*@SWIG@*/;        Py_DECREF(target_z);      Py_DECREF(target_nabla_F);      Py_DECREF(target_n);    }
SWIGINTERN struct VariationalInequality *new_VariationalInequality__SWIG_0(PyObject *n){
     int nn;
     SWIG_AsVal_int(n, &nn);
     VariationalInequality* vi = variationalInequality_new(nn);
     assert(vi);

     if (vi->size < 1)
     {
       SWIG_Error(SWIG_RuntimeError, "the size of the VI has to be positive");
       PyErr_PrintEx(0);
       free(vi);
       return NULL;
     }

     vi->nabla_F = NM_create(NM_DENSE, nn, nn);

     return vi;
  }
SWIGINTERN struct VariationalInequality *new_VariationalInequality__SWIG_1(PyObject *n,PyObject *compute){

     int nn;
     SWIG_AsVal_int(n, &nn);
     VariationalInequality* vi = variationalInequality_new(nn);

     vi->nabla_F = NM_create(NM_DENSE, nn, nn);


     PyObject* method_compute_F = NULL;
     if (PyObject_HasAttrString(compute, "compute_F")) method_compute_F = PyObject_GetAttrString(compute, "compute_F");
     PyObject* method_compute_nabla_F = NULL;
     if (PyObject_HasAttrString(compute, "compute_nabla_F")) method_compute_nabla_F = PyObject_GetAttrString(compute, "compute_nabla_F");

     if (method_compute_F && method_compute_nabla_F && PyCallable_Check(method_compute_F) && PyCallable_Check(method_compute_nabla_F))
     {
       vi->env = (void*) malloc(sizeof(class_env_python));
       class_env_python* vi_env_python = (class_env_python*) vi->env;
       vi_env_python->id = ENV_IS_PYTHON_CLASS;
       vi_env_python->class_object = compute;
       Py_DECREF(method_compute_F);
       Py_DECREF(method_compute_nabla_F);
     }
     else

     {
       /*@SWIG:/scratch/huber/siconos/siconos/wrap/swig/target_datatypes.i,62,check_save_target_fn@*/
  if (PyCallable_Check(compute))
  {
    vi->F = VariationalInequality_call_compute_F;
    if (!vi->env) vi->env = malloc(sizeof(functions_env_python));
    functions_env_python* vi_env_python = (functions_env_python*) vi->env;
    vi_env_python->id = ENV_IS_PYTHON_FUNCTIONS;
    vi_env_python->env_compute_function = compute;
  }
  else
  {
    SWIG_Error(SWIG_TypeError, "argument ""2" " must be callable");
    PyErr_PrintEx(0);
  }
/*@SWIG@*/;
     }


     Py_XDECREF(method_compute_F);
     Py_XDECREF(method_compute_nabla_F);

     return vi;
   }
SWIGINTERN void VariationalInequality_set_compute_nabla_F(struct VariationalInequality *self,PyObject *compute_nabla_F){
     /*@SWIG:/scratch/huber/siconos/siconos/wrap/swig/target_datatypes.i,62,check_save_target_fn@*/
  if (PyCallable_Check(compute_nabla_F))
  {
    self->compute_nabla_F = VariationalInequality_call_compute_nabla_F;
    if (!self->env) self->env = malloc(sizeof(functions_env_python));
    functions_env_python* vi_env_python = (functions_env_python*) self->env;
    vi_env_python->id = ENV_IS_PYTHON_FUNCTIONS;
    vi_env_python->env_compute_jacobian = compute_nabla_F;
  }
  else
  {
    SWIG_Error(SWIG_TypeError, "argument ""1" " must be callable");
    PyErr_PrintEx(0);
  }
/*@SWIG@*/;
   }
SWIGINTERN void VariationalInequality_set_box_constraints(struct VariationalInequality *self,PyObject *box_lower_bound,PyObject *box_upper_bound){
     if ((PyObject_Length(box_lower_bound) == self->size) && (PyObject_Length(box_upper_bound) == self->size))
     {
       self->set = (void *)malloc(sizeof(box_constraints));
       box_constraints* box_c = (box_constraints*)self->set;
       box_c->id = SICONOS_SET_BOX;
       box_c->lb = (double*)malloc(self->size*sizeof(double));
       box_c->ub = (double*)malloc(self->size*sizeof(double));

       if (!convert_darray(box_lower_bound, box_c->lb) || !convert_darray(box_upper_bound, box_c->ub))
       {
         PyErr_PrintEx(0);
         exit(1);
       }
     }
     else
     {
       SWIG_Error(SWIG_TypeError, "The arguments do not have the right length");
       PyErr_PrintEx(0);
     }
   }
SWIGINTERN void VariationalInequality_set_compute_F_and_nabla_F_as_C_functions(struct VariationalInequality *self,PyObject *lib_name,PyObject *compute_F_name,PyObject *compute_nabla_F_name){
#if PY_MAJOR_VERSION < 3
    if(PyString_Check(lib_name) && PyString_Check(compute_F_name) && PyString_Check(compute_nabla_F_name))
#else
    if(PyUnicode_Check(lib_name) && PyUnicode_Check(compute_F_name) && PyUnicode_Check(compute_nabla_F_name))
#endif
    {
    void* p_compute_F;
    void* p_compute_nabla_F;

    // TODO: save this lib_handle somewhere and close it !
    get_c_functions(lib_name, compute_F_name, compute_nabla_F_name, &p_compute_F, &p_compute_nabla_F);

    self->F = (ptrFunctionVI)p_compute_F;
    self->compute_nabla_F = (ptrFunctionVI_nabla)p_compute_nabla_F;
    }
    else
    {
      SWIG_Error(SWIG_TypeError, "All arguments should be strings");
      PyErr_PrintEx(0);
    }
  }
SWIGINTERN PyObject *VariationalInequality_get_env_as_long(struct VariationalInequality *self){
      return SWIG_From_long((uintptr_t)&self->env);
    }
SWIGINTERN void delete_VariationalInequality(struct VariationalInequality *self){
    if (self->set)
    {
      //black magic
      switch (((generic_set*)self->set)->id)
      {
        case SICONOS_SET_BOX:
        {
          box_constraints* box_c = (box_constraints*)self->set;
          free_box(box_c);
          break;
        }
        default:
        {
          SWIG_Error(SWIG_TypeError, "unknown set type");
          PyErr_PrintEx(0);
        }
      }
      free(self->set);
      self->set = NULL;
    }
    if (self->env)
    {
      if(((env_target_lang*)self->env)->id > 0)
      {
        free(self->env);
      }
    }
    freeVariationalInequalityProblem(self);
  }

#include "ConvexQP.h"
#include "ConvexQP_Solvers.h"
#include "ConvexQP_cst.h"
#include "ConvexQP_Solvers.h"
#include "SiconosCompat.h"


#include "SecondOrderConeLinearComplementarityProblem.h"
#include "SOCLCP_Solvers.h"
#include "SOCLCP_cst.h"
#include "SOCLCP_Solvers.h"


#include "fc3d_Solvers.h"
#include "Friction_cst.h"
#include "FrictionContactProblem.h"
#include "fc3d_compute_error.h"
#ifdef WITH_FCLIB
// avoid a conflict with old csparse.h in case fclib.h includes it
#define _CS_H
#include "fclib_interface.h"
#endif
#include "fc2d_Solvers.h"
#include "gfc3d_Solvers.h"
#include "fc3d_AlartCurnier_functions.h"
#include "AlartCurnierGenerated.h"
#include "FischerBurmeisterGenerated.h"
#include "NaturalMapGenerated.h"

SWIGINTERN struct FrictionContactProblem *new_FrictionContactProblem__SWIG_0(void){
    return frictionContactProblem_new();
  }
SWIGINTERN struct FrictionContactProblem *new_FrictionContactProblem__SWIG_1(PyObject *o){
    FrictionContactProblem* fcp;
    FrictionContactProblem* FCP;

    /*@SWIG:/scratch/huber/siconos/siconos/numerics/swig/numerics.i,97,%SN_INPUT_CHECK_RETURN@*/
{ void* _ptr = NULL; if (!SWIG_IsOK(SWIG_ConvertPtr(o, &_ptr, SWIGTYPE_p_FrictionContactProblem, 0 |  0 ))) {
    char errmsg[1024];
    snprintf(errmsg, sizeof(errmsg), "Argument check failed! Argument %s has the wrong type, should be %s","o","FrictionContactProblem");
    SWIG_Error(SWIG_TypeError, errmsg); return NULL; }
    fcp = (FrictionContactProblem*)(_ptr);
   }
/*@SWIG@*/;

    FCP = frictionContactProblem_new();
    FCP->dimension = fcp->dimension;

    FCP->M = NM_create(fcp->M->storageType, fcp->M->size0, fcp->M->size1);

    NM_copy(FCP->M, fcp->M);

    FCP->numberOfContacts = fcp->numberOfContacts;
    size_t size =  fcp->dimension * fcp->numberOfContacts;

    FCP->q = (double*) malloc(size * sizeof(double));
    memcpy(FCP->q, fcp->q, size * sizeof(double));

    FCP->q = (double*) malloc(size * sizeof(double));
    memcpy(FCP->mu, fcp->mu, size * sizeof(double));

    return FCP;
  }
SWIGINTERN struct FrictionContactProblem *new_FrictionContactProblem__SWIG_2(PyObject *dim,PyObject *numberOfContacts,PyObject *M,PyObject *q,PyObject *mu){
    FrictionContactProblem * FC = frictionContactProblem_new();
    SWIG_AsVal_int(dim, &FC->dimension);
    SWIG_AsVal_int(numberOfContacts, &FC->numberOfContacts);

    /*@SWIG:/scratch/huber/siconos/siconos/numerics/swig/numerics_NM.i,7,%NM_convert_from_target@*/
{
 PyArrayObject* array_ = NULL;
 int array_ctrl_ = 0;
 PyArrayObject* array_i_ = NULL;
 int array_i_ctrl_ = 0;
 PyArrayObject* array_p_ = NULL;
 int array_p_ctrl_ = 0;
 int alloc_ctrl_ = 0;
 NumericsMatrix *nummat = NULL;


   NumericsMatrix* Mtmp = NM_convert_from_python(M, &nummat, &array_, &array_ctrl_, &array_i_, &array_i_ctrl_, &array_p_, &array_p_ctrl_, &alloc_ctrl_);






   if (!Mtmp) { return NULL; }

  *((&FC->M)) = NM_create(Mtmp->storageType, Mtmp->size0, Mtmp->size1);
  NM_copy(Mtmp, *((&FC->M)));

  if(array_ctrl_ && array_) { Py_DECREF(array_); };
  if(array_i_ctrl_ && array_i_) { Py_DECREF(array_i_); };
  if(array_p_ctrl_ && array_p_) { Py_DECREF(array_p_); };

  if (nummat)
  {
    if (!NM_clean(nummat, alloc_ctrl_)) { return NULL; }
    free(nummat);
  }

}
/*@SWIG@*/;

    int is_new_objectq=0;
    PyArrayObject* vector = obj_to_sn_vector(q, &is_new_objectq);

    sn_check_size_mat_vec(FC->M->size0, vector, return NULL);
    set_vec_from_target(FC->q, vector, , return NULL);

    int is_new_objectmu = 0;
    PyArrayObject* vectormu = obj_to_sn_vector(mu, &is_new_objectmu);

    sn_check_size_mat_vec(FC->numberOfContacts, vectormu, return NULL);
    set_vec_from_target(FC->mu, vectormu, , return NULL);

    if(is_new_objectq && vector) { Py_DECREF(vector); };
    if(is_new_objectmu && vectormu) { Py_DECREF(vectormu); };

    return FC;

  }
SWIGINTERN struct FrictionContactProblem *new_FrictionContactProblem__SWIG_3(PyObject *dim,PyObject *M,PyObject *q,PyObject *mu){
    FrictionContactProblem * FC = frictionContactProblem_new();

    SWIG_AsVal_int(dim, &FC->dimension);

    /*@SWIG:/scratch/huber/siconos/siconos/numerics/swig/numerics_NM.i,7,%NM_convert_from_target@*/
{
 PyArrayObject* array_ = NULL;
 int array_ctrl_ = 0;
 PyArrayObject* array_i_ = NULL;
 int array_i_ctrl_ = 0;
 PyArrayObject* array_p_ = NULL;
 int array_p_ctrl_ = 0;
 int alloc_ctrl_ = 0;
 NumericsMatrix *nummat = NULL;


   NumericsMatrix* Mtmp = NM_convert_from_python(M, &nummat, &array_, &array_ctrl_, &array_i_, &array_i_ctrl_, &array_p_, &array_p_ctrl_, &alloc_ctrl_);






   if (!Mtmp) { return NULL; }

  *((&FC->M)) = NM_create(Mtmp->storageType, Mtmp->size0, Mtmp->size1);
  NM_copy(Mtmp, *((&FC->M)));

  if(array_ctrl_ && array_) { Py_DECREF(array_); };
  if(array_i_ctrl_ && array_i_) { Py_DECREF(array_i_); };
  if(array_p_ctrl_ && array_p_) { Py_DECREF(array_p_); };

  if (nummat)
  {
    if (!NM_clean(nummat, alloc_ctrl_)) { return NULL; }
    free(nummat);
  }

}
/*@SWIG@*/;

    FC->numberOfContacts = FC->M->size0 / FC->dimension;

    int is_new_objectq=0;
    PyArrayObject* vector = obj_to_sn_vector(q, &is_new_objectq);

    sn_check_size_mat_vec(FC->M->size0, vector, return NULL);
    set_vec_from_target(FC->q, vector, , return NULL);

    int is_new_objectmu = 0;
    PyArrayObject* vectormu = obj_to_sn_vector(mu, &is_new_objectmu);

    sn_check_size_mat_vec(FC->numberOfContacts, vectormu, return NULL);
    set_vec_from_target(FC->mu, vectormu, , return NULL);

    if(is_new_objectq && vector) { Py_DECREF(vector); };
    if(is_new_objectmu && vectormu) { Py_DECREF(vectormu); };


    return FC;
  }
SWIGINTERN void delete_FrictionContactProblem(struct FrictionContactProblem *self){
    frictionContactProblem_free(self);
  }


#include <stdio.h>
  static FrictionContactProblem* frictionContactProblemFromFile
    (const char * filename)
  {
    FILE * finput = fopen(filename, "r");
    if (finput)
    {
      FrictionContactProblem* problem =
        (FrictionContactProblem *) malloc(sizeof(FrictionContactProblem));
      if (frictionContact_newFromFile(problem,finput))
      {
      char msg[1024];
      snprintf(msg, sizeof(msg), "frictionContactProblemFromFile: cannot load %s\n",filename);
      SWIG_Error(SWIG_RuntimeError, msg);
      free(problem);
      fclose(finput);
      return NULL;
      }
      else
      {
        fclose(finput);
        return problem;
      }
    }
    else
    {
      char msg[1024];
      snprintf(msg, sizeof(msg), "frictionContactProblemFromFile: cannot open %s\n",filename);
      SWIG_Error(SWIG_RuntimeError, msg);
      return NULL;
    }

  }


SWIGINTERN SN_GAMSparams *new_SN_GAMSparams(SolverOptions *SO){
    assert(SO->solverParameters);
    return (SN_GAMSparams*) SO->solverParameters;
  }
SWIGINTERN void SN_GAMSparams_gamsdir_set(SN_GAMSparams *self,PyObject *strobj){
    /*@SWIG:/scratch/huber/siconos/siconos/numerics/swig/numerics.i,475,STR_FIELD_COPY@*/
{
  int alloc = 0;
  char* name_str;
  size_t len = 0;
  int res = SWIG_AsCharPtrAndSize(strobj, &name_str, &len, &alloc);
  if (!SWIG_IsOK(res)) {
    SWIG_Error(SWIG_ArgError(res), "in method unknown', argument " "1"" of type '" "char *""'");
  }

  // Some weird logic here
  if (self->gams_dir)
  {
    self->gams_dir = (char*)realloc(self->gams_dir, len*sizeof(char));
  }
  else
  {
    self->gams_dir = (char*)malloc(len*sizeof(char));
  }
  strncpy(self->gams_dir, name_str, len);

  if (alloc == SWIG_NEWOBJ) free(name_str);

}
/*@SWIG@*/
  }
SWIGINTERN void SN_GAMSparams_modeldir_set(SN_GAMSparams *self,PyObject *strobj){
    /*@SWIG:/scratch/huber/siconos/siconos/numerics/swig/numerics.i,475,STR_FIELD_COPY@*/
{
  int alloc = 0;
  char* name_str;
  size_t len = 0;
  int res = SWIG_AsCharPtrAndSize(strobj, &name_str, &len, &alloc);
  if (!SWIG_IsOK(res)) {
    SWIG_Error(SWIG_ArgError(res), "in method unknown', argument " "1"" of type '" "char *""'");
  }

  // Some weird logic here
  if (self->model_dir)
  {
    self->model_dir = (char*)realloc(self->model_dir, len*sizeof(char));
  }
  else
  {
    self->model_dir = (char*)malloc(len*sizeof(char));
  }
  strncpy(self->model_dir, name_str, len);

  if (alloc == SWIG_NEWOBJ) free(name_str);

}
/*@SWIG@*/
  }
SWIGINTERN void delete_SN_GAMSparams(SN_GAMSparams *self){
    //do nothing
  }

#include "GlobalFrictionContactProblem.h"
#include "gfc3d_Solvers.h"
#include "gfc3d_compute_error.h"
  

SWIGINTERN struct GlobalFrictionContactProblem *new_GlobalFrictionContactProblem__SWIG_0(void){

      GlobalFrictionContactProblem *FC;
      // return pointer : free by std swig destructor
      FC = (GlobalFrictionContactProblem *) malloc(sizeof(GlobalFrictionContactProblem));

      globalFrictionContact_null(FC);

      return FC;
    }
SWIGINTERN struct GlobalFrictionContactProblem *new_GlobalFrictionContactProblem__SWIG_1(PyObject *dim){

      GlobalFrictionContactProblem *FC;
      // return pointer : free by std swig destructor
      FC = (GlobalFrictionContactProblem *) malloc(sizeof(GlobalFrictionContactProblem));

      globalFrictionContact_null(FC);
      SWIG_AsVal_int(dim, &FC->dimension);

      return FC;
    }
SWIGINTERN struct GlobalFrictionContactProblem *new_GlobalFrictionContactProblem__SWIG_2(PyObject *dim,PyObject *o1,PyObject *o2,PyObject *o3){

      int is_new_object1=0;
      int is_new_object2=0;
      int is_new_object3=0;

      PyArrayObject* array = obj_to_sn_array(o1, &is_new_object1);
      PyArrayObject* vector = obj_to_sn_vector(o2, &is_new_object2);
      PyArrayObject* mu_vector = obj_to_sn_vector(o3, &is_new_object3);
      GlobalFrictionContactProblem * FC = (GlobalFrictionContactProblem *) malloc(sizeof(GlobalFrictionContactProblem));
      globalFrictionContact_null(FC);

      size_t size0 = array_size((PyArrayObject*)array,0);
      size_t size1 = array_size((PyArrayObject*)array,1);
      FC->M = NM_create(NM_DENSE, size0, size1);

      memcpy(FC->M->matrix0,array_data(array),size0*size1*sizeof(double));
      SWIG_AsVal_int(dim, &FC->dimension);
      FC->numberOfContacts = size0 / FC->dimension;
      FC->q = (double *) malloc(size0*sizeof(double));
      memcpy(FC->q,array_data(vector),size0*sizeof(double));
      FC->mu = (double *) malloc(FC->numberOfContacts*sizeof(double));
      memcpy(FC->mu,array_data(mu_vector),FC->numberOfContacts*sizeof(double));

      // python mem management
      if(is_new_object1 && array) { Py_DECREF(array); }
      if(is_new_object2 && vector) { Py_DECREF(vector); }
      if(is_new_object3 && mu_vector) { Py_DECREF(mu_vector); }

      return FC;
    }
SWIGINTERN void delete_GlobalFrictionContactProblem(struct GlobalFrictionContactProblem *self){
    freeGlobalFrictionContactProblem(self);
  }

#include <GenericMechanical_cst.h>

#ifdef __cplusplus
extern "C" {
#endif
SWIGINTERN PyObject *_wrap_NM_clean_cs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CSparseMatrix *arg1 = (CSparseMatrix *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NM_clean_cs",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cs_dl_sparse, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NM_clean_cs" "', argument " "1"" of type '" "CSparseMatrix *""'"); 
  }
  arg1 = (CSparseMatrix *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NM_clean_cs" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_clean_cs(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_clean(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NM_clean",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NM_clean" "', argument " "1"" of type '" "NumericsMatrix *""'"); 
  }
  arg1 = (NumericsMatrix *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NM_clean" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)NM_clean(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_sane_pyseq_check(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:sane_pyseq_check",&obj0)) SWIG_fail;
  arg1 = obj0;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (bool)sane_pyseq_check(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_bool((bool)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap__sn_check_nnz(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  PyObject **arg1 = (PyObject **) 0 ;
  CSparseMatrix *arg2 = (CSparseMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:_sn_check_nnz",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_p_PyObject, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_sn_check_nnz" "', argument " "1"" of type '" "PyObject **""'"); 
  }
  arg1 = (PyObject **)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_cs_dl_sparse, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "_sn_check_nnz" "', argument " "2"" of type '" "CSparseMatrix *""'"); 
  }
  arg2 = (CSparseMatrix *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        _sn_check_nnz(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap__sn_check_shape(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  PyObject **arg1 = (PyObject **) 0 ;
  CSparseMatrix *arg2 = (CSparseMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:_sn_check_shape",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_p_PyObject, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_sn_check_shape" "', argument " "1"" of type '" "PyObject **""'"); 
  }
  arg1 = (PyObject **)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_cs_dl_sparse, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "_sn_check_shape" "', argument " "2"" of type '" "CSparseMatrix *""'"); 
  }
  arg2 = (CSparseMatrix *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        _sn_check_shape(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_is_Pyobject_scipy_sparse_matrix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:is_Pyobject_scipy_sparse_matrix",&obj0,&obj1)) SWIG_fail;
  arg1 = obj0;
  arg2 = obj1;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (bool)is_Pyobject_scipy_sparse_matrix(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_bool((bool)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_linearComplementarity_driver(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LinearComplementarityProblem *arg1 = (LinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  SolverOptions *arg4 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:linearComplementarity_driver",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "linearComplementarity_driver" "', argument " "1"" of type '" "LinearComplementarityProblem *""'"); 
  }
  arg1 = (LinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "linearComplementarity_driver" "', argument " "4"" of type '" "SolverOptions *""'"); 
  }
  arg4 = (SolverOptions *)(argp4);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)linearComplementarity_driver(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_mlcp_driver(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  SolverOptions *arg4 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:mlcp_driver",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mlcp_driver" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "mlcp_driver" "', argument " "4"" of type '" "SolverOptions *""'"); 
  }
  arg4 = (SolverOptions *)(argp4);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)mlcp_driver(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc2d_driver(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  SolverOptions *arg4 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:fc2d_driver",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc2d_driver" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "fc2d_driver" "', argument " "4"" of type '" "SolverOptions *""'"); 
  }
  arg4 = (SolverOptions *)(argp4);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc2d_driver(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_driver(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  SolverOptions *arg4 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:fc3d_driver",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_driver" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "fc3d_driver" "', argument " "4"" of type '" "SolverOptions *""'"); 
  }
  arg4 = (SolverOptions *)(argp4);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc3d_driver(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_gfc3d_driver(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  GlobalFrictionContactProblem *arg1 = (GlobalFrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  PyArrayObject *array4 = NULL ;
  int is_new_object4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:gfc3d_driver",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gfc3d_driver" "', argument " "1"" of type '" "GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (GlobalFrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  {
    array4 = obj_to_sn_vector(obj3, &is_new_object4);
    
    if (!array4)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array4))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg4 = (double *) array_data(array4);
    
  }
  res5 = SWIG_ConvertPtr(obj4, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "gfc3d_driver" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)gfc3d_driver(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_variationalInequality_driver(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  VariationalInequality *arg1 = (VariationalInequality *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  SolverOptions *arg4 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:variationalInequality_driver",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_VariationalInequality, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "variationalInequality_driver" "', argument " "1"" of type '" "VariationalInequality *""'"); 
  }
  arg1 = (VariationalInequality *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "variationalInequality_driver" "', argument " "4"" of type '" "SolverOptions *""'"); 
  }
  arg4 = (SolverOptions *)(argp4);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)variationalInequality_driver(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_avi_driver(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  AffineVariationalInequalities *arg1 = (AffineVariationalInequalities *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  SolverOptions *arg4 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:avi_driver",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AffineVariationalInequalities, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avi_driver" "', argument " "1"" of type '" "AffineVariationalInequalities *""'"); 
  }
  arg1 = (AffineVariationalInequalities *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "avi_driver" "', argument " "4"" of type '" "SolverOptions *""'"); 
  }
  arg4 = (SolverOptions *)(argp4);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)avi_driver(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_mcp_driver(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedComplementarityProblem *arg1 = (MixedComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  SolverOptions *arg4 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:mcp_driver",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mcp_driver" "', argument " "1"" of type '" "MixedComplementarityProblem *""'"); 
  }
  arg1 = (MixedComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "mcp_driver" "', argument " "4"" of type '" "SolverOptions *""'"); 
  }
  arg4 = (SolverOptions *)(argp4);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)mcp_driver(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_mcp_driver2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedComplementarityProblem2 *arg1 = (MixedComplementarityProblem2 *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  SolverOptions *arg4 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:mcp_driver2",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem2, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mcp_driver2" "', argument " "1"" of type '" "MixedComplementarityProblem2 *""'"); 
  }
  arg1 = (MixedComplementarityProblem2 *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "mcp_driver2" "', argument " "4"" of type '" "SolverOptions *""'"); 
  }
  arg4 = (SolverOptions *)(argp4);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)mcp_driver2(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_ncp_driver(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NonlinearComplementarityProblem *arg1 = (NonlinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  SolverOptions *arg4 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:ncp_driver",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NonlinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ncp_driver" "', argument " "1"" of type '" "NonlinearComplementarityProblem *""'"); 
  }
  arg1 = (NonlinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "ncp_driver" "', argument " "4"" of type '" "SolverOptions *""'"); 
  }
  arg4 = (SolverOptions *)(argp4);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)ncp_driver(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_soclcp_driver(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SecondOrderConeLinearComplementarityProblem *arg1 = (SecondOrderConeLinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  SolverOptions *arg4 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:soclcp_driver",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SecondOrderConeLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "soclcp_driver" "', argument " "1"" of type '" "SecondOrderConeLinearComplementarityProblem *""'"); 
  }
  arg1 = (SecondOrderConeLinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "soclcp_driver" "', argument " "3"" of type '" "double *""'"); 
  }
  arg3 = (double *)(argp3);
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "soclcp_driver" "', argument " "4"" of type '" "SolverOptions *""'"); 
  }
  arg4 = (SolverOptions *)(argp4);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)soclcp_driver(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_LmgcDriver(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  double *arg1 = (double *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  unsigned int *arg6 = (unsigned int *) 0 ;
  unsigned int *arg7 = (unsigned int *) 0 ;
  unsigned int arg8 ;
  unsigned int arg9 ;
  int arg10 ;
  double arg11 ;
  int arg12 ;
  int arg13 ;
  int arg14 ;
  int arg15 ;
  int arg16 ;
  PyArrayObject *array1 = NULL ;
  int is_new_object1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  PyArrayObject *array4 = NULL ;
  int is_new_object4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  unsigned int val8 ;
  int ecode8 = 0 ;
  unsigned int val9 ;
  int ecode9 = 0 ;
  int val10 ;
  int ecode10 = 0 ;
  double val11 ;
  int ecode11 = 0 ;
  int val12 ;
  int ecode12 = 0 ;
  int val13 ;
  int ecode13 = 0 ;
  int val14 ;
  int ecode14 = 0 ;
  int val15 ;
  int ecode15 = 0 ;
  int val16 ;
  int ecode16 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  PyObject * obj10 = 0 ;
  PyObject * obj11 = 0 ;
  PyObject * obj12 = 0 ;
  PyObject * obj13 = 0 ;
  PyObject * obj14 = 0 ;
  PyObject * obj15 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOOOOOOOOOO:fc3d_LmgcDriver",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10,&obj11,&obj12,&obj13,&obj14,&obj15)) SWIG_fail;
  {
    array1 = obj_to_sn_vector(obj0, &is_new_object1);
    
    if (!array1)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array1))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg1 = (double *) array_data(array1);
    
  }
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  {
    array4 = obj_to_sn_vector(obj3, &is_new_object4);
    
    if (!array4)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array4))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg4 = (double *) array_data(array4);
    
  }
  res5 = SWIG_ConvertPtr(obj4, &argp5,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc3d_LmgcDriver" "', argument " "5"" of type '" "double *""'"); 
  }
  arg5 = (double *)(argp5);
  res6 = SWIG_ConvertPtr(obj5, &argp6,SWIGTYPE_p_unsigned_int, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "fc3d_LmgcDriver" "', argument " "6"" of type '" "unsigned int *""'"); 
  }
  arg6 = (unsigned int *)(argp6);
  res7 = SWIG_ConvertPtr(obj6, &argp7,SWIGTYPE_p_unsigned_int, 0 |  0 );
  if (!SWIG_IsOK(res7)) {
    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "fc3d_LmgcDriver" "', argument " "7"" of type '" "unsigned int *""'"); 
  }
  arg7 = (unsigned int *)(argp7);
  ecode8 = SWIG_AsVal_unsigned_SS_int(obj7, &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "fc3d_LmgcDriver" "', argument " "8"" of type '" "unsigned int""'");
  } 
  arg8 = (unsigned int)(val8);
  ecode9 = SWIG_AsVal_unsigned_SS_int(obj8, &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "fc3d_LmgcDriver" "', argument " "9"" of type '" "unsigned int""'");
  } 
  arg9 = (unsigned int)(val9);
  ecode10 = SWIG_AsVal_int(obj9, &val10);
  if (!SWIG_IsOK(ecode10)) {
    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "fc3d_LmgcDriver" "', argument " "10"" of type '" "int""'");
  } 
  arg10 = (int)(val10);
  ecode11 = SWIG_AsVal_double(obj10, &val11);
  if (!SWIG_IsOK(ecode11)) {
    SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "fc3d_LmgcDriver" "', argument " "11"" of type '" "double""'");
  } 
  arg11 = (double)(val11);
  ecode12 = SWIG_AsVal_int(obj11, &val12);
  if (!SWIG_IsOK(ecode12)) {
    SWIG_exception_fail(SWIG_ArgError(ecode12), "in method '" "fc3d_LmgcDriver" "', argument " "12"" of type '" "int""'");
  } 
  arg12 = (int)(val12);
  ecode13 = SWIG_AsVal_int(obj12, &val13);
  if (!SWIG_IsOK(ecode13)) {
    SWIG_exception_fail(SWIG_ArgError(ecode13), "in method '" "fc3d_LmgcDriver" "', argument " "13"" of type '" "int""'");
  } 
  arg13 = (int)(val13);
  ecode14 = SWIG_AsVal_int(obj13, &val14);
  if (!SWIG_IsOK(ecode14)) {
    SWIG_exception_fail(SWIG_ArgError(ecode14), "in method '" "fc3d_LmgcDriver" "', argument " "14"" of type '" "int""'");
  } 
  arg14 = (int)(val14);
  ecode15 = SWIG_AsVal_int(obj14, &val15);
  if (!SWIG_IsOK(ecode15)) {
    SWIG_exception_fail(SWIG_ArgError(ecode15), "in method '" "fc3d_LmgcDriver" "', argument " "15"" of type '" "int""'");
  } 
  arg15 = (int)(val15);
  ecode16 = SWIG_AsVal_int(obj15, &val16);
  if (!SWIG_IsOK(ecode16)) {
    SWIG_exception_fail(SWIG_ArgError(ecode16), "in method '" "fc3d_LmgcDriver" "', argument " "16"" of type '" "int""'");
  } 
  arg16 = (int)(val16);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc3d_LmgcDriver(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15,arg16);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    if(is_new_object1 && array1) {
      Py_DECREF(array1); 
    };
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object1 && array1) {
      Py_DECREF(array1); 
    };
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_gfc3d_LmgcDriver(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  double *arg1 = (double *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  double *arg7 = (double *) 0 ;
  unsigned int arg8 ;
  unsigned int *arg9 = (unsigned int *) 0 ;
  unsigned int *arg10 = (unsigned int *) 0 ;
  double *arg11 = (double *) 0 ;
  unsigned int arg12 ;
  unsigned int *arg13 = (unsigned int *) 0 ;
  unsigned int *arg14 = (unsigned int *) 0 ;
  unsigned int arg15 ;
  unsigned int arg16 ;
  int arg17 ;
  int arg18 ;
  int *arg19 = (int *) 0 ;
  int arg20 ;
  double *arg21 = (double *) 0 ;
  int arg22 ;
  int arg23 ;
  int arg24 ;
  PyArrayObject *array1 = NULL ;
  int is_new_object1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  PyArrayObject *array4 = NULL ;
  int is_new_object4 = 0 ;
  PyArrayObject *array5 = NULL ;
  int is_new_object5 = 0 ;
  PyArrayObject *array6 = NULL ;
  int is_new_object6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  unsigned int val8 ;
  int ecode8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  void *argp10 = 0 ;
  int res10 = 0 ;
  void *argp11 = 0 ;
  int res11 = 0 ;
  unsigned int val12 ;
  int ecode12 = 0 ;
  void *argp13 = 0 ;
  int res13 = 0 ;
  void *argp14 = 0 ;
  int res14 = 0 ;
  unsigned int val15 ;
  int ecode15 = 0 ;
  unsigned int val16 ;
  int ecode16 = 0 ;
  int val17 ;
  int ecode17 = 0 ;
  int val18 ;
  int ecode18 = 0 ;
  void *argp19 = 0 ;
  int res19 = 0 ;
  int val20 ;
  int ecode20 = 0 ;
  void *argp21 = 0 ;
  int res21 = 0 ;
  int val22 ;
  int ecode22 = 0 ;
  int val23 ;
  int ecode23 = 0 ;
  int val24 ;
  int ecode24 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  PyObject * obj10 = 0 ;
  PyObject * obj11 = 0 ;
  PyObject * obj12 = 0 ;
  PyObject * obj13 = 0 ;
  PyObject * obj14 = 0 ;
  PyObject * obj15 = 0 ;
  PyObject * obj16 = 0 ;
  PyObject * obj17 = 0 ;
  PyObject * obj18 = 0 ;
  PyObject * obj19 = 0 ;
  PyObject * obj20 = 0 ;
  PyObject * obj21 = 0 ;
  PyObject * obj22 = 0 ;
  PyObject * obj23 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOOOOOOOOOOOOOOOOOO:gfc3d_LmgcDriver",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10,&obj11,&obj12,&obj13,&obj14,&obj15,&obj16,&obj17,&obj18,&obj19,&obj20,&obj21,&obj22,&obj23)) SWIG_fail;
  {
    array1 = obj_to_sn_vector(obj0, &is_new_object1);
    
    if (!array1)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array1))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg1 = (double *) array_data(array1);
    
  }
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  {
    array4 = obj_to_sn_vector(obj3, &is_new_object4);
    
    if (!array4)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array4))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg4 = (double *) array_data(array4);
    
  }
  {
    array5 = obj_to_sn_vector(obj4, &is_new_object5);
    
    if (!array5)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array5))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg5 = (double *) array_data(array5);
    
  }
  {
    array6 = obj_to_sn_vector(obj5, &is_new_object6);
    
    if (!array6)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array6))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg6 = (double *) array_data(array6);
    
  }
  res7 = SWIG_ConvertPtr(obj6, &argp7,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res7)) {
    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "gfc3d_LmgcDriver" "', argument " "7"" of type '" "double *""'"); 
  }
  arg7 = (double *)(argp7);
  ecode8 = SWIG_AsVal_unsigned_SS_int(obj7, &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "gfc3d_LmgcDriver" "', argument " "8"" of type '" "unsigned int""'");
  } 
  arg8 = (unsigned int)(val8);
  res9 = SWIG_ConvertPtr(obj8, &argp9,SWIGTYPE_p_unsigned_int, 0 |  0 );
  if (!SWIG_IsOK(res9)) {
    SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "gfc3d_LmgcDriver" "', argument " "9"" of type '" "unsigned int *""'"); 
  }
  arg9 = (unsigned int *)(argp9);
  res10 = SWIG_ConvertPtr(obj9, &argp10,SWIGTYPE_p_unsigned_int, 0 |  0 );
  if (!SWIG_IsOK(res10)) {
    SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "gfc3d_LmgcDriver" "', argument " "10"" of type '" "unsigned int *""'"); 
  }
  arg10 = (unsigned int *)(argp10);
  res11 = SWIG_ConvertPtr(obj10, &argp11,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res11)) {
    SWIG_exception_fail(SWIG_ArgError(res11), "in method '" "gfc3d_LmgcDriver" "', argument " "11"" of type '" "double *""'"); 
  }
  arg11 = (double *)(argp11);
  ecode12 = SWIG_AsVal_unsigned_SS_int(obj11, &val12);
  if (!SWIG_IsOK(ecode12)) {
    SWIG_exception_fail(SWIG_ArgError(ecode12), "in method '" "gfc3d_LmgcDriver" "', argument " "12"" of type '" "unsigned int""'");
  } 
  arg12 = (unsigned int)(val12);
  res13 = SWIG_ConvertPtr(obj12, &argp13,SWIGTYPE_p_unsigned_int, 0 |  0 );
  if (!SWIG_IsOK(res13)) {
    SWIG_exception_fail(SWIG_ArgError(res13), "in method '" "gfc3d_LmgcDriver" "', argument " "13"" of type '" "unsigned int *""'"); 
  }
  arg13 = (unsigned int *)(argp13);
  res14 = SWIG_ConvertPtr(obj13, &argp14,SWIGTYPE_p_unsigned_int, 0 |  0 );
  if (!SWIG_IsOK(res14)) {
    SWIG_exception_fail(SWIG_ArgError(res14), "in method '" "gfc3d_LmgcDriver" "', argument " "14"" of type '" "unsigned int *""'"); 
  }
  arg14 = (unsigned int *)(argp14);
  ecode15 = SWIG_AsVal_unsigned_SS_int(obj14, &val15);
  if (!SWIG_IsOK(ecode15)) {
    SWIG_exception_fail(SWIG_ArgError(ecode15), "in method '" "gfc3d_LmgcDriver" "', argument " "15"" of type '" "unsigned int""'");
  } 
  arg15 = (unsigned int)(val15);
  ecode16 = SWIG_AsVal_unsigned_SS_int(obj15, &val16);
  if (!SWIG_IsOK(ecode16)) {
    SWIG_exception_fail(SWIG_ArgError(ecode16), "in method '" "gfc3d_LmgcDriver" "', argument " "16"" of type '" "unsigned int""'");
  } 
  arg16 = (unsigned int)(val16);
  ecode17 = SWIG_AsVal_int(obj16, &val17);
  if (!SWIG_IsOK(ecode17)) {
    SWIG_exception_fail(SWIG_ArgError(ecode17), "in method '" "gfc3d_LmgcDriver" "', argument " "17"" of type '" "int""'");
  } 
  arg17 = (int)(val17);
  ecode18 = SWIG_AsVal_int(obj17, &val18);
  if (!SWIG_IsOK(ecode18)) {
    SWIG_exception_fail(SWIG_ArgError(ecode18), "in method '" "gfc3d_LmgcDriver" "', argument " "18"" of type '" "int""'");
  } 
  arg18 = (int)(val18);
  res19 = SWIG_ConvertPtr(obj18, &argp19,SWIGTYPE_p_int, 0 |  0 );
  if (!SWIG_IsOK(res19)) {
    SWIG_exception_fail(SWIG_ArgError(res19), "in method '" "gfc3d_LmgcDriver" "', argument " "19"" of type '" "int *""'"); 
  }
  arg19 = (int *)(argp19);
  ecode20 = SWIG_AsVal_int(obj19, &val20);
  if (!SWIG_IsOK(ecode20)) {
    SWIG_exception_fail(SWIG_ArgError(ecode20), "in method '" "gfc3d_LmgcDriver" "', argument " "20"" of type '" "int""'");
  } 
  arg20 = (int)(val20);
  res21 = SWIG_ConvertPtr(obj20, &argp21,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res21)) {
    SWIG_exception_fail(SWIG_ArgError(res21), "in method '" "gfc3d_LmgcDriver" "', argument " "21"" of type '" "double *""'"); 
  }
  arg21 = (double *)(argp21);
  ecode22 = SWIG_AsVal_int(obj21, &val22);
  if (!SWIG_IsOK(ecode22)) {
    SWIG_exception_fail(SWIG_ArgError(ecode22), "in method '" "gfc3d_LmgcDriver" "', argument " "22"" of type '" "int""'");
  } 
  arg22 = (int)(val22);
  ecode23 = SWIG_AsVal_int(obj22, &val23);
  if (!SWIG_IsOK(ecode23)) {
    SWIG_exception_fail(SWIG_ArgError(ecode23), "in method '" "gfc3d_LmgcDriver" "', argument " "23"" of type '" "int""'");
  } 
  arg23 = (int)(val23);
  ecode24 = SWIG_AsVal_int(obj23, &val24);
  if (!SWIG_IsOK(ecode24)) {
    SWIG_exception_fail(SWIG_ArgError(ecode24), "in method '" "gfc3d_LmgcDriver" "', argument " "24"" of type '" "int""'");
  } 
  arg24 = (int)(val24);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)gfc3d_LmgcDriver(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15,arg16,arg17,arg18,arg19,arg20,arg21,arg22,arg23,arg24);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    if(is_new_object1 && array1) {
      Py_DECREF(array1); 
    };
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  {
    if(is_new_object5 && array5) {
      Py_DECREF(array5); 
    };
  }
  {
    if(is_new_object6 && array6) {
      Py_DECREF(array6); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object1 && array1) {
      Py_DECREF(array1); 
    };
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  {
    if(is_new_object5 && array5) {
      Py_DECREF(array5); 
    };
  }
  {
    if(is_new_object6 && array6) {
      Py_DECREF(array6); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_relay_driver(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  RelayProblem *arg1 = (RelayProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  SolverOptions *arg4 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:relay_driver",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_RelayProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "relay_driver" "', argument " "1"" of type '" "RelayProblem *""'"); 
  }
  arg1 = (RelayProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "relay_driver" "', argument " "4"" of type '" "SolverOptions *""'"); 
  }
  arg4 = (SolverOptions *)(argp4);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)relay_driver(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_Callback_env_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Callback *arg1 = (Callback *) 0 ;
  void *arg2 = (void *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Callback_env_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Callback, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Callback_env_set" "', argument " "1"" of type '" "Callback *""'"); 
  }
  arg1 = (Callback *)(argp1);
  res2 = SWIG_ConvertPtr(obj1,SWIG_as_voidptrptr(&arg2), 0, SWIG_POINTER_DISOWN);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Callback_env_set" "', argument " "2"" of type '" "void *""'"); 
  }
  if (arg1) (arg1)->env = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Callback_env_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Callback *arg1 = (Callback *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  void *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Callback_env_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Callback, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Callback_env_get" "', argument " "1"" of type '" "Callback *""'"); 
  }
  arg1 = (Callback *)(argp1);
  result = (void *) ((arg1)->env);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Callback_collectStatsIteration_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Callback *arg1 = (Callback *) 0 ;
  void (*arg2)(void *,int,double *,double *,double,void *) = (void (*)(void *,int,double *,double *,double,void *)) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Callback_collectStatsIteration_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Callback, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Callback_collectStatsIteration_set" "', argument " "1"" of type '" "Callback *""'"); 
  }
  arg1 = (Callback *)(argp1);
  {
    int res = SWIG_ConvertFunctionPtr(obj1, (void**)(&arg2), SWIGTYPE_p_f_p_void_int_p_double_p_double_double_p_void__void);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "Callback_collectStatsIteration_set" "', argument " "2"" of type '" "void (*)(void *,int,double *,double *,double,void *)""'"); 
    }
  }
  if (arg1) (arg1)->collectStatsIteration = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Callback_collectStatsIteration_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Callback *arg1 = (Callback *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  void (*result)(void *,int,double *,double *,double,void *) = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Callback_collectStatsIteration_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Callback, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Callback_collectStatsIteration_get" "', argument " "1"" of type '" "Callback *""'"); 
  }
  arg1 = (Callback *)(argp1);
  result = (void (*)(void *,int,double *,double *,double,void *)) ((arg1)->collectStatsIteration);
  resultobj = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_void_int_p_double_p_double_double_p_void__void);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Callback(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Callback *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_Callback")) SWIG_fail;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (Callback *)calloc(1, sizeof(Callback));
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Callback, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Callback(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Callback *arg1 = (Callback *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_Callback",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Callback, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Callback" "', argument " "1"" of type '" "Callback *""'"); 
  }
  arg1 = (Callback *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        free((char *) arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Callback_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_Callback, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_SolverOptions_solverId_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SolverOptions *arg1 = (struct SolverOptions *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SolverOptions_solverId_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolverOptions_solverId_set" "', argument " "1"" of type '" "struct SolverOptions *""'"); 
  }
  arg1 = (struct SolverOptions *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SolverOptions_solverId_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->solverId = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SolverOptions_solverId_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SolverOptions *arg1 = (struct SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SolverOptions_solverId_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolverOptions_solverId_get" "', argument " "1"" of type '" "struct SolverOptions *""'"); 
  }
  arg1 = (struct SolverOptions *)(argp1);
  result = (int) ((arg1)->solverId);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SolverOptions_isSet_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SolverOptions *arg1 = (struct SolverOptions *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SolverOptions_isSet_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolverOptions_isSet_set" "', argument " "1"" of type '" "struct SolverOptions *""'"); 
  }
  arg1 = (struct SolverOptions *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SolverOptions_isSet_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->isSet = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SolverOptions_isSet_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SolverOptions *arg1 = (struct SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SolverOptions_isSet_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolverOptions_isSet_get" "', argument " "1"" of type '" "struct SolverOptions *""'"); 
  }
  arg1 = (struct SolverOptions *)(argp1);
  result = (int) ((arg1)->isSet);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SolverOptions_iSize_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SolverOptions *arg1 = (struct SolverOptions *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SolverOptions_iSize_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolverOptions_iSize_set" "', argument " "1"" of type '" "struct SolverOptions *""'"); 
  }
  arg1 = (struct SolverOptions *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SolverOptions_iSize_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->iSize = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SolverOptions_iSize_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SolverOptions *arg1 = (struct SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SolverOptions_iSize_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolverOptions_iSize_get" "', argument " "1"" of type '" "struct SolverOptions *""'"); 
  }
  arg1 = (struct SolverOptions *)(argp1);
  result = (int) ((arg1)->iSize);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SolverOptions_iparam_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SolverOptions *arg1 = (struct SolverOptions *) 0 ;
  int *arg2 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SolverOptions_iparam_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolverOptions_iparam_set" "', argument " "1"" of type '" "struct SolverOptions *""'"); 
  }
  arg1 = (struct SolverOptions *)(argp1);
  {
    int * temp;
    temp = (int *) malloc(sizeof(int)*PyObject_Length(obj1));
    if (!convert_iarray(obj1,temp)) {
      SWIG_fail;
    }
    
    if (arg2) {
      free(arg2); 
    };
    
    arg2 = &temp[0];
    
    // arg1 is *SolverOptions. May be version dependent, how to get
    // this?
    if (arg1) arg1->iSize = PyObject_Length(obj1);
    
  }
  if (arg1) (arg1)->iparam = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SolverOptions_iparam_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SolverOptions *arg1 = (struct SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SolverOptions_iparam_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolverOptions_iparam_get" "', argument " "1"" of type '" "struct SolverOptions *""'"); 
  }
  arg1 = (struct SolverOptions *)(argp1);
  result = (int *) ((arg1)->iparam);
  {
    C_to_target_lang1_int(resultobj, arg1->iSize, result, SWIG_fail);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SolverOptions_dSize_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SolverOptions *arg1 = (struct SolverOptions *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SolverOptions_dSize_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolverOptions_dSize_set" "', argument " "1"" of type '" "struct SolverOptions *""'"); 
  }
  arg1 = (struct SolverOptions *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SolverOptions_dSize_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->dSize = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SolverOptions_dSize_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SolverOptions *arg1 = (struct SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SolverOptions_dSize_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolverOptions_dSize_get" "', argument " "1"" of type '" "struct SolverOptions *""'"); 
  }
  arg1 = (struct SolverOptions *)(argp1);
  result = (int) ((arg1)->dSize);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SolverOptions_dparam_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SolverOptions *arg1 = (struct SolverOptions *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SolverOptions_dparam_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolverOptions_dparam_set" "', argument " "1"" of type '" "struct SolverOptions *""'"); 
  }
  arg1 = (struct SolverOptions *)(argp1);
  {
    double * temp;
    temp = (double *) malloc(sizeof(double)*PyObject_Length(obj1));
    if (!convert_darray(obj1,temp)) {
      SWIG_fail;
    }
    
    if (arg2) {
      free(arg2); 
    };
    
    arg2 = &temp[0];
    
    // arg1 is *SolverOptions. May be version dependent, how to get
    // this?
    if (arg1) arg1->dSize = PyObject_Length(obj1);
    
  }
  if (arg1) (arg1)->dparam = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SolverOptions_dparam_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SolverOptions *arg1 = (struct SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SolverOptions_dparam_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolverOptions_dparam_get" "', argument " "1"" of type '" "struct SolverOptions *""'"); 
  }
  arg1 = (struct SolverOptions *)(argp1);
  result = (double *) ((arg1)->dparam);
  {
    C_to_target_lang1(resultobj, arg1->dSize, result, SWIG_fail);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SolverOptions_filterOn_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SolverOptions *arg1 = (struct SolverOptions *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SolverOptions_filterOn_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolverOptions_filterOn_set" "', argument " "1"" of type '" "struct SolverOptions *""'"); 
  }
  arg1 = (struct SolverOptions *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SolverOptions_filterOn_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->filterOn = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SolverOptions_filterOn_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SolverOptions *arg1 = (struct SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SolverOptions_filterOn_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolverOptions_filterOn_get" "', argument " "1"" of type '" "struct SolverOptions *""'"); 
  }
  arg1 = (struct SolverOptions *)(argp1);
  result = (int) ((arg1)->filterOn);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SolverOptions_dWorkSize_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SolverOptions *arg1 = (struct SolverOptions *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SolverOptions_dWorkSize_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolverOptions_dWorkSize_set" "', argument " "1"" of type '" "struct SolverOptions *""'"); 
  }
  arg1 = (struct SolverOptions *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SolverOptions_dWorkSize_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->dWorkSize = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SolverOptions_dWorkSize_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SolverOptions *arg1 = (struct SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SolverOptions_dWorkSize_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolverOptions_dWorkSize_get" "', argument " "1"" of type '" "struct SolverOptions *""'"); 
  }
  arg1 = (struct SolverOptions *)(argp1);
  result = (int) ((arg1)->dWorkSize);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SolverOptions_dWork_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SolverOptions *arg1 = (struct SolverOptions *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SolverOptions_dWork_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolverOptions_dWork_set" "', argument " "1"" of type '" "struct SolverOptions *""'"); 
  }
  arg1 = (struct SolverOptions *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_double, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SolverOptions_dWork_set" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = (double *)(argp2);
  if (arg1) (arg1)->dWork = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SolverOptions_dWork_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SolverOptions *arg1 = (struct SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SolverOptions_dWork_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolverOptions_dWork_get" "', argument " "1"" of type '" "struct SolverOptions *""'"); 
  }
  arg1 = (struct SolverOptions *)(argp1);
  result = (double *) ((arg1)->dWork);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SolverOptions_iWorkSize_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SolverOptions *arg1 = (struct SolverOptions *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SolverOptions_iWorkSize_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolverOptions_iWorkSize_set" "', argument " "1"" of type '" "struct SolverOptions *""'"); 
  }
  arg1 = (struct SolverOptions *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SolverOptions_iWorkSize_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->iWorkSize = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SolverOptions_iWorkSize_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SolverOptions *arg1 = (struct SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SolverOptions_iWorkSize_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolverOptions_iWorkSize_get" "', argument " "1"" of type '" "struct SolverOptions *""'"); 
  }
  arg1 = (struct SolverOptions *)(argp1);
  result = (int) ((arg1)->iWorkSize);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SolverOptions_iWork_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SolverOptions *arg1 = (struct SolverOptions *) 0 ;
  int *arg2 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SolverOptions_iWork_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolverOptions_iWork_set" "', argument " "1"" of type '" "struct SolverOptions *""'"); 
  }
  arg1 = (struct SolverOptions *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_int, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SolverOptions_iWork_set" "', argument " "2"" of type '" "int *""'"); 
  }
  arg2 = (int *)(argp2);
  if (arg1) (arg1)->iWork = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SolverOptions_iWork_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SolverOptions *arg1 = (struct SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SolverOptions_iWork_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolverOptions_iWork_get" "', argument " "1"" of type '" "struct SolverOptions *""'"); 
  }
  arg1 = (struct SolverOptions *)(argp1);
  result = (int *) ((arg1)->iWork);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_int, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SolverOptions_numberOfInternalSolvers_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SolverOptions *arg1 = (struct SolverOptions *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SolverOptions_numberOfInternalSolvers_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolverOptions_numberOfInternalSolvers_set" "', argument " "1"" of type '" "struct SolverOptions *""'"); 
  }
  arg1 = (struct SolverOptions *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SolverOptions_numberOfInternalSolvers_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->numberOfInternalSolvers = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SolverOptions_numberOfInternalSolvers_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SolverOptions *arg1 = (struct SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SolverOptions_numberOfInternalSolvers_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolverOptions_numberOfInternalSolvers_get" "', argument " "1"" of type '" "struct SolverOptions *""'"); 
  }
  arg1 = (struct SolverOptions *)(argp1);
  result = (int) ((arg1)->numberOfInternalSolvers);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SolverOptions_internalSolvers_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SolverOptions *arg1 = (struct SolverOptions *) 0 ;
  struct SolverOptions *arg2 = (struct SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SolverOptions_internalSolvers_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolverOptions_internalSolvers_set" "', argument " "1"" of type '" "struct SolverOptions *""'"); 
  }
  arg1 = (struct SolverOptions *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SolverOptions_internalSolvers_set" "', argument " "2"" of type '" "struct SolverOptions *""'"); 
  }
  arg2 = (struct SolverOptions *)(argp2);
  if (arg1) (arg1)->internalSolvers = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SolverOptions_internalSolvers_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SolverOptions *arg1 = (struct SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  struct SolverOptions *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SolverOptions_internalSolvers_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolverOptions_internalSolvers_get" "', argument " "1"" of type '" "struct SolverOptions *""'"); 
  }
  arg1 = (struct SolverOptions *)(argp1);
  result = (struct SolverOptions *) ((arg1)->internalSolvers);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SolverOptions, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SolverOptions_callback_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SolverOptions *arg1 = (struct SolverOptions *) 0 ;
  Callback *arg2 = (Callback *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Callback *pycallback2 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SolverOptions_callback_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolverOptions_callback_set" "', argument " "1"" of type '" "struct SolverOptions *""'"); 
  }
  arg1 = (struct SolverOptions *)(argp1);
  {
    // %typemap(in) (Callback* callback) (Callback* pycallback2)
    if ((arg1)->callback)
    {
      free(arg1->callback);
    }
    pycallback2 = (Callback*) malloc(sizeof(Callback)); // free in solver_options_delete
    pycallback2->env = obj1;
    pycallback2->collectStatsIteration = &collectStatsIterationCallback;
    
    arg2 = pycallback2;
    
  }
  if (arg1) (arg1)->callback = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SolverOptions_callback_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SolverOptions *arg1 = (struct SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Callback *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SolverOptions_callback_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolverOptions_callback_get" "', argument " "1"" of type '" "struct SolverOptions *""'"); 
  }
  arg1 = (struct SolverOptions *)(argp1);
  result = (Callback *) ((arg1)->callback);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Callback, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SolverOptions_solverParameters_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SolverOptions *arg1 = (struct SolverOptions *) 0 ;
  void *arg2 = (void *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SolverOptions_solverParameters_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolverOptions_solverParameters_set" "', argument " "1"" of type '" "struct SolverOptions *""'"); 
  }
  arg1 = (struct SolverOptions *)(argp1);
  res2 = SWIG_ConvertPtr(obj1,SWIG_as_voidptrptr(&arg2), 0, SWIG_POINTER_DISOWN);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SolverOptions_solverParameters_set" "', argument " "2"" of type '" "void *""'"); 
  }
  if (arg1) (arg1)->solverParameters = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SolverOptions_solverParameters_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SolverOptions *arg1 = (struct SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  void *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SolverOptions_solverParameters_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolverOptions_solverParameters_get" "', argument " "1"" of type '" "struct SolverOptions *""'"); 
  }
  arg1 = (struct SolverOptions *)(argp1);
  result = (void *) ((arg1)->solverParameters);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SolverOptions_solverData_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SolverOptions *arg1 = (struct SolverOptions *) 0 ;
  void *arg2 = (void *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SolverOptions_solverData_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolverOptions_solverData_set" "', argument " "1"" of type '" "struct SolverOptions *""'"); 
  }
  arg1 = (struct SolverOptions *)(argp1);
  res2 = SWIG_ConvertPtr(obj1,SWIG_as_voidptrptr(&arg2), 0, SWIG_POINTER_DISOWN);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SolverOptions_solverData_set" "', argument " "2"" of type '" "void *""'"); 
  }
  if (arg1) (arg1)->solverData = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SolverOptions_solverData_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SolverOptions *arg1 = (struct SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  void *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SolverOptions_solverData_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolverOptions_solverData_get" "', argument " "1"" of type '" "struct SolverOptions *""'"); 
  }
  arg1 = (struct SolverOptions *)(argp1);
  result = (void *) ((arg1)->solverData);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SolverOptions__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  enum FRICTION_SOLVER arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  struct SolverOptions *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_SolverOptions",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_SolverOptions" "', argument " "1"" of type '" "enum FRICTION_SOLVER""'");
  } 
  arg1 = (enum FRICTION_SOLVER)(val1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct SolverOptions *)new_SolverOptions__SWIG_0(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SolverOptions, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SolverOptions__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SecondOrderConeLinearComplementarityProblem *arg1 = (SecondOrderConeLinearComplementarityProblem *) 0 ;
  enum SOCLCP_SOLVER arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  struct SolverOptions *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_SolverOptions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SecondOrderConeLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SolverOptions" "', argument " "1"" of type '" "SecondOrderConeLinearComplementarityProblem *""'"); 
  }
  arg1 = (SecondOrderConeLinearComplementarityProblem *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_SolverOptions" "', argument " "2"" of type '" "enum SOCLCP_SOLVER""'");
  } 
  arg2 = (enum SOCLCP_SOLVER)(val2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct SolverOptions *)new_SolverOptions__SWIG_1(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SolverOptions, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SolverOptions__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SolverOptions *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_SolverOptions")) SWIG_fail;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct SolverOptions *)new_SolverOptions__SWIG_2();
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SolverOptions, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SolverOptions__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LinearComplementarityProblem *arg1 = (LinearComplementarityProblem *) 0 ;
  enum LCP_SOLVER arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  struct SolverOptions *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_SolverOptions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SolverOptions" "', argument " "1"" of type '" "LinearComplementarityProblem *""'"); 
  }
  arg1 = (LinearComplementarityProblem *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_SolverOptions" "', argument " "2"" of type '" "enum LCP_SOLVER""'");
  } 
  arg2 = (enum LCP_SOLVER)(val2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct SolverOptions *)new_SolverOptions__SWIG_3(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SolverOptions, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SolverOptions__SWIG_4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  enum MLCP_SOLVER arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  struct SolverOptions *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_SolverOptions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SolverOptions" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_SolverOptions" "', argument " "2"" of type '" "enum MLCP_SOLVER""'");
  } 
  arg2 = (enum MLCP_SOLVER)(val2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct SolverOptions *)new_SolverOptions__SWIG_4(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SolverOptions, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SolverOptions__SWIG_5(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedComplementarityProblem *arg1 = (MixedComplementarityProblem *) 0 ;
  enum MCP_SOLVER arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  struct SolverOptions *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_SolverOptions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SolverOptions" "', argument " "1"" of type '" "MixedComplementarityProblem *""'"); 
  }
  arg1 = (MixedComplementarityProblem *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_SolverOptions" "', argument " "2"" of type '" "enum MCP_SOLVER""'");
  } 
  arg2 = (enum MCP_SOLVER)(val2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct SolverOptions *)new_SolverOptions__SWIG_5(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SolverOptions, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SolverOptions__SWIG_6(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedComplementarityProblem2 *arg1 = (MixedComplementarityProblem2 *) 0 ;
  enum MCP_SOLVER arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  struct SolverOptions *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_SolverOptions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem2, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SolverOptions" "', argument " "1"" of type '" "MixedComplementarityProblem2 *""'"); 
  }
  arg1 = (MixedComplementarityProblem2 *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_SolverOptions" "', argument " "2"" of type '" "enum MCP_SOLVER""'");
  } 
  arg2 = (enum MCP_SOLVER)(val2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct SolverOptions *)new_SolverOptions__SWIG_6(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SolverOptions, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SolverOptions__SWIG_7(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NonlinearComplementarityProblem *arg1 = (NonlinearComplementarityProblem *) 0 ;
  enum NCP_SOLVER arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  struct SolverOptions *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_SolverOptions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NonlinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SolverOptions" "', argument " "1"" of type '" "NonlinearComplementarityProblem *""'"); 
  }
  arg1 = (NonlinearComplementarityProblem *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_SolverOptions" "', argument " "2"" of type '" "enum NCP_SOLVER""'");
  } 
  arg2 = (enum NCP_SOLVER)(val2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct SolverOptions *)new_SolverOptions__SWIG_7(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SolverOptions, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SolverOptions__SWIG_8(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  VariationalInequality *arg1 = (VariationalInequality *) 0 ;
  enum VI_SOLVER arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  struct SolverOptions *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_SolverOptions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_VariationalInequality, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SolverOptions" "', argument " "1"" of type '" "VariationalInequality *""'"); 
  }
  arg1 = (VariationalInequality *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_SolverOptions" "', argument " "2"" of type '" "enum VI_SOLVER""'");
  } 
  arg2 = (enum VI_SOLVER)(val2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct SolverOptions *)new_SolverOptions__SWIG_8(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SolverOptions, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SolverOptions__SWIG_9(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  AffineVariationalInequalities *arg1 = (AffineVariationalInequalities *) 0 ;
  enum AVI_SOLVER arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  struct SolverOptions *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_SolverOptions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AffineVariationalInequalities, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SolverOptions" "', argument " "1"" of type '" "AffineVariationalInequalities *""'"); 
  }
  arg1 = (AffineVariationalInequalities *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_SolverOptions" "', argument " "2"" of type '" "enum AVI_SOLVER""'");
  } 
  arg2 = (enum AVI_SOLVER)(val2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct SolverOptions *)new_SolverOptions__SWIG_9(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SolverOptions, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SolverOptions(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  Py_ssize_t ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = args ? PyObject_Length(args) : 0;
  for (ii = 0; (ii < 2) && (ii < argc); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_SolverOptions__SWIG_2(self, args);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_SolverOptions__SWIG_0(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SecondOrderConeLinearComplementarityProblem, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_SolverOptions__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_LinearComplementarityProblem, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_SolverOptions__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_MixedLinearComplementarityProblem, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_SolverOptions__SWIG_4(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_MixedComplementarityProblem, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_SolverOptions__SWIG_5(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_MixedComplementarityProblem2, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_SolverOptions__SWIG_6(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_NonlinearComplementarityProblem, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_SolverOptions__SWIG_7(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_VariationalInequality, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_SolverOptions__SWIG_8(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_AffineVariationalInequalities, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_SolverOptions__SWIG_9(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_SolverOptions'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    SolverOptions::SolverOptions(enum FRICTION_SOLVER)\n"
    "    SolverOptions::SolverOptions(SecondOrderConeLinearComplementarityProblem *,enum SOCLCP_SOLVER)\n"
    "    SolverOptions::SolverOptions()\n"
    "    SolverOptions::SolverOptions(LinearComplementarityProblem *,enum LCP_SOLVER)\n"
    "    SolverOptions::SolverOptions(MixedLinearComplementarityProblem *,enum MLCP_SOLVER)\n"
    "    SolverOptions::SolverOptions(MixedComplementarityProblem *,enum MCP_SOLVER)\n"
    "    SolverOptions::SolverOptions(MixedComplementarityProblem2 *,enum MCP_SOLVER)\n"
    "    SolverOptions::SolverOptions(NonlinearComplementarityProblem *,enum NCP_SOLVER)\n"
    "    SolverOptions::SolverOptions(VariationalInequality *,enum VI_SOLVER)\n"
    "    SolverOptions::SolverOptions(AffineVariationalInequalities *,enum AVI_SOLVER)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_SolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SolverOptions *arg1 = (struct SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_SolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SolverOptions" "', argument " "1"" of type '" "struct SolverOptions *""'"); 
  }
  arg1 = (struct SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        delete_SolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SolverOptions_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_SolverOptions, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN int Swig_var_SICONOS_NUMERICS_PROBLEM_LCP_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_NUMERICS_PROBLEM_LCP_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_NUMERICS_PROBLEM_LCP_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_NUMERICS_PROBLEM_LCP_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_NUMERICS_PROBLEM_MLCP_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_NUMERICS_PROBLEM_MLCP_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_NUMERICS_PROBLEM_MLCP_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_NUMERICS_PROBLEM_MLCP_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_NUMERICS_PROBLEM_NCP_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_NUMERICS_PROBLEM_NCP_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_NUMERICS_PROBLEM_NCP_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_NUMERICS_PROBLEM_NCP_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_NUMERICS_PROBLEM_MCP_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_NUMERICS_PROBLEM_MCP_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_NUMERICS_PROBLEM_MCP_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_NUMERICS_PROBLEM_MCP_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_NUMERICS_PROBLEM_EQUALITY_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_NUMERICS_PROBLEM_EQUALITY_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_NUMERICS_PROBLEM_EQUALITY_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_NUMERICS_PROBLEM_EQUALITY_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_NUMERICS_PROBLEM_FC2D_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_NUMERICS_PROBLEM_FC2D_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_NUMERICS_PROBLEM_FC2D_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_NUMERICS_PROBLEM_FC2D_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_NUMERICS_PROBLEM_FC3D_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_NUMERICS_PROBLEM_FC3D_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_NUMERICS_PROBLEM_FC3D_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_NUMERICS_PROBLEM_FC3D_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_NUMERICS_PROBLEM_VI_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_NUMERICS_PROBLEM_VI_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_NUMERICS_PROBLEM_VI_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_NUMERICS_PROBLEM_VI_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_NUMERICS_PROBLEM_AVI_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_NUMERICS_PROBLEM_AVI_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_NUMERICS_PROBLEM_AVI_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_NUMERICS_PROBLEM_AVI_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_NUMERICS_PROBLEM_RELAY_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_NUMERICS_PROBLEM_RELAY_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_NUMERICS_PROBLEM_RELAY_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_NUMERICS_PROBLEM_RELAY_STR);
  return pyobj;
}


SWIGINTERN PyObject *_wrap_solver_options_print(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:solver_options_print",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "solver_options_print" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        solver_options_print(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_solver_options_delete(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:solver_options_delete",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "solver_options_delete" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        solver_options_delete(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_solver_options_nullify(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:solver_options_nullify",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "solver_options_nullify" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        solver_options_nullify(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_solver_options_fill(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  double arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOO:solver_options_fill",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "solver_options_fill" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "solver_options_fill" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "solver_options_fill" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "solver_options_fill" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  ecode5 = SWIG_AsVal_int(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "solver_options_fill" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  ecode6 = SWIG_AsVal_double(obj5, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "solver_options_fill" "', argument " "6"" of type '" "double""'");
  } 
  arg6 = (double)(val6);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        solver_options_fill(arg1,arg2,arg3,arg4,arg5,arg6);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_solver_options_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:solver_options_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "solver_options_set" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "solver_options_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        solver_options_set(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_solver_options_name_to_id(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:solver_options_name_to_id",&obj0)) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "solver_options_name_to_id" "', argument " "1"" of type '" "char *""'");
  }
  arg1 = (char *)(buf1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)solver_options_name_to_id(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
  return resultobj;
fail:
  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
  return NULL;
}


SWIGINTERN PyObject *_wrap_solver_options_id_to_name(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:solver_options_id_to_name",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "solver_options_id_to_name" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (char *)solver_options_id_to_name(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ns_problem_id_to_name(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ns_problem_id_to_name",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "ns_problem_id_to_name" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (char *)ns_problem_id_to_name(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_solver_options_free_solver_specific_data(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:solver_options_free_solver_specific_data",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "solver_options_free_solver_specific_data" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        solver_options_free_solver_specific_data(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_solver_options_copy(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:solver_options_copy",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "solver_options_copy" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "solver_options_copy" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        solver_options_copy(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_solver_options_get_internal_solver(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SolverOptions *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:solver_options_get_internal_solver",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "solver_options_get_internal_solver" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "solver_options_get_internal_solver" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (SolverOptions *)solver_options_get_internal_solver(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SolverOptions, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_numerics_set_verbose(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:numerics_set_verbose",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "numerics_set_verbose" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        numerics_set_verbose(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int Swig_var_verbose_set(PyObject *_val) {
  {
    int val;
    int res = SWIG_AsVal_int(_val, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""verbose""' of type '""int""'");
    }
    verbose = (int)(val);
  }
  return 0;
fail:
  return 1;
}


SWIGINTERN PyObject *Swig_var_verbose_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_From_int((int)(verbose));
  return pyobj;
}


SWIGINTERN PyObject *_wrap_numerics_error__varargs__(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *varargs) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  void *arg3 = 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:numerics_error",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "numerics_error" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "numerics_error" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        numerics_error((char const *)arg1,(char const *)arg2,arg3);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_numerics_error(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj;
  PyObject *varargs;
  PyObject *newargs;
  
  newargs = PyTuple_GetSlice(args,0,2);
  varargs = PyTuple_GetSlice(args,2,PyTuple_Size(args));
  resultobj = _wrap_numerics_error__varargs__(NULL,newargs,varargs);
  Py_XDECREF(newargs);
  Py_XDECREF(varargs);
  return resultobj;
}


SWIGINTERN PyObject *_wrap_numerics_error_nonfatal__varargs__(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *varargs) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  void *arg3 = 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:numerics_error_nonfatal",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "numerics_error_nonfatal" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "numerics_error_nonfatal" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        numerics_error_nonfatal((char const *)arg1,(char const *)arg2,arg3);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_numerics_error_nonfatal(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj;
  PyObject *varargs;
  PyObject *newargs;
  
  newargs = PyTuple_GetSlice(args,0,2);
  varargs = PyTuple_GetSlice(args,2,PyTuple_Size(args));
  resultobj = _wrap_numerics_error_nonfatal__varargs__(NULL,newargs,varargs);
  Py_XDECREF(newargs);
  Py_XDECREF(varargs);
  return resultobj;
}


SWIGINTERN PyObject *_wrap_numerics_warning__varargs__(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *varargs) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  void *arg3 = 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:numerics_warning",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "numerics_warning" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "numerics_warning" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        numerics_warning((char const *)arg1,arg2,arg3);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_numerics_warning(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj;
  PyObject *varargs;
  PyObject *newargs;
  
  newargs = PyTuple_GetSlice(args,0,2);
  varargs = PyTuple_GetSlice(args,2,PyTuple_Size(args));
  resultobj = _wrap_numerics_warning__varargs__(NULL,newargs,varargs);
  Py_XDECREF(newargs);
  Py_XDECREF(varargs);
  return resultobj;
}


SWIGINTERN PyObject *_wrap_numerics_printf__varargs__(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *varargs) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  void *arg2 = 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:numerics_printf",&obj0)) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "numerics_printf" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = (char *)(buf1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        numerics_printf((char const *)arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
  return resultobj;
fail:
  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
  return NULL;
}


SWIGINTERN PyObject *_wrap_numerics_printf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj;
  PyObject *varargs;
  PyObject *newargs;
  
  newargs = PyTuple_GetSlice(args,0,1);
  varargs = PyTuple_GetSlice(args,1,PyTuple_Size(args));
  resultobj = _wrap_numerics_printf__varargs__(NULL,newargs,varargs);
  Py_XDECREF(newargs);
  Py_XDECREF(varargs);
  return resultobj;
}


SWIGINTERN PyObject *_wrap_numerics_printf_verbose__varargs__(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *varargs) {
  PyObject *resultobj = 0;
  int arg1 ;
  char *arg2 = (char *) 0 ;
  void *arg3 = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:numerics_printf_verbose",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "numerics_printf_verbose" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "numerics_printf_verbose" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        numerics_printf_verbose(arg1,(char const *)arg2,arg3);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_numerics_printf_verbose(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj;
  PyObject *varargs;
  PyObject *newargs;
  
  newargs = PyTuple_GetSlice(args,0,2);
  varargs = PyTuple_GetSlice(args,2,PyTuple_Size(args));
  resultobj = _wrap_numerics_printf_verbose__varargs__(NULL,newargs,varargs);
  Py_XDECREF(newargs);
  Py_XDECREF(varargs);
  return resultobj;
}


SWIGINTERN PyObject *_wrap_isqrt(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:isqrt",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "isqrt" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = (unsigned int)(val1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (unsigned int)isqrt(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_compiled_in_debug_mode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)":compiled_in_debug_mode")) SWIG_fail;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)compiled_in_debug_mode();
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_set_cstruct(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  uintptr_t arg1 ;
  void *arg2 = (void *) 0 ;
  void *argp1 ;
  int res1 = 0 ;
  int res2 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:set_cstruct",&obj0,&obj1)) SWIG_fail;
  {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_uintptr_t,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_cstruct" "', argument " "1"" of type '" "uintptr_t""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "set_cstruct" "', argument " "1"" of type '" "uintptr_t""'");
    } else {
      arg1 = *((uintptr_t *)(argp1));
    }
  }
  res2 = SWIG_ConvertPtr(obj1,SWIG_as_voidptrptr(&arg2), 0, 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "set_cstruct" "', argument " "2"" of type '" "void *""'"); 
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        set_cstruct(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CSparseMatrix_lu_factors_n_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CSparseMatrix_lu_factors *arg1 = (CSparseMatrix_lu_factors *) 0 ;
  long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:CSparseMatrix_lu_factors_n_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CSparseMatrix_lu_factors, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CSparseMatrix_lu_factors_n_set" "', argument " "1"" of type '" "CSparseMatrix_lu_factors *""'"); 
  }
  arg1 = (CSparseMatrix_lu_factors *)(argp1);
  ecode2 = SWIG_AsVal_long(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CSparseMatrix_lu_factors_n_set" "', argument " "2"" of type '" "long""'");
  } 
  arg2 = (long)(val2);
  if (arg1) (arg1)->n = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CSparseMatrix_lu_factors_n_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CSparseMatrix_lu_factors *arg1 = (CSparseMatrix_lu_factors *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  long result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CSparseMatrix_lu_factors_n_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CSparseMatrix_lu_factors, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CSparseMatrix_lu_factors_n_get" "', argument " "1"" of type '" "CSparseMatrix_lu_factors *""'"); 
  }
  arg1 = (CSparseMatrix_lu_factors *)(argp1);
  result = (long) ((arg1)->n);
  resultobj = SWIG_From_long((long)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CSparseMatrix_lu_factors_S_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CSparseMatrix_lu_factors *arg1 = (CSparseMatrix_lu_factors *) 0 ;
  cs_dls *arg2 = (cs_dls *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:CSparseMatrix_lu_factors_S_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CSparseMatrix_lu_factors, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CSparseMatrix_lu_factors_S_set" "', argument " "1"" of type '" "CSparseMatrix_lu_factors *""'"); 
  }
  arg1 = (CSparseMatrix_lu_factors *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_cs_dl_symbolic, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CSparseMatrix_lu_factors_S_set" "', argument " "2"" of type '" "cs_dls *""'"); 
  }
  arg2 = (cs_dls *)(argp2);
  if (arg1) (arg1)->S = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CSparseMatrix_lu_factors_S_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CSparseMatrix_lu_factors *arg1 = (CSparseMatrix_lu_factors *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  cs_dls *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CSparseMatrix_lu_factors_S_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CSparseMatrix_lu_factors, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CSparseMatrix_lu_factors_S_get" "', argument " "1"" of type '" "CSparseMatrix_lu_factors *""'"); 
  }
  arg1 = (CSparseMatrix_lu_factors *)(argp1);
  result = (cs_dls *) ((arg1)->S);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_cs_dl_symbolic, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CSparseMatrix_lu_factors_N_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CSparseMatrix_lu_factors *arg1 = (CSparseMatrix_lu_factors *) 0 ;
  cs_dln *arg2 = (cs_dln *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:CSparseMatrix_lu_factors_N_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CSparseMatrix_lu_factors, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CSparseMatrix_lu_factors_N_set" "', argument " "1"" of type '" "CSparseMatrix_lu_factors *""'"); 
  }
  arg1 = (CSparseMatrix_lu_factors *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_cs_dl_numeric, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CSparseMatrix_lu_factors_N_set" "', argument " "2"" of type '" "cs_dln *""'"); 
  }
  arg2 = (cs_dln *)(argp2);
  if (arg1) (arg1)->N = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CSparseMatrix_lu_factors_N_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CSparseMatrix_lu_factors *arg1 = (CSparseMatrix_lu_factors *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  cs_dln *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CSparseMatrix_lu_factors_N_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CSparseMatrix_lu_factors, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CSparseMatrix_lu_factors_N_get" "', argument " "1"" of type '" "CSparseMatrix_lu_factors *""'"); 
  }
  arg1 = (CSparseMatrix_lu_factors *)(argp1);
  result = (cs_dln *) ((arg1)->N);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_cs_dl_numeric, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_CSparseMatrix_lu_factors(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CSparseMatrix_lu_factors *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_CSparseMatrix_lu_factors")) SWIG_fail;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (CSparseMatrix_lu_factors *)calloc(1, sizeof(CSparseMatrix_lu_factors));
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CSparseMatrix_lu_factors, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_CSparseMatrix_lu_factors(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CSparseMatrix_lu_factors *arg1 = (CSparseMatrix_lu_factors *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_CSparseMatrix_lu_factors",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CSparseMatrix_lu_factors, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CSparseMatrix_lu_factors" "', argument " "1"" of type '" "CSparseMatrix_lu_factors *""'"); 
  }
  arg1 = (CSparseMatrix_lu_factors *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        free((char *) arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *CSparseMatrix_lu_factors_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_CSparseMatrix_lu_factors, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_CSparsematrix_lu_factorization(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  long arg1 ;
  CSparseMatrix *arg2 = (CSparseMatrix *) 0 ;
  double arg3 ;
  CSparseMatrix_lu_factors *arg4 = (CSparseMatrix_lu_factors *) 0 ;
  long val1 ;
  int ecode1 = 0 ;
  int array_data_ctrl_2 = 0 ;
  int array_i_ctrl_2 = 0 ;
  int array_p_ctrl_2 = 0 ;
  PyArrayObject *array_data_2 = NULL ;
  PyArrayObject *array_i_2 = NULL ;
  PyArrayObject *array_p_2 = NULL ;
  int alloc_ctrl_2 = 0 ;
  struct cs_dl_sparse *M2 = NULL ;
  double val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:CSparsematrix_lu_factorization",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  ecode1 = SWIG_AsVal_long(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "CSparsematrix_lu_factorization" "', argument " "1"" of type '" "long""'");
  } 
  arg1 = (long)(val1);
  {
    int res = cs_convert_from_scipy_sparse(obj1, &M2, &array_data_2, &array_data_ctrl_2, &array_i_2, &array_i_ctrl_2, &array_p_2, &array_p_ctrl_2, &alloc_ctrl_2);
    
    
    
    
    
    
    if (!res) {
      SWIG_fail; 
    }
    else if (res < 0) {
      SWIG_exception_fail(SWIG_RuntimeError, "Error the matrix is not sparse!"); 
    }
    
    arg2 = M2;
  }
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CSparsematrix_lu_factorization" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_CSparseMatrix_lu_factors, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "CSparsematrix_lu_factorization" "', argument " "4"" of type '" "CSparseMatrix_lu_factors *""'"); 
  }
  arg4 = (CSparseMatrix_lu_factors *)(argp4);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)CSparsematrix_lu_factorization(arg1,(struct cs_dl_sparse const *)arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    if(array_data_ctrl_2 && array_data_2) {
      Py_DECREF(array_data_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if(M2) {
      NM_clean_cs(M2, alloc_ctrl_2); cs_spfree(M2); 
    }
  }
  return resultobj;
fail:
  {
    if(array_data_ctrl_2 && array_data_2) {
      Py_DECREF(array_data_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if(M2) {
      NM_clean_cs(M2, alloc_ctrl_2); cs_spfree(M2); 
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_CSparseMatrix_solve(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CSparseMatrix_lu_factors *arg1 = (CSparseMatrix_lu_factors *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  long result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:CSparseMatrix_solve",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CSparseMatrix_lu_factors, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CSparseMatrix_solve" "', argument " "1"" of type '" "CSparseMatrix_lu_factors *""'"); 
  }
  arg1 = (CSparseMatrix_lu_factors *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (long)CSparseMatrix_solve(arg1,arg2,arg3);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_long((long)(result));
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_CSparseMatrix_free_lu_factors(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CSparseMatrix_lu_factors *arg1 = (CSparseMatrix_lu_factors *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CSparseMatrix_free_lu_factors",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CSparseMatrix_lu_factors, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CSparseMatrix_free_lu_factors" "', argument " "1"" of type '" "CSparseMatrix_lu_factors *""'"); 
  }
  arg1 = (CSparseMatrix_lu_factors *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        CSparseMatrix_free_lu_factors(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CSparseMatrix_aaxpby(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  double arg1 ;
  CSparseMatrix *arg2 = (CSparseMatrix *) 0 ;
  double *arg3 = (double *) 0 ;
  double arg4 ;
  double *arg5 = (double *) 0 ;
  double val1 ;
  int ecode1 = 0 ;
  int array_data_ctrl_2 = 0 ;
  int array_i_ctrl_2 = 0 ;
  int array_p_ctrl_2 = 0 ;
  PyArrayObject *array_data_2 = NULL ;
  PyArrayObject *array_i_2 = NULL ;
  PyArrayObject *array_p_2 = NULL ;
  int alloc_ctrl_2 = 0 ;
  struct cs_dl_sparse *M2 = NULL ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:CSparseMatrix_aaxpby",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  ecode1 = SWIG_AsVal_double(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "CSparseMatrix_aaxpby" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = (double)(val1);
  {
    int res = cs_convert_from_scipy_sparse(obj1, &M2, &array_data_2, &array_data_ctrl_2, &array_i_2, &array_i_ctrl_2, &array_p_2, &array_p_ctrl_2, &alloc_ctrl_2);
    
    
    
    
    
    
    if (!res) {
      SWIG_fail; 
    }
    else if (res < 0) {
      SWIG_exception_fail(SWIG_RuntimeError, "Error the matrix is not sparse!"); 
    }
    
    arg2 = M2;
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  ecode4 = SWIG_AsVal_double(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "CSparseMatrix_aaxpby" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  res5 = SWIG_ConvertPtr(obj4, &argp5,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "CSparseMatrix_aaxpby" "', argument " "5"" of type '" "double *""'"); 
  }
  arg5 = (double *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)CSparseMatrix_aaxpby(arg1,(struct cs_dl_sparse const *)arg2,(double const *)arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    if(array_data_ctrl_2 && array_data_2) {
      Py_DECREF(array_data_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if(M2) {
      NM_clean_cs(M2, alloc_ctrl_2); cs_spfree(M2); 
    }
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(array_data_ctrl_2 && array_data_2) {
      Py_DECREF(array_data_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if(M2) {
      NM_clean_cs(M2, alloc_ctrl_2); cs_spfree(M2); 
    }
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_CSparseMatrix_alloc_for_copy(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CSparseMatrix *arg1 = (CSparseMatrix *) (CSparseMatrix *)0 ;
  int array_data_ctrl_1 = 0 ;
  int array_i_ctrl_1 = 0 ;
  int array_p_ctrl_1 = 0 ;
  PyArrayObject *array_data_1 = NULL ;
  PyArrayObject *array_i_1 = NULL ;
  PyArrayObject *array_p_1 = NULL ;
  int alloc_ctrl_1 = 0 ;
  struct cs_dl_sparse *M1 = NULL ;
  PyObject * obj0 = 0 ;
  CSparseMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CSparseMatrix_alloc_for_copy",&obj0)) SWIG_fail;
  {
    int res = cs_convert_from_scipy_sparse(obj0, &M1, &array_data_1, &array_data_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    
    if (!res) {
      SWIG_fail; 
    }
    else if (res < 0) {
      SWIG_exception_fail(SWIG_RuntimeError, "Error the matrix is not sparse!"); 
    }
    
    arg1 = M1;
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (CSparseMatrix *)CSparseMatrix_alloc_for_copy((struct cs_dl_sparse const *)arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  {
    if (result->nz == -1)
    {
      resultobj = cs_sparse_to_csc_matrix(result, true);
    }
    else if (result->nz == -2)
    {
      resultobj = cs_sparse_to_csr_matrix(result, true);
    }
    else if (result->nz >= 0)
    {
      resultobj = cs_sparse_to_coo_matrix(result, true);
    }
    else
    {
      SWIG_exception_fail(SWIG_RuntimeError, "The given sparse matrix is of unknown type. Please file a bug");
    }
    
    
    
    
    
    
    if (!resultobj) {
      SWIG_fail; 
    }
  }
  {
    if(array_data_ctrl_1 && array_data_1) {
      Py_DECREF(array_data_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if(M1) {
      NM_clean_cs(M1, alloc_ctrl_1); cs_spfree(M1); 
    }
  }
  return resultobj;
fail:
  {
    if(array_data_ctrl_1 && array_data_1) {
      Py_DECREF(array_data_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if(M1) {
      NM_clean_cs(M1, alloc_ctrl_1); cs_spfree(M1); 
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_CSparseMatrix_to_dense(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CSparseMatrix *arg1 = (CSparseMatrix *) (CSparseMatrix *)0 ;
  double *arg2 = (double *) 0 ;
  int array_data_ctrl_1 = 0 ;
  int array_i_ctrl_1 = 0 ;
  int array_p_ctrl_1 = 0 ;
  PyArrayObject *array_data_1 = NULL ;
  PyArrayObject *array_i_1 = NULL ;
  PyArrayObject *array_p_1 = NULL ;
  int alloc_ctrl_1 = 0 ;
  struct cs_dl_sparse *M1 = NULL ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  long result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:CSparseMatrix_to_dense",&obj0,&obj1)) SWIG_fail;
  {
    int res = cs_convert_from_scipy_sparse(obj0, &M1, &array_data_1, &array_data_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    
    if (!res) {
      SWIG_fail; 
    }
    else if (res < 0) {
      SWIG_exception_fail(SWIG_RuntimeError, "Error the matrix is not sparse!"); 
    }
    
    arg1 = M1;
  }
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CSparseMatrix_to_dense" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = (double *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (long)CSparseMatrix_to_dense((struct cs_dl_sparse const *)arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_long((long)(result));
  {
    if(array_data_ctrl_1 && array_data_1) {
      Py_DECREF(array_data_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if(M1) {
      NM_clean_cs(M1, alloc_ctrl_1); cs_spfree(M1); 
    }
  }
  return resultobj;
fail:
  {
    if(array_data_ctrl_1 && array_data_1) {
      Py_DECREF(array_data_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if(M1) {
      NM_clean_cs(M1, alloc_ctrl_1); cs_spfree(M1); 
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_CSparseMatrix_print_in_file(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CSparseMatrix *arg1 = (CSparseMatrix *) 0 ;
  int arg2 ;
  FILE *arg3 = (FILE *) 0 ;
  int array_data_ctrl_1 = 0 ;
  int array_i_ctrl_1 = 0 ;
  int array_p_ctrl_1 = 0 ;
  PyArrayObject *array_data_1 = NULL ;
  PyArrayObject *array_i_1 = NULL ;
  PyArrayObject *array_p_1 = NULL ;
  int alloc_ctrl_1 = 0 ;
  struct cs_dl_sparse *M1 = NULL ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:CSparseMatrix_print_in_file",&obj0,&obj1,&obj2)) SWIG_fail;
  {
    int res = cs_convert_from_scipy_sparse(obj0, &M1, &array_data_1, &array_data_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    
    if (!res) {
      SWIG_fail; 
    }
    else if (res < 0) {
      SWIG_exception_fail(SWIG_RuntimeError, "Error the matrix is not sparse!"); 
    }
    
    arg1 = M1;
  }
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CSparseMatrix_print_in_file" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    // %typemap(in) (FILE *file)
    int alloc = 1;
    char* cstr;
    int res = SWIG_AsCharPtrAndSize(obj2, &cstr, NULL, &alloc);
    if (!SWIG_IsOK(res)) {
      SWIG_Error(SWIG_ArgError(res), "in method unknown', argument " "1"" of type '" "char *""'");
    }
    arg3 = fopen(cstr, "r");
    if (!arg3)
    {
      SWIG_Error(SWIG_IOError, format_msg_concat("in method '" "CSparseMatrix_print_in_file" "' cannot fopen file", cstr));
      if (alloc == SWIG_NEWOBJ) free(cstr);
      SWIG_fail;
    }
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)CSparseMatrix_print_in_file((struct cs_dl_sparse const *)arg1,arg2,arg3);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    if(array_data_ctrl_1 && array_data_1) {
      Py_DECREF(array_data_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if(M1) {
      NM_clean_cs(M1, alloc_ctrl_1); cs_spfree(M1); 
    }
  }
  {
    // %typemap(freearg) (FILE *file)
    if(arg3)
    {
      fclose(arg3);
    }
  }
  return resultobj;
fail:
  {
    if(array_data_ctrl_1 && array_data_1) {
      Py_DECREF(array_data_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if(M1) {
      NM_clean_cs(M1, alloc_ctrl_1); cs_spfree(M1); 
    }
  }
  {
    // %typemap(freearg) (FILE *file)
    if(arg3)
    {
      fclose(arg3);
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_CSparseMatrix_new_from_file(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FILE *arg1 = (FILE *) 0 ;
  PyObject * obj0 = 0 ;
  CSparseMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CSparseMatrix_new_from_file",&obj0)) SWIG_fail;
  {
    // %typemap(in) (FILE *file)
    int alloc = 1;
    char* cstr;
    int res = SWIG_AsCharPtrAndSize(obj0, &cstr, NULL, &alloc);
    if (!SWIG_IsOK(res)) {
      SWIG_Error(SWIG_ArgError(res), "in method unknown', argument " "1"" of type '" "char *""'");
    }
    arg1 = fopen(cstr, "r");
    if (!arg1)
    {
      SWIG_Error(SWIG_IOError, format_msg_concat("in method '" "CSparseMatrix_new_from_file" "' cannot fopen file", cstr));
      if (alloc == SWIG_NEWOBJ) free(cstr);
      SWIG_fail;
    }
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (CSparseMatrix *)CSparseMatrix_new_from_file(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  {
    if (result->nz == -1)
    {
      resultobj = cs_sparse_to_csc_matrix(result, true);
    }
    else if (result->nz == -2)
    {
      resultobj = cs_sparse_to_csr_matrix(result, true);
    }
    else if (result->nz >= 0)
    {
      resultobj = cs_sparse_to_coo_matrix(result, true);
    }
    else
    {
      SWIG_exception_fail(SWIG_RuntimeError, "The given sparse matrix is of unknown type. Please file a bug");
    }
    
    
    
    
    
    
    if (!resultobj) {
      SWIG_fail; 
    }
  }
  {
    // %typemap(freearg) (FILE *file)
    if(arg1)
    {
      fclose(arg1);
    }
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (FILE *file)
    if(arg1)
    {
      fclose(arg1);
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_CSparseMatrix_zentry(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CSparseMatrix *arg1 = (CSparseMatrix *) 0 ;
  long arg2 ;
  long arg3 ;
  double arg4 ;
  int array_data_ctrl_1 = 0 ;
  int array_i_ctrl_1 = 0 ;
  int array_p_ctrl_1 = 0 ;
  PyArrayObject *array_data_1 = NULL ;
  PyArrayObject *array_i_1 = NULL ;
  PyArrayObject *array_p_1 = NULL ;
  int alloc_ctrl_1 = 0 ;
  struct cs_dl_sparse *M1 = NULL ;
  long val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  long result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:CSparseMatrix_zentry",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  {
    int res = cs_convert_from_scipy_sparse(obj0, &M1, &array_data_1, &array_data_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    
    if (!res) {
      SWIG_fail; 
    }
    else if (res < 0) {
      SWIG_exception_fail(SWIG_RuntimeError, "Error the matrix is not sparse!"); 
    }
    
    arg1 = M1;
  }
  ecode2 = SWIG_AsVal_long(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CSparseMatrix_zentry" "', argument " "2"" of type '" "long""'");
  } 
  arg2 = (long)(val2);
  ecode3 = SWIG_AsVal_long(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CSparseMatrix_zentry" "', argument " "3"" of type '" "long""'");
  } 
  arg3 = (long)(val3);
  ecode4 = SWIG_AsVal_double(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "CSparseMatrix_zentry" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (long)CSparseMatrix_zentry(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_long((long)(result));
  {
    if(array_data_ctrl_1 && array_data_1) {
      Py_DECREF(array_data_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if(M1) {
      NM_clean_cs(M1, alloc_ctrl_1); cs_spfree(M1); 
    }
  }
  return resultobj;
fail:
  {
    if(array_data_ctrl_1 && array_data_1) {
      Py_DECREF(array_data_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if(M1) {
      NM_clean_cs(M1, alloc_ctrl_1); cs_spfree(M1); 
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_CSparseMatrix_check_triplet(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CSparseMatrix *arg1 = (CSparseMatrix *) 0 ;
  int array_data_ctrl_1 = 0 ;
  int array_i_ctrl_1 = 0 ;
  int array_p_ctrl_1 = 0 ;
  PyArrayObject *array_data_1 = NULL ;
  PyArrayObject *array_i_1 = NULL ;
  PyArrayObject *array_p_1 = NULL ;
  int alloc_ctrl_1 = 0 ;
  struct cs_dl_sparse *M1 = NULL ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CSparseMatrix_check_triplet",&obj0)) SWIG_fail;
  {
    int res = cs_convert_from_scipy_sparse(obj0, &M1, &array_data_1, &array_data_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    
    if (!res) {
      SWIG_fail; 
    }
    else if (res < 0) {
      SWIG_exception_fail(SWIG_RuntimeError, "Error the matrix is not sparse!"); 
    }
    
    arg1 = M1;
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)CSparseMatrix_check_triplet(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    if(array_data_ctrl_1 && array_data_1) {
      Py_DECREF(array_data_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if(M1) {
      NM_clean_cs(M1, alloc_ctrl_1); cs_spfree(M1); 
    }
  }
  return resultobj;
fail:
  {
    if(array_data_ctrl_1 && array_data_1) {
      Py_DECREF(array_data_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if(M1) {
      NM_clean_cs(M1, alloc_ctrl_1); cs_spfree(M1); 
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_CSparseMatrix_check_csc(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CSparseMatrix *arg1 = (CSparseMatrix *) 0 ;
  int array_data_ctrl_1 = 0 ;
  int array_i_ctrl_1 = 0 ;
  int array_p_ctrl_1 = 0 ;
  PyArrayObject *array_data_1 = NULL ;
  PyArrayObject *array_i_1 = NULL ;
  PyArrayObject *array_p_1 = NULL ;
  int alloc_ctrl_1 = 0 ;
  struct cs_dl_sparse *M1 = NULL ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CSparseMatrix_check_csc",&obj0)) SWIG_fail;
  {
    int res = cs_convert_from_scipy_sparse(obj0, &M1, &array_data_1, &array_data_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    
    if (!res) {
      SWIG_fail; 
    }
    else if (res < 0) {
      SWIG_exception_fail(SWIG_RuntimeError, "Error the matrix is not sparse!"); 
    }
    
    arg1 = M1;
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)CSparseMatrix_check_csc(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    if(array_data_ctrl_1 && array_data_1) {
      Py_DECREF(array_data_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if(M1) {
      NM_clean_cs(M1, alloc_ctrl_1); cs_spfree(M1); 
    }
  }
  return resultobj;
fail:
  {
    if(array_data_ctrl_1 && array_data_1) {
      Py_DECREF(array_data_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if(M1) {
      NM_clean_cs(M1, alloc_ctrl_1); cs_spfree(M1); 
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_CSparseMatrix_spfree_on_stack(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CSparseMatrix *arg1 = (CSparseMatrix *) 0 ;
  int array_data_ctrl_1 = 0 ;
  int array_i_ctrl_1 = 0 ;
  int array_p_ctrl_1 = 0 ;
  PyArrayObject *array_data_1 = NULL ;
  PyArrayObject *array_i_1 = NULL ;
  PyArrayObject *array_p_1 = NULL ;
  int alloc_ctrl_1 = 0 ;
  struct cs_dl_sparse *M1 = NULL ;
  PyObject * obj0 = 0 ;
  CSparseMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CSparseMatrix_spfree_on_stack",&obj0)) SWIG_fail;
  {
    int res = cs_convert_from_scipy_sparse(obj0, &M1, &array_data_1, &array_data_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    
    if (!res) {
      SWIG_fail; 
    }
    else if (res < 0) {
      SWIG_exception_fail(SWIG_RuntimeError, "Error the matrix is not sparse!"); 
    }
    
    arg1 = M1;
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (CSparseMatrix *)CSparseMatrix_spfree_on_stack(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  {
    if (result->nz == -1)
    {
      resultobj = cs_sparse_to_csc_matrix(result, true);
    }
    else if (result->nz == -2)
    {
      resultobj = cs_sparse_to_csr_matrix(result, true);
    }
    else if (result->nz >= 0)
    {
      resultobj = cs_sparse_to_coo_matrix(result, true);
    }
    else
    {
      SWIG_exception_fail(SWIG_RuntimeError, "The given sparse matrix is of unknown type. Please file a bug");
    }
    
    
    
    
    
    
    if (!resultobj) {
      SWIG_fail; 
    }
  }
  {
    if(array_data_ctrl_1 && array_data_1) {
      Py_DECREF(array_data_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if(M1) {
      NM_clean_cs(M1, alloc_ctrl_1); cs_spfree(M1); 
    }
  }
  return resultobj;
fail:
  {
    if(array_data_ctrl_1 && array_data_1) {
      Py_DECREF(array_data_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if(M1) {
      NM_clean_cs(M1, alloc_ctrl_1); cs_spfree(M1); 
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_CSparseMatrix_copy(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CSparseMatrix *arg1 = (CSparseMatrix *) (CSparseMatrix *)0 ;
  CSparseMatrix *arg2 = (CSparseMatrix *) 0 ;
  int array_data_ctrl_1 = 0 ;
  int array_i_ctrl_1 = 0 ;
  int array_p_ctrl_1 = 0 ;
  PyArrayObject *array_data_1 = NULL ;
  PyArrayObject *array_i_1 = NULL ;
  PyArrayObject *array_p_1 = NULL ;
  int alloc_ctrl_1 = 0 ;
  struct cs_dl_sparse *M1 = NULL ;
  int array_data_ctrl_2 = 0 ;
  int array_i_ctrl_2 = 0 ;
  int array_p_ctrl_2 = 0 ;
  PyArrayObject *array_data_2 = NULL ;
  PyArrayObject *array_i_2 = NULL ;
  PyArrayObject *array_p_2 = NULL ;
  int alloc_ctrl_2 = 0 ;
  struct cs_dl_sparse *M2 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:CSparseMatrix_copy",&obj0,&obj1)) SWIG_fail;
  {
    int res = cs_convert_from_scipy_sparse(obj0, &M1, &array_data_1, &array_data_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    
    if (!res) {
      SWIG_fail; 
    }
    else if (res < 0) {
      SWIG_exception_fail(SWIG_RuntimeError, "Error the matrix is not sparse!"); 
    }
    
    arg1 = M1;
  }
  {
    int res = cs_convert_from_scipy_sparse(obj1, &M2, &array_data_2, &array_data_ctrl_2, &array_i_2, &array_i_ctrl_2, &array_p_2, &array_p_ctrl_2, &alloc_ctrl_2);
    
    
    
    
    
    
    if (!res) {
      SWIG_fail; 
    }
    else if (res < 0) {
      SWIG_exception_fail(SWIG_RuntimeError, "Error the matrix is not sparse!"); 
    }
    
    arg2 = M2;
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        CSparseMatrix_copy((struct cs_dl_sparse const *)arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    if(array_data_ctrl_1 && array_data_1) {
      Py_DECREF(array_data_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if(M1) {
      NM_clean_cs(M1, alloc_ctrl_1); cs_spfree(M1); 
    }
  }
  {
    if(array_data_ctrl_2 && array_data_2) {
      Py_DECREF(array_data_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if(M2) {
      NM_clean_cs(M2, alloc_ctrl_2); cs_spfree(M2); 
    }
  }
  return resultobj;
fail:
  {
    if(array_data_ctrl_1 && array_data_1) {
      Py_DECREF(array_data_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if(M1) {
      NM_clean_cs(M1, alloc_ctrl_1); cs_spfree(M1); 
    }
  }
  {
    if(array_data_ctrl_2 && array_data_2) {
      Py_DECREF(array_data_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if(M2) {
      NM_clean_cs(M2, alloc_ctrl_2); cs_spfree(M2); 
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrix_nbblocks_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrix *arg1 = (struct SparseBlockStructuredMatrix *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SparseBlockStructuredMatrix_nbblocks_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrix_nbblocks_set" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrix *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrix *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SparseBlockStructuredMatrix_nbblocks_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  if (arg1) (arg1)->nbblocks = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrix_nbblocks_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrix *arg1 = (struct SparseBlockStructuredMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SparseBlockStructuredMatrix_nbblocks_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrix_nbblocks_get" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrix *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrix *)(argp1);
  result = (unsigned int) ((arg1)->nbblocks);
  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrix_block_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrix *arg1 = (struct SparseBlockStructuredMatrix *) 0 ;
  double **arg2 = (double **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SparseBlockStructuredMatrix_block_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrix_block_set" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrix *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrix *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SparseBlockStructuredMatrix_block_set" "', argument " "2"" of type '" "double **""'"); 
  }
  arg2 = (double **)(argp2);
  if (arg1) (arg1)->block = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrix_block_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrix *arg1 = (struct SparseBlockStructuredMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double **result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SparseBlockStructuredMatrix_block_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrix_block_get" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrix *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrix *)(argp1);
  result = (double **) ((arg1)->block);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_double, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrix_blocknumber0_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrix *arg1 = (struct SparseBlockStructuredMatrix *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SparseBlockStructuredMatrix_blocknumber0_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrix_blocknumber0_set" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrix *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrix *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SparseBlockStructuredMatrix_blocknumber0_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  if (arg1) (arg1)->blocknumber0 = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrix_blocknumber0_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrix *arg1 = (struct SparseBlockStructuredMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SparseBlockStructuredMatrix_blocknumber0_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrix_blocknumber0_get" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrix *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrix *)(argp1);
  result = (unsigned int) ((arg1)->blocknumber0);
  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrix_blocknumber1_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrix *arg1 = (struct SparseBlockStructuredMatrix *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SparseBlockStructuredMatrix_blocknumber1_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrix_blocknumber1_set" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrix *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrix *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SparseBlockStructuredMatrix_blocknumber1_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  if (arg1) (arg1)->blocknumber1 = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrix_blocknumber1_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrix *arg1 = (struct SparseBlockStructuredMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SparseBlockStructuredMatrix_blocknumber1_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrix_blocknumber1_get" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrix *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrix *)(argp1);
  result = (unsigned int) ((arg1)->blocknumber1);
  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrix_blocksize0_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrix *arg1 = (struct SparseBlockStructuredMatrix *) 0 ;
  unsigned int *arg2 = (unsigned int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SparseBlockStructuredMatrix_blocksize0_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrix_blocksize0_set" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrix *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrix *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_unsigned_int, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SparseBlockStructuredMatrix_blocksize0_set" "', argument " "2"" of type '" "unsigned int *""'"); 
  }
  arg2 = (unsigned int *)(argp2);
  if (arg1) (arg1)->blocksize0 = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrix_blocksize0_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrix *arg1 = (struct SparseBlockStructuredMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SparseBlockStructuredMatrix_blocksize0_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrix_blocksize0_get" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrix *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrix *)(argp1);
  result = (unsigned int *) ((arg1)->blocksize0);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_int, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrix_blocksize1_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrix *arg1 = (struct SparseBlockStructuredMatrix *) 0 ;
  unsigned int *arg2 = (unsigned int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SparseBlockStructuredMatrix_blocksize1_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrix_blocksize1_set" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrix *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrix *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_unsigned_int, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SparseBlockStructuredMatrix_blocksize1_set" "', argument " "2"" of type '" "unsigned int *""'"); 
  }
  arg2 = (unsigned int *)(argp2);
  if (arg1) (arg1)->blocksize1 = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrix_blocksize1_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrix *arg1 = (struct SparseBlockStructuredMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SparseBlockStructuredMatrix_blocksize1_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrix_blocksize1_get" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrix *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrix *)(argp1);
  result = (unsigned int *) ((arg1)->blocksize1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_int, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrix_filled1_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrix *arg1 = (struct SparseBlockStructuredMatrix *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SparseBlockStructuredMatrix_filled1_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrix_filled1_set" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrix *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrix *)(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SparseBlockStructuredMatrix_filled1_set" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = (size_t)(val2);
  if (arg1) (arg1)->filled1 = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrix_filled1_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrix *arg1 = (struct SparseBlockStructuredMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  size_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SparseBlockStructuredMatrix_filled1_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrix_filled1_get" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrix *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrix *)(argp1);
  result =  ((arg1)->filled1);
  resultobj = SWIG_From_size_t((size_t)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrix_filled2_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrix *arg1 = (struct SparseBlockStructuredMatrix *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SparseBlockStructuredMatrix_filled2_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrix_filled2_set" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrix *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrix *)(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SparseBlockStructuredMatrix_filled2_set" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = (size_t)(val2);
  if (arg1) (arg1)->filled2 = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrix_filled2_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrix *arg1 = (struct SparseBlockStructuredMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  size_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SparseBlockStructuredMatrix_filled2_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrix_filled2_get" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrix *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrix *)(argp1);
  result =  ((arg1)->filled2);
  resultobj = SWIG_From_size_t((size_t)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrix_index1_data_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrix *arg1 = (struct SparseBlockStructuredMatrix *) 0 ;
  size_t *arg2 = (size_t *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SparseBlockStructuredMatrix_index1_data_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrix_index1_data_set" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrix *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrix *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_size_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SparseBlockStructuredMatrix_index1_data_set" "', argument " "2"" of type '" "size_t *""'"); 
  }
  arg2 = (size_t *)(argp2);
  if (arg1) (arg1)->index1_data = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrix_index1_data_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrix *arg1 = (struct SparseBlockStructuredMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  size_t *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SparseBlockStructuredMatrix_index1_data_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrix_index1_data_get" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrix *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrix *)(argp1);
  result = (size_t *) ((arg1)->index1_data);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_size_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrix_index2_data_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrix *arg1 = (struct SparseBlockStructuredMatrix *) 0 ;
  size_t *arg2 = (size_t *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SparseBlockStructuredMatrix_index2_data_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrix_index2_data_set" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrix *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrix *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_size_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SparseBlockStructuredMatrix_index2_data_set" "', argument " "2"" of type '" "size_t *""'"); 
  }
  arg2 = (size_t *)(argp2);
  if (arg1) (arg1)->index2_data = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrix_index2_data_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrix *arg1 = (struct SparseBlockStructuredMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  size_t *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SparseBlockStructuredMatrix_index2_data_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrix_index2_data_get" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrix *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrix *)(argp1);
  result = (size_t *) ((arg1)->index2_data);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_size_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrix_diagonal_blocks_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrix *arg1 = (struct SparseBlockStructuredMatrix *) 0 ;
  unsigned int *arg2 = (unsigned int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SparseBlockStructuredMatrix_diagonal_blocks_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrix_diagonal_blocks_set" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrix *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrix *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_unsigned_int, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SparseBlockStructuredMatrix_diagonal_blocks_set" "', argument " "2"" of type '" "unsigned int *""'"); 
  }
  arg2 = (unsigned int *)(argp2);
  if (arg1) (arg1)->diagonal_blocks = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrix_diagonal_blocks_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrix *arg1 = (struct SparseBlockStructuredMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SparseBlockStructuredMatrix_diagonal_blocks_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrix_diagonal_blocks_get" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrix *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrix *)(argp1);
  result = (unsigned int *) ((arg1)->diagonal_blocks);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_int, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SparseBlockStructuredMatrix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrix *arg1 = (struct SparseBlockStructuredMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_SparseBlockStructuredMatrix",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SparseBlockStructuredMatrix" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrix *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrix *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        delete_SparseBlockStructuredMatrix(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SparseBlockStructuredMatrix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_SparseBlockStructuredMatrix")) SWIG_fail;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct SparseBlockStructuredMatrix *)calloc(1, sizeof(struct SparseBlockStructuredMatrix));
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SparseBlockStructuredMatrix, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SparseBlockStructuredMatrix_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_SparseBlockStructuredMatrix, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_SparseBlockCoordinateMatrix_nbblocks_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockCoordinateMatrix *arg1 = (struct SparseBlockCoordinateMatrix *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SparseBlockCoordinateMatrix_nbblocks_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockCoordinateMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockCoordinateMatrix_nbblocks_set" "', argument " "1"" of type '" "struct SparseBlockCoordinateMatrix *""'"); 
  }
  arg1 = (struct SparseBlockCoordinateMatrix *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SparseBlockCoordinateMatrix_nbblocks_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  if (arg1) (arg1)->nbblocks = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockCoordinateMatrix_nbblocks_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockCoordinateMatrix *arg1 = (struct SparseBlockCoordinateMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SparseBlockCoordinateMatrix_nbblocks_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockCoordinateMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockCoordinateMatrix_nbblocks_get" "', argument " "1"" of type '" "struct SparseBlockCoordinateMatrix *""'"); 
  }
  arg1 = (struct SparseBlockCoordinateMatrix *)(argp1);
  result = (unsigned int) ((arg1)->nbblocks);
  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockCoordinateMatrix_blocknumber0_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockCoordinateMatrix *arg1 = (struct SparseBlockCoordinateMatrix *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SparseBlockCoordinateMatrix_blocknumber0_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockCoordinateMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockCoordinateMatrix_blocknumber0_set" "', argument " "1"" of type '" "struct SparseBlockCoordinateMatrix *""'"); 
  }
  arg1 = (struct SparseBlockCoordinateMatrix *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SparseBlockCoordinateMatrix_blocknumber0_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  if (arg1) (arg1)->blocknumber0 = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockCoordinateMatrix_blocknumber0_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockCoordinateMatrix *arg1 = (struct SparseBlockCoordinateMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SparseBlockCoordinateMatrix_blocknumber0_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockCoordinateMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockCoordinateMatrix_blocknumber0_get" "', argument " "1"" of type '" "struct SparseBlockCoordinateMatrix *""'"); 
  }
  arg1 = (struct SparseBlockCoordinateMatrix *)(argp1);
  result = (unsigned int) ((arg1)->blocknumber0);
  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockCoordinateMatrix_blocknumber1_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockCoordinateMatrix *arg1 = (struct SparseBlockCoordinateMatrix *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SparseBlockCoordinateMatrix_blocknumber1_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockCoordinateMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockCoordinateMatrix_blocknumber1_set" "', argument " "1"" of type '" "struct SparseBlockCoordinateMatrix *""'"); 
  }
  arg1 = (struct SparseBlockCoordinateMatrix *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SparseBlockCoordinateMatrix_blocknumber1_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  if (arg1) (arg1)->blocknumber1 = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockCoordinateMatrix_blocknumber1_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockCoordinateMatrix *arg1 = (struct SparseBlockCoordinateMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SparseBlockCoordinateMatrix_blocknumber1_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockCoordinateMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockCoordinateMatrix_blocknumber1_get" "', argument " "1"" of type '" "struct SparseBlockCoordinateMatrix *""'"); 
  }
  arg1 = (struct SparseBlockCoordinateMatrix *)(argp1);
  result = (unsigned int) ((arg1)->blocknumber1);
  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockCoordinateMatrix_block_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockCoordinateMatrix *arg1 = (struct SparseBlockCoordinateMatrix *) 0 ;
  double **arg2 = (double **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SparseBlockCoordinateMatrix_block_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockCoordinateMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockCoordinateMatrix_block_set" "', argument " "1"" of type '" "struct SparseBlockCoordinateMatrix *""'"); 
  }
  arg1 = (struct SparseBlockCoordinateMatrix *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SparseBlockCoordinateMatrix_block_set" "', argument " "2"" of type '" "double **""'"); 
  }
  arg2 = (double **)(argp2);
  if (arg1) (arg1)->block = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockCoordinateMatrix_block_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockCoordinateMatrix *arg1 = (struct SparseBlockCoordinateMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double **result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SparseBlockCoordinateMatrix_block_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockCoordinateMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockCoordinateMatrix_block_get" "', argument " "1"" of type '" "struct SparseBlockCoordinateMatrix *""'"); 
  }
  arg1 = (struct SparseBlockCoordinateMatrix *)(argp1);
  result = (double **) ((arg1)->block);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_double, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockCoordinateMatrix_blocksize0_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockCoordinateMatrix *arg1 = (struct SparseBlockCoordinateMatrix *) 0 ;
  unsigned int *arg2 = (unsigned int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SparseBlockCoordinateMatrix_blocksize0_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockCoordinateMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockCoordinateMatrix_blocksize0_set" "', argument " "1"" of type '" "struct SparseBlockCoordinateMatrix *""'"); 
  }
  arg1 = (struct SparseBlockCoordinateMatrix *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_unsigned_int, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SparseBlockCoordinateMatrix_blocksize0_set" "', argument " "2"" of type '" "unsigned int *""'"); 
  }
  arg2 = (unsigned int *)(argp2);
  if (arg1) (arg1)->blocksize0 = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockCoordinateMatrix_blocksize0_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockCoordinateMatrix *arg1 = (struct SparseBlockCoordinateMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SparseBlockCoordinateMatrix_blocksize0_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockCoordinateMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockCoordinateMatrix_blocksize0_get" "', argument " "1"" of type '" "struct SparseBlockCoordinateMatrix *""'"); 
  }
  arg1 = (struct SparseBlockCoordinateMatrix *)(argp1);
  result = (unsigned int *) ((arg1)->blocksize0);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_int, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockCoordinateMatrix_blocksize1_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockCoordinateMatrix *arg1 = (struct SparseBlockCoordinateMatrix *) 0 ;
  unsigned int *arg2 = (unsigned int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SparseBlockCoordinateMatrix_blocksize1_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockCoordinateMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockCoordinateMatrix_blocksize1_set" "', argument " "1"" of type '" "struct SparseBlockCoordinateMatrix *""'"); 
  }
  arg1 = (struct SparseBlockCoordinateMatrix *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_unsigned_int, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SparseBlockCoordinateMatrix_blocksize1_set" "', argument " "2"" of type '" "unsigned int *""'"); 
  }
  arg2 = (unsigned int *)(argp2);
  if (arg1) (arg1)->blocksize1 = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockCoordinateMatrix_blocksize1_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockCoordinateMatrix *arg1 = (struct SparseBlockCoordinateMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SparseBlockCoordinateMatrix_blocksize1_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockCoordinateMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockCoordinateMatrix_blocksize1_get" "', argument " "1"" of type '" "struct SparseBlockCoordinateMatrix *""'"); 
  }
  arg1 = (struct SparseBlockCoordinateMatrix *)(argp1);
  result = (unsigned int *) ((arg1)->blocksize1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_int, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockCoordinateMatrix_row_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockCoordinateMatrix *arg1 = (struct SparseBlockCoordinateMatrix *) 0 ;
  unsigned int *arg2 = (unsigned int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SparseBlockCoordinateMatrix_row_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockCoordinateMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockCoordinateMatrix_row_set" "', argument " "1"" of type '" "struct SparseBlockCoordinateMatrix *""'"); 
  }
  arg1 = (struct SparseBlockCoordinateMatrix *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_unsigned_int, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SparseBlockCoordinateMatrix_row_set" "', argument " "2"" of type '" "unsigned int *""'"); 
  }
  arg2 = (unsigned int *)(argp2);
  if (arg1) (arg1)->row = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockCoordinateMatrix_row_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockCoordinateMatrix *arg1 = (struct SparseBlockCoordinateMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SparseBlockCoordinateMatrix_row_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockCoordinateMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockCoordinateMatrix_row_get" "', argument " "1"" of type '" "struct SparseBlockCoordinateMatrix *""'"); 
  }
  arg1 = (struct SparseBlockCoordinateMatrix *)(argp1);
  result = (unsigned int *) ((arg1)->row);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_int, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockCoordinateMatrix_column_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockCoordinateMatrix *arg1 = (struct SparseBlockCoordinateMatrix *) 0 ;
  unsigned int *arg2 = (unsigned int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SparseBlockCoordinateMatrix_column_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockCoordinateMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockCoordinateMatrix_column_set" "', argument " "1"" of type '" "struct SparseBlockCoordinateMatrix *""'"); 
  }
  arg1 = (struct SparseBlockCoordinateMatrix *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_unsigned_int, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SparseBlockCoordinateMatrix_column_set" "', argument " "2"" of type '" "unsigned int *""'"); 
  }
  arg2 = (unsigned int *)(argp2);
  if (arg1) (arg1)->column = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockCoordinateMatrix_column_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockCoordinateMatrix *arg1 = (struct SparseBlockCoordinateMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SparseBlockCoordinateMatrix_column_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockCoordinateMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockCoordinateMatrix_column_get" "', argument " "1"" of type '" "struct SparseBlockCoordinateMatrix *""'"); 
  }
  arg1 = (struct SparseBlockCoordinateMatrix *)(argp1);
  result = (unsigned int *) ((arg1)->column);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_int, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SparseBlockCoordinateMatrix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockCoordinateMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_SparseBlockCoordinateMatrix")) SWIG_fail;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct SparseBlockCoordinateMatrix *)calloc(1, sizeof(struct SparseBlockCoordinateMatrix));
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SparseBlockCoordinateMatrix, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SparseBlockCoordinateMatrix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockCoordinateMatrix *arg1 = (struct SparseBlockCoordinateMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_SparseBlockCoordinateMatrix",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockCoordinateMatrix, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SparseBlockCoordinateMatrix" "', argument " "1"" of type '" "struct SparseBlockCoordinateMatrix *""'"); 
  }
  arg1 = (struct SparseBlockCoordinateMatrix *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        free((char *) arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SparseBlockCoordinateMatrix_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_SparseBlockCoordinateMatrix, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrixPred_nbbldiag_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrixPred *arg1 = (struct SparseBlockStructuredMatrixPred *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SparseBlockStructuredMatrixPred_nbbldiag_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrixPred, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrixPred_nbbldiag_set" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrixPred *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrixPred *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SparseBlockStructuredMatrixPred_nbbldiag_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->nbbldiag = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrixPred_nbbldiag_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrixPred *arg1 = (struct SparseBlockStructuredMatrixPred *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SparseBlockStructuredMatrixPred_nbbldiag_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrixPred, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrixPred_nbbldiag_get" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrixPred *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrixPred *)(argp1);
  result = (int) ((arg1)->nbbldiag);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrixPred_indic_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrixPred *arg1 = (struct SparseBlockStructuredMatrixPred *) 0 ;
  int **arg2 = (int **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SparseBlockStructuredMatrixPred_indic_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrixPred, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrixPred_indic_set" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrixPred *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrixPred *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_p_int, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SparseBlockStructuredMatrixPred_indic_set" "', argument " "2"" of type '" "int **""'"); 
  }
  arg2 = (int **)(argp2);
  if (arg1) (arg1)->indic = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrixPred_indic_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrixPred *arg1 = (struct SparseBlockStructuredMatrixPred *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int **result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SparseBlockStructuredMatrixPred_indic_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrixPred, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrixPred_indic_get" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrixPred *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrixPred *)(argp1);
  result = (int **) ((arg1)->indic);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_int, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrixPred_indicop_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrixPred *arg1 = (struct SparseBlockStructuredMatrixPred *) 0 ;
  int **arg2 = (int **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SparseBlockStructuredMatrixPred_indicop_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrixPred, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrixPred_indicop_set" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrixPred *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrixPred *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_p_int, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SparseBlockStructuredMatrixPred_indicop_set" "', argument " "2"" of type '" "int **""'"); 
  }
  arg2 = (int **)(argp2);
  if (arg1) (arg1)->indicop = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrixPred_indicop_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrixPred *arg1 = (struct SparseBlockStructuredMatrixPred *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int **result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SparseBlockStructuredMatrixPred_indicop_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrixPred, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrixPred_indicop_get" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrixPred *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrixPred *)(argp1);
  result = (int **) ((arg1)->indicop);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_int, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrixPred_submatlcp_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrixPred *arg1 = (struct SparseBlockStructuredMatrixPred *) 0 ;
  double **arg2 = (double **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SparseBlockStructuredMatrixPred_submatlcp_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrixPred, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrixPred_submatlcp_set" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrixPred *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrixPred *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SparseBlockStructuredMatrixPred_submatlcp_set" "', argument " "2"" of type '" "double **""'"); 
  }
  arg2 = (double **)(argp2);
  if (arg1) (arg1)->submatlcp = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrixPred_submatlcp_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrixPred *arg1 = (struct SparseBlockStructuredMatrixPred *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double **result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SparseBlockStructuredMatrixPred_submatlcp_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrixPred, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrixPred_submatlcp_get" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrixPred *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrixPred *)(argp1);
  result = (double **) ((arg1)->submatlcp);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_double, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrixPred_submatlcpop_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrixPred *arg1 = (struct SparseBlockStructuredMatrixPred *) 0 ;
  double **arg2 = (double **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SparseBlockStructuredMatrixPred_submatlcpop_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrixPred, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrixPred_submatlcpop_set" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrixPred *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrixPred *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SparseBlockStructuredMatrixPred_submatlcpop_set" "', argument " "2"" of type '" "double **""'"); 
  }
  arg2 = (double **)(argp2);
  if (arg1) (arg1)->submatlcpop = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrixPred_submatlcpop_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrixPred *arg1 = (struct SparseBlockStructuredMatrixPred *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double **result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SparseBlockStructuredMatrixPred_submatlcpop_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrixPred, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrixPred_submatlcpop_get" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrixPred *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrixPred *)(argp1);
  result = (double **) ((arg1)->submatlcpop);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_double, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrixPred_ipiv_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrixPred *arg1 = (struct SparseBlockStructuredMatrixPred *) 0 ;
  int **arg2 = (int **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SparseBlockStructuredMatrixPred_ipiv_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrixPred, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrixPred_ipiv_set" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrixPred *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrixPred *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_p_int, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SparseBlockStructuredMatrixPred_ipiv_set" "', argument " "2"" of type '" "int **""'"); 
  }
  arg2 = (int **)(argp2);
  if (arg1) (arg1)->ipiv = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrixPred_ipiv_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrixPred *arg1 = (struct SparseBlockStructuredMatrixPred *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int **result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SparseBlockStructuredMatrixPred_ipiv_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrixPred, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrixPred_ipiv_get" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrixPred *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrixPred *)(argp1);
  result = (int **) ((arg1)->ipiv);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_int, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrixPred_sizesublcp_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrixPred *arg1 = (struct SparseBlockStructuredMatrixPred *) 0 ;
  int *arg2 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SparseBlockStructuredMatrixPred_sizesublcp_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrixPred, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrixPred_sizesublcp_set" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrixPred *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrixPred *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_int, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SparseBlockStructuredMatrixPred_sizesublcp_set" "', argument " "2"" of type '" "int *""'"); 
  }
  arg2 = (int *)(argp2);
  if (arg1) (arg1)->sizesublcp = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrixPred_sizesublcp_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrixPred *arg1 = (struct SparseBlockStructuredMatrixPred *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SparseBlockStructuredMatrixPred_sizesublcp_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrixPred, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrixPred_sizesublcp_get" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrixPred *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrixPred *)(argp1);
  result = (int *) ((arg1)->sizesublcp);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_int, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrixPred_sizesublcpop_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrixPred *arg1 = (struct SparseBlockStructuredMatrixPred *) 0 ;
  int *arg2 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SparseBlockStructuredMatrixPred_sizesublcpop_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrixPred, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrixPred_sizesublcpop_set" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrixPred *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrixPred *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_int, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SparseBlockStructuredMatrixPred_sizesublcpop_set" "', argument " "2"" of type '" "int *""'"); 
  }
  arg2 = (int *)(argp2);
  if (arg1) (arg1)->sizesublcpop = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrixPred_sizesublcpop_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrixPred *arg1 = (struct SparseBlockStructuredMatrixPred *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SparseBlockStructuredMatrixPred_sizesublcpop_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrixPred, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrixPred_sizesublcpop_get" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrixPred *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrixPred *)(argp1);
  result = (int *) ((arg1)->sizesublcpop);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_int, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrixPred_subq_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrixPred *arg1 = (struct SparseBlockStructuredMatrixPred *) 0 ;
  double **arg2 = (double **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SparseBlockStructuredMatrixPred_subq_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrixPred, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrixPred_subq_set" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrixPred *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrixPred *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SparseBlockStructuredMatrixPred_subq_set" "', argument " "2"" of type '" "double **""'"); 
  }
  arg2 = (double **)(argp2);
  if (arg1) (arg1)->subq = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrixPred_subq_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrixPred *arg1 = (struct SparseBlockStructuredMatrixPred *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double **result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SparseBlockStructuredMatrixPred_subq_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrixPred, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrixPred_subq_get" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrixPred *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrixPred *)(argp1);
  result = (double **) ((arg1)->subq);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_double, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrixPred_bufz_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrixPred *arg1 = (struct SparseBlockStructuredMatrixPred *) 0 ;
  double **arg2 = (double **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SparseBlockStructuredMatrixPred_bufz_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrixPred, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrixPred_bufz_set" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrixPred *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrixPred *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SparseBlockStructuredMatrixPred_bufz_set" "', argument " "2"" of type '" "double **""'"); 
  }
  arg2 = (double **)(argp2);
  if (arg1) (arg1)->bufz = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrixPred_bufz_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrixPred *arg1 = (struct SparseBlockStructuredMatrixPred *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double **result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SparseBlockStructuredMatrixPred_bufz_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrixPred, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrixPred_bufz_get" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrixPred *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrixPred *)(argp1);
  result = (double **) ((arg1)->bufz);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_double, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrixPred_newz_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrixPred *arg1 = (struct SparseBlockStructuredMatrixPred *) 0 ;
  double **arg2 = (double **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SparseBlockStructuredMatrixPred_newz_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrixPred, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrixPred_newz_set" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrixPred *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrixPred *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SparseBlockStructuredMatrixPred_newz_set" "', argument " "2"" of type '" "double **""'"); 
  }
  arg2 = (double **)(argp2);
  if (arg1) (arg1)->newz = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrixPred_newz_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrixPred *arg1 = (struct SparseBlockStructuredMatrixPred *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double **result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SparseBlockStructuredMatrixPred_newz_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrixPred, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrixPred_newz_get" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrixPred *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrixPred *)(argp1);
  result = (double **) ((arg1)->newz);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_double, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrixPred_workspace_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrixPred *arg1 = (struct SparseBlockStructuredMatrixPred *) 0 ;
  double **arg2 = (double **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SparseBlockStructuredMatrixPred_workspace_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrixPred, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrixPred_workspace_set" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrixPred *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrixPred *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SparseBlockStructuredMatrixPred_workspace_set" "', argument " "2"" of type '" "double **""'"); 
  }
  arg2 = (double **)(argp2);
  if (arg1) (arg1)->workspace = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SparseBlockStructuredMatrixPred_workspace_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrixPred *arg1 = (struct SparseBlockStructuredMatrixPred *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double **result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SparseBlockStructuredMatrixPred_workspace_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrixPred, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SparseBlockStructuredMatrixPred_workspace_get" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrixPred *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrixPred *)(argp1);
  result = (double **) ((arg1)->workspace);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_double, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SparseBlockStructuredMatrixPred(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrixPred *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_SparseBlockStructuredMatrixPred")) SWIG_fail;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct SparseBlockStructuredMatrixPred *)calloc(1, sizeof(struct SparseBlockStructuredMatrixPred));
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SparseBlockStructuredMatrixPred, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SparseBlockStructuredMatrixPred(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SparseBlockStructuredMatrixPred *arg1 = (struct SparseBlockStructuredMatrixPred *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_SparseBlockStructuredMatrixPred",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrixPred, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SparseBlockStructuredMatrixPred" "', argument " "1"" of type '" "struct SparseBlockStructuredMatrixPred *""'"); 
  }
  arg1 = (struct SparseBlockStructuredMatrixPred *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        free((char *) arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SparseBlockStructuredMatrixPred_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_SparseBlockStructuredMatrixPred, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_SBM_index_by_column_filled3_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SBM_index_by_column *arg1 = (struct SBM_index_by_column *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBM_index_by_column_filled3_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBM_index_by_column, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBM_index_by_column_filled3_set" "', argument " "1"" of type '" "struct SBM_index_by_column *""'"); 
  }
  arg1 = (struct SBM_index_by_column *)(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SBM_index_by_column_filled3_set" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = (size_t)(val2);
  if (arg1) (arg1)->filled3 = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_index_by_column_filled3_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SBM_index_by_column *arg1 = (struct SBM_index_by_column *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  size_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBM_index_by_column_filled3_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBM_index_by_column, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBM_index_by_column_filled3_get" "', argument " "1"" of type '" "struct SBM_index_by_column *""'"); 
  }
  arg1 = (struct SBM_index_by_column *)(argp1);
  result =  ((arg1)->filled3);
  resultobj = SWIG_From_size_t((size_t)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_index_by_column_filled4_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SBM_index_by_column *arg1 = (struct SBM_index_by_column *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBM_index_by_column_filled4_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBM_index_by_column, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBM_index_by_column_filled4_set" "', argument " "1"" of type '" "struct SBM_index_by_column *""'"); 
  }
  arg1 = (struct SBM_index_by_column *)(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SBM_index_by_column_filled4_set" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = (size_t)(val2);
  if (arg1) (arg1)->filled4 = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_index_by_column_filled4_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SBM_index_by_column *arg1 = (struct SBM_index_by_column *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  size_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBM_index_by_column_filled4_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBM_index_by_column, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBM_index_by_column_filled4_get" "', argument " "1"" of type '" "struct SBM_index_by_column *""'"); 
  }
  arg1 = (struct SBM_index_by_column *)(argp1);
  result =  ((arg1)->filled4);
  resultobj = SWIG_From_size_t((size_t)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_index_by_column_index3_data_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SBM_index_by_column *arg1 = (struct SBM_index_by_column *) 0 ;
  size_t *arg2 = (size_t *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBM_index_by_column_index3_data_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBM_index_by_column, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBM_index_by_column_index3_data_set" "', argument " "1"" of type '" "struct SBM_index_by_column *""'"); 
  }
  arg1 = (struct SBM_index_by_column *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_size_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBM_index_by_column_index3_data_set" "', argument " "2"" of type '" "size_t *""'"); 
  }
  arg2 = (size_t *)(argp2);
  if (arg1) (arg1)->index3_data = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_index_by_column_index3_data_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SBM_index_by_column *arg1 = (struct SBM_index_by_column *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  size_t *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBM_index_by_column_index3_data_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBM_index_by_column, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBM_index_by_column_index3_data_get" "', argument " "1"" of type '" "struct SBM_index_by_column *""'"); 
  }
  arg1 = (struct SBM_index_by_column *)(argp1);
  result = (size_t *) ((arg1)->index3_data);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_size_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_index_by_column_index4_data_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SBM_index_by_column *arg1 = (struct SBM_index_by_column *) 0 ;
  size_t *arg2 = (size_t *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBM_index_by_column_index4_data_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBM_index_by_column, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBM_index_by_column_index4_data_set" "', argument " "1"" of type '" "struct SBM_index_by_column *""'"); 
  }
  arg1 = (struct SBM_index_by_column *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_size_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBM_index_by_column_index4_data_set" "', argument " "2"" of type '" "size_t *""'"); 
  }
  arg2 = (size_t *)(argp2);
  if (arg1) (arg1)->index4_data = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_index_by_column_index4_data_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SBM_index_by_column *arg1 = (struct SBM_index_by_column *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  size_t *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBM_index_by_column_index4_data_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBM_index_by_column, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBM_index_by_column_index4_data_get" "', argument " "1"" of type '" "struct SBM_index_by_column *""'"); 
  }
  arg1 = (struct SBM_index_by_column *)(argp1);
  result = (size_t *) ((arg1)->index4_data);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_size_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_index_by_column_blockMap_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SBM_index_by_column *arg1 = (struct SBM_index_by_column *) 0 ;
  size_t *arg2 = (size_t *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBM_index_by_column_blockMap_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBM_index_by_column, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBM_index_by_column_blockMap_set" "', argument " "1"" of type '" "struct SBM_index_by_column *""'"); 
  }
  arg1 = (struct SBM_index_by_column *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_size_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBM_index_by_column_blockMap_set" "', argument " "2"" of type '" "size_t *""'"); 
  }
  arg2 = (size_t *)(argp2);
  if (arg1) (arg1)->blockMap = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_index_by_column_blockMap_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SBM_index_by_column *arg1 = (struct SBM_index_by_column *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  size_t *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBM_index_by_column_blockMap_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBM_index_by_column, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBM_index_by_column_blockMap_get" "', argument " "1"" of type '" "struct SBM_index_by_column *""'"); 
  }
  arg1 = (struct SBM_index_by_column *)(argp1);
  result = (size_t *) ((arg1)->blockMap);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_size_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBM_index_by_column(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SBM_index_by_column *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_SBM_index_by_column")) SWIG_fail;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct SBM_index_by_column *)calloc(1, sizeof(struct SBM_index_by_column));
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBM_index_by_column, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SBM_index_by_column(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SBM_index_by_column *arg1 = (struct SBM_index_by_column *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_SBM_index_by_column",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBM_index_by_column, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SBM_index_by_column" "', argument " "1"" of type '" "struct SBM_index_by_column *""'"); 
  }
  arg1 = (struct SBM_index_by_column *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        free((char *) arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SBM_index_by_column_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_SBM_index_by_column, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_SBM_new(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SparseBlockStructuredMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":SBM_new")) SWIG_fail;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (SparseBlockStructuredMatrix *)SBM_new();
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SparseBlockStructuredMatrix, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_null(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SparseBlockStructuredMatrix *arg1 = (SparseBlockStructuredMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBM_null",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBM_null" "', argument " "1"" of type '" "SparseBlockStructuredMatrix *""'"); 
  }
  arg1 = (SparseBlockStructuredMatrix *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        SBM_null(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_gemv(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  double arg3 ;
  SparseBlockStructuredMatrix *arg4 = (SparseBlockStructuredMatrix *) (SparseBlockStructuredMatrix *)0 ;
  double *arg5 = (double *) 0 ;
  double arg6 ;
  double *arg7 = (double *) 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  PyArrayObject *array5 = NULL ;
  int is_new_object5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:SBM_gemv",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBM_gemv" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = (unsigned int)(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SBM_gemv" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SBM_gemv" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SBM_gemv" "', argument " "4"" of type '" "SparseBlockStructuredMatrix const *const""'"); 
  }
  arg4 = (SparseBlockStructuredMatrix *)(argp4);
  {
    array5 = obj_to_sn_vector(obj4, &is_new_object5);
    
    if (!array5)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array5))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg5 = (double *) array_data(array5);
    
  }
  ecode6 = SWIG_AsVal_double(obj5, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "SBM_gemv" "', argument " "6"" of type '" "double""'");
  } 
  arg6 = (double)(val6);
  res7 = SWIG_ConvertPtr(obj6, &argp7,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res7)) {
    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "SBM_gemv" "', argument " "7"" of type '" "double *""'"); 
  }
  arg7 = (double *)(argp7);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        SBM_gemv(arg1,arg2,arg3,(SparseBlockStructuredMatrix const *)arg4,(double const *)arg5,arg6,arg7);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    if(is_new_object5 && array5) {
      Py_DECREF(array5); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object5 && array5) {
      Py_DECREF(array5); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_gemv_3x3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  SparseBlockStructuredMatrix *arg3 = (SparseBlockStructuredMatrix *) (SparseBlockStructuredMatrix *)0 ;
  double *arg4 = (double *) (double *)0 ;
  double *arg5 = (double *) 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyArrayObject *array4 = NULL ;
  int is_new_object4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:SBM_gemv_3x3",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBM_gemv_3x3" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = (unsigned int)(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SBM_gemv_3x3" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SBM_gemv_3x3" "', argument " "3"" of type '" "SparseBlockStructuredMatrix const *const""'"); 
  }
  arg3 = (SparseBlockStructuredMatrix *)(argp3);
  {
    array4 = obj_to_sn_vector(obj3, &is_new_object4);
    
    if (!array4)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array4))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg4 = (double *) array_data(array4);
    
  }
  res5 = SWIG_ConvertPtr(obj4, &argp5,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "SBM_gemv_3x3" "', argument " "5"" of type '" "double *""'"); 
  }
  arg5 = (double *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        SBM_gemv_3x3(arg1,arg2,(SparseBlockStructuredMatrix const *)arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_gemm_without_allocation(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  double arg1 ;
  SparseBlockStructuredMatrix *arg2 = (SparseBlockStructuredMatrix *) (SparseBlockStructuredMatrix *)0 ;
  SparseBlockStructuredMatrix *arg3 = (SparseBlockStructuredMatrix *) (SparseBlockStructuredMatrix *)0 ;
  double arg4 ;
  SparseBlockStructuredMatrix *arg5 = (SparseBlockStructuredMatrix *) 0 ;
  double val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:SBM_gemm_without_allocation",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  ecode1 = SWIG_AsVal_double(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBM_gemm_without_allocation" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = (double)(val1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBM_gemm_without_allocation" "', argument " "2"" of type '" "SparseBlockStructuredMatrix const *const""'"); 
  }
  arg2 = (SparseBlockStructuredMatrix *)(argp2);
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SBM_gemm_without_allocation" "', argument " "3"" of type '" "SparseBlockStructuredMatrix const *const""'"); 
  }
  arg3 = (SparseBlockStructuredMatrix *)(argp3);
  ecode4 = SWIG_AsVal_double(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SBM_gemm_without_allocation" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  res5 = SWIG_ConvertPtr(obj4, &argp5,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "SBM_gemm_without_allocation" "', argument " "5"" of type '" "SparseBlockStructuredMatrix *""'"); 
  }
  arg5 = (SparseBlockStructuredMatrix *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        SBM_gemm_without_allocation(arg1,(SparseBlockStructuredMatrix const *)arg2,(SparseBlockStructuredMatrix const *)arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_multiply(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SparseBlockStructuredMatrix *arg1 = (SparseBlockStructuredMatrix *) (SparseBlockStructuredMatrix *)0 ;
  SparseBlockStructuredMatrix *arg2 = (SparseBlockStructuredMatrix *) (SparseBlockStructuredMatrix *)0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SparseBlockStructuredMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBM_multiply",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBM_multiply" "', argument " "1"" of type '" "SparseBlockStructuredMatrix const *const""'"); 
  }
  arg1 = (SparseBlockStructuredMatrix *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBM_multiply" "', argument " "2"" of type '" "SparseBlockStructuredMatrix const *const""'"); 
  }
  arg2 = (SparseBlockStructuredMatrix *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (SparseBlockStructuredMatrix *)SBM_multiply((SparseBlockStructuredMatrix const *)arg1,(SparseBlockStructuredMatrix const *)arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_zero_matrix_for_multiply(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SparseBlockStructuredMatrix *arg1 = (SparseBlockStructuredMatrix *) (SparseBlockStructuredMatrix *)0 ;
  SparseBlockStructuredMatrix *arg2 = (SparseBlockStructuredMatrix *) (SparseBlockStructuredMatrix *)0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SparseBlockStructuredMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBM_zero_matrix_for_multiply",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBM_zero_matrix_for_multiply" "', argument " "1"" of type '" "SparseBlockStructuredMatrix const *const""'"); 
  }
  arg1 = (SparseBlockStructuredMatrix *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBM_zero_matrix_for_multiply" "', argument " "2"" of type '" "SparseBlockStructuredMatrix const *const""'"); 
  }
  arg2 = (SparseBlockStructuredMatrix *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (SparseBlockStructuredMatrix *)SBM_zero_matrix_for_multiply((SparseBlockStructuredMatrix const *)arg1,(SparseBlockStructuredMatrix const *)arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_add(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SparseBlockStructuredMatrix *arg1 = (SparseBlockStructuredMatrix *) 0 ;
  SparseBlockStructuredMatrix *arg2 = (SparseBlockStructuredMatrix *) 0 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  SparseBlockStructuredMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:SBM_add",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBM_add" "', argument " "1"" of type '" "SparseBlockStructuredMatrix *""'"); 
  }
  arg1 = (SparseBlockStructuredMatrix *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBM_add" "', argument " "2"" of type '" "SparseBlockStructuredMatrix *""'"); 
  }
  arg2 = (SparseBlockStructuredMatrix *)(argp2);
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SBM_add" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  ecode4 = SWIG_AsVal_double(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SBM_add" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (SparseBlockStructuredMatrix *)SBM_add(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_add_without_allocation(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SparseBlockStructuredMatrix *arg1 = (SparseBlockStructuredMatrix *) 0 ;
  SparseBlockStructuredMatrix *arg2 = (SparseBlockStructuredMatrix *) 0 ;
  double arg3 ;
  double arg4 ;
  SparseBlockStructuredMatrix *arg5 = (SparseBlockStructuredMatrix *) 0 ;
  double arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOO:SBM_add_without_allocation",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBM_add_without_allocation" "', argument " "1"" of type '" "SparseBlockStructuredMatrix *""'"); 
  }
  arg1 = (SparseBlockStructuredMatrix *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBM_add_without_allocation" "', argument " "2"" of type '" "SparseBlockStructuredMatrix *""'"); 
  }
  arg2 = (SparseBlockStructuredMatrix *)(argp2);
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SBM_add_without_allocation" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  ecode4 = SWIG_AsVal_double(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SBM_add_without_allocation" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  res5 = SWIG_ConvertPtr(obj4, &argp5,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "SBM_add_without_allocation" "', argument " "5"" of type '" "SparseBlockStructuredMatrix *""'"); 
  }
  arg5 = (SparseBlockStructuredMatrix *)(argp5);
  ecode6 = SWIG_AsVal_double(obj5, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "SBM_add_without_allocation" "', argument " "6"" of type '" "double""'");
  } 
  arg6 = (double)(val6);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        SBM_add_without_allocation(arg1,arg2,arg3,arg4,arg5,arg6);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_row_prod(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  SparseBlockStructuredMatrix *arg4 = (SparseBlockStructuredMatrix *) (SparseBlockStructuredMatrix *)0 ;
  double *arg5 = (double *) (double *)0 ;
  double *arg6 = (double *) 0 ;
  int arg7 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  PyArrayObject *array5 = NULL ;
  int is_new_object5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:SBM_row_prod",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBM_row_prod" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = (unsigned int)(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SBM_row_prod" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SBM_row_prod" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SBM_row_prod" "', argument " "4"" of type '" "SparseBlockStructuredMatrix const *const""'"); 
  }
  arg4 = (SparseBlockStructuredMatrix *)(argp4);
  {
    array5 = obj_to_sn_vector(obj4, &is_new_object5);
    
    if (!array5)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array5))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg5 = (double *) array_data(array5);
    
  }
  res6 = SWIG_ConvertPtr(obj5, &argp6,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "SBM_row_prod" "', argument " "6"" of type '" "double *""'"); 
  }
  arg6 = (double *)(argp6);
  ecode7 = SWIG_AsVal_int(obj6, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "SBM_row_prod" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        SBM_row_prod(arg1,arg2,arg3,(SparseBlockStructuredMatrix const *)arg4,(double const *)arg5,arg6,arg7);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    if(is_new_object5 && array5) {
      Py_DECREF(array5); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object5 && array5) {
      Py_DECREF(array5); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_row_prod_no_diag(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  SparseBlockStructuredMatrix *arg4 = (SparseBlockStructuredMatrix *) (SparseBlockStructuredMatrix *)0 ;
  double *arg5 = (double *) (double *)0 ;
  double *arg6 = (double *) 0 ;
  int arg7 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  PyArrayObject *array5 = NULL ;
  int is_new_object5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:SBM_row_prod_no_diag",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBM_row_prod_no_diag" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = (unsigned int)(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SBM_row_prod_no_diag" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SBM_row_prod_no_diag" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SBM_row_prod_no_diag" "', argument " "4"" of type '" "SparseBlockStructuredMatrix const *const""'"); 
  }
  arg4 = (SparseBlockStructuredMatrix *)(argp4);
  {
    array5 = obj_to_sn_vector(obj4, &is_new_object5);
    
    if (!array5)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array5))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg5 = (double *) array_data(array5);
    
  }
  res6 = SWIG_ConvertPtr(obj5, &argp6,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "SBM_row_prod_no_diag" "', argument " "6"" of type '" "double *""'"); 
  }
  arg6 = (double *)(argp6);
  ecode7 = SWIG_AsVal_int(obj6, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "SBM_row_prod_no_diag" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        SBM_row_prod_no_diag(arg1,arg2,arg3,(SparseBlockStructuredMatrix const *)arg4,(double const *)arg5,arg6,arg7);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    if(is_new_object5 && array5) {
      Py_DECREF(array5); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object5 && array5) {
      Py_DECREF(array5); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_row_prod_no_diag_3x3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  SparseBlockStructuredMatrix *arg4 = (SparseBlockStructuredMatrix *) (SparseBlockStructuredMatrix *)0 ;
  double *arg5 = (double *) (double *)0 ;
  double *arg6 = (double *) 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  PyArrayObject *array5 = NULL ;
  int is_new_object5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOO:SBM_row_prod_no_diag_3x3",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBM_row_prod_no_diag_3x3" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = (unsigned int)(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SBM_row_prod_no_diag_3x3" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SBM_row_prod_no_diag_3x3" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SBM_row_prod_no_diag_3x3" "', argument " "4"" of type '" "SparseBlockStructuredMatrix const *const""'"); 
  }
  arg4 = (SparseBlockStructuredMatrix *)(argp4);
  {
    array5 = obj_to_sn_vector(obj4, &is_new_object5);
    
    if (!array5)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array5))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg5 = (double *) array_data(array5);
    
  }
  res6 = SWIG_ConvertPtr(obj5, &argp6,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "SBM_row_prod_no_diag_3x3" "', argument " "6"" of type '" "double *""'"); 
  }
  arg6 = (double *)(argp6);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        SBM_row_prod_no_diag_3x3(arg1,arg2,arg3,(SparseBlockStructuredMatrix const *)arg4,arg5,arg6);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    if(is_new_object5 && array5) {
      Py_DECREF(array5); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object5 && array5) {
      Py_DECREF(array5); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_row_prod_no_diag_1x1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  SparseBlockStructuredMatrix *arg4 = (SparseBlockStructuredMatrix *) (SparseBlockStructuredMatrix *)0 ;
  double *arg5 = (double *) (double *)0 ;
  double *arg6 = (double *) 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  PyArrayObject *array5 = NULL ;
  int is_new_object5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOO:SBM_row_prod_no_diag_1x1",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBM_row_prod_no_diag_1x1" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = (unsigned int)(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SBM_row_prod_no_diag_1x1" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SBM_row_prod_no_diag_1x1" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SBM_row_prod_no_diag_1x1" "', argument " "4"" of type '" "SparseBlockStructuredMatrix const *const""'"); 
  }
  arg4 = (SparseBlockStructuredMatrix *)(argp4);
  {
    array5 = obj_to_sn_vector(obj4, &is_new_object5);
    
    if (!array5)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array5))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg5 = (double *) array_data(array5);
    
  }
  res6 = SWIG_ConvertPtr(obj5, &argp6,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "SBM_row_prod_no_diag_1x1" "', argument " "6"" of type '" "double *""'"); 
  }
  arg6 = (double *)(argp6);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        SBM_row_prod_no_diag_1x1(arg1,arg2,arg3,(SparseBlockStructuredMatrix const *)arg4,arg5,arg6);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    if(is_new_object5 && array5) {
      Py_DECREF(array5); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object5 && array5) {
      Py_DECREF(array5); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_extract_component_3x3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SparseBlockStructuredMatrix *arg1 = (SparseBlockStructuredMatrix *) (SparseBlockStructuredMatrix *)0 ;
  SparseBlockStructuredMatrix *arg2 = (SparseBlockStructuredMatrix *) 0 ;
  unsigned int *arg3 = (unsigned int *) 0 ;
  unsigned int arg4 ;
  unsigned int *arg5 = (unsigned int *) 0 ;
  unsigned int arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  unsigned int val6 ;
  int ecode6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOO:SBM_extract_component_3x3",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBM_extract_component_3x3" "', argument " "1"" of type '" "SparseBlockStructuredMatrix const *const""'"); 
  }
  arg1 = (SparseBlockStructuredMatrix *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBM_extract_component_3x3" "', argument " "2"" of type '" "SparseBlockStructuredMatrix *""'"); 
  }
  arg2 = (SparseBlockStructuredMatrix *)(argp2);
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_unsigned_int, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SBM_extract_component_3x3" "', argument " "3"" of type '" "unsigned int *""'"); 
  }
  arg3 = (unsigned int *)(argp3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SBM_extract_component_3x3" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = (unsigned int)(val4);
  res5 = SWIG_ConvertPtr(obj4, &argp5,SWIGTYPE_p_unsigned_int, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "SBM_extract_component_3x3" "', argument " "5"" of type '" "unsigned int *""'"); 
  }
  arg5 = (unsigned int *)(argp5);
  ecode6 = SWIG_AsVal_unsigned_SS_int(obj5, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "SBM_extract_component_3x3" "', argument " "6"" of type '" "unsigned int""'");
  } 
  arg6 = (unsigned int)(val6);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        SBM_extract_component_3x3((SparseBlockStructuredMatrix const *)arg1,arg2,arg3,arg4,arg5,arg6);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_free(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SparseBlockStructuredMatrix *arg1 = (SparseBlockStructuredMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBM_free",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBM_free" "', argument " "1"" of type '" "SparseBlockStructuredMatrix *""'"); 
  }
  arg1 = (SparseBlockStructuredMatrix *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        SBM_free(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMfree(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SparseBlockStructuredMatrix *arg1 = (SparseBlockStructuredMatrix *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBMfree",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMfree" "', argument " "1"" of type '" "SparseBlockStructuredMatrix *""'"); 
  }
  arg1 = (SparseBlockStructuredMatrix *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SBMfree" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        SBMfree(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_print(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SparseBlockStructuredMatrix *arg1 = (SparseBlockStructuredMatrix *) (SparseBlockStructuredMatrix *)0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBM_print",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBM_print" "', argument " "1"" of type '" "SparseBlockStructuredMatrix const *const""'"); 
  }
  arg1 = (SparseBlockStructuredMatrix *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        SBM_print((SparseBlockStructuredMatrix const *)arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_write_in_file(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SparseBlockStructuredMatrix *arg1 = (SparseBlockStructuredMatrix *) (SparseBlockStructuredMatrix *)0 ;
  FILE *arg2 = (FILE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBM_write_in_file",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBM_write_in_file" "', argument " "1"" of type '" "SparseBlockStructuredMatrix const *const""'"); 
  }
  arg1 = (SparseBlockStructuredMatrix *)(argp1);
  {
    // %typemap(in) (FILE *file)
    int alloc = 1;
    char* cstr;
    int res = SWIG_AsCharPtrAndSize(obj1, &cstr, NULL, &alloc);
    if (!SWIG_IsOK(res)) {
      SWIG_Error(SWIG_ArgError(res), "in method unknown', argument " "1"" of type '" "char *""'");
    }
    arg2 = fopen(cstr, "r");
    if (!arg2)
    {
      SWIG_Error(SWIG_IOError, format_msg_concat("in method '" "SBM_write_in_file" "' cannot fopen file", cstr));
      if (alloc == SWIG_NEWOBJ) free(cstr);
      SWIG_fail;
    }
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        SBM_write_in_file((SparseBlockStructuredMatrix const *)arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_read_in_file(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SparseBlockStructuredMatrix *arg1 = (SparseBlockStructuredMatrix *) (SparseBlockStructuredMatrix *)0 ;
  FILE *arg2 = (FILE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBM_read_in_file",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBM_read_in_file" "', argument " "1"" of type '" "SparseBlockStructuredMatrix *const""'"); 
  }
  arg1 = (SparseBlockStructuredMatrix *)(argp1);
  {
    // %typemap(in) (FILE *file)
    int alloc = 1;
    char* cstr;
    int res = SWIG_AsCharPtrAndSize(obj1, &cstr, NULL, &alloc);
    if (!SWIG_IsOK(res)) {
      SWIG_Error(SWIG_ArgError(res), "in method unknown', argument " "1"" of type '" "char *""'");
    }
    arg2 = fopen(cstr, "r");
    if (!arg2)
    {
      SWIG_Error(SWIG_IOError, format_msg_concat("in method '" "SBM_read_in_file" "' cannot fopen file", cstr));
      if (alloc == SWIG_NEWOBJ) free(cstr);
      SWIG_fail;
    }
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        SBM_read_in_file(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_new_from_file(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FILE *arg1 = (FILE *) 0 ;
  PyObject * obj0 = 0 ;
  SparseBlockStructuredMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBM_new_from_file",&obj0)) SWIG_fail;
  {
    // %typemap(in) (FILE *file)
    int alloc = 1;
    char* cstr;
    int res = SWIG_AsCharPtrAndSize(obj0, &cstr, NULL, &alloc);
    if (!SWIG_IsOK(res)) {
      SWIG_Error(SWIG_ArgError(res), "in method unknown', argument " "1"" of type '" "char *""'");
    }
    arg1 = fopen(cstr, "r");
    if (!arg1)
    {
      SWIG_Error(SWIG_IOError, format_msg_concat("in method '" "SBM_new_from_file" "' cannot fopen file", cstr));
      if (alloc == SWIG_NEWOBJ) free(cstr);
      SWIG_fail;
    }
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (SparseBlockStructuredMatrix *)SBM_new_from_file(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  {
    // %typemap(freearg) (FILE *file)
    if(arg1)
    {
      fclose(arg1);
    }
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (FILE *file)
    if(arg1)
    {
      fclose(arg1);
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_write_in_fileForScilab(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SparseBlockStructuredMatrix *arg1 = (SparseBlockStructuredMatrix *) (SparseBlockStructuredMatrix *)0 ;
  FILE *arg2 = (FILE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBM_write_in_fileForScilab",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBM_write_in_fileForScilab" "', argument " "1"" of type '" "SparseBlockStructuredMatrix const *const""'"); 
  }
  arg1 = (SparseBlockStructuredMatrix *)(argp1);
  {
    // %typemap(in) (FILE *file)
    int alloc = 1;
    char* cstr;
    int res = SWIG_AsCharPtrAndSize(obj1, &cstr, NULL, &alloc);
    if (!SWIG_IsOK(res)) {
      SWIG_Error(SWIG_ArgError(res), "in method unknown', argument " "1"" of type '" "char *""'");
    }
    arg2 = fopen(cstr, "r");
    if (!arg2)
    {
      SWIG_Error(SWIG_IOError, format_msg_concat("in method '" "SBM_write_in_fileForScilab" "' cannot fopen file", cstr));
      if (alloc == SWIG_NEWOBJ) free(cstr);
      SWIG_fail;
    }
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        SBM_write_in_fileForScilab((SparseBlockStructuredMatrix const *)arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_write_in_filename(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SparseBlockStructuredMatrix *arg1 = (SparseBlockStructuredMatrix *) (SparseBlockStructuredMatrix *)0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBM_write_in_filename",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBM_write_in_filename" "', argument " "1"" of type '" "SparseBlockStructuredMatrix const *const""'"); 
  }
  arg1 = (SparseBlockStructuredMatrix *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBM_write_in_filename" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        SBM_write_in_filename((SparseBlockStructuredMatrix const *)arg1,(char const *)arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_read_in_filename(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SparseBlockStructuredMatrix *arg1 = (SparseBlockStructuredMatrix *) (SparseBlockStructuredMatrix *)0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBM_read_in_filename",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBM_read_in_filename" "', argument " "1"" of type '" "SparseBlockStructuredMatrix *const""'"); 
  }
  arg1 = (SparseBlockStructuredMatrix *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBM_read_in_filename" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        SBM_read_in_filename(arg1,(char const *)arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_free_pred(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SparseBlockStructuredMatrixPred *arg1 = (SparseBlockStructuredMatrixPred *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBM_free_pred",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrixPred, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBM_free_pred" "', argument " "1"" of type '" "SparseBlockStructuredMatrixPred *""'"); 
  }
  arg1 = (SparseBlockStructuredMatrixPred *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        SBM_free_pred(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_diagonal_block_indices(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SparseBlockStructuredMatrix *arg1 = (SparseBlockStructuredMatrix *) (SparseBlockStructuredMatrix *)0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBM_diagonal_block_indices",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBM_diagonal_block_indices" "', argument " "1"" of type '" "SparseBlockStructuredMatrix *const""'"); 
  }
  arg1 = (SparseBlockStructuredMatrix *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (unsigned int *)SBM_diagonal_block_indices(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_int, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_diagonal_block_index(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SparseBlockStructuredMatrix *arg1 = (SparseBlockStructuredMatrix *) (SparseBlockStructuredMatrix *)0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBM_diagonal_block_index",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBM_diagonal_block_index" "', argument " "1"" of type '" "SparseBlockStructuredMatrix *const""'"); 
  }
  arg1 = (SparseBlockStructuredMatrix *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SBM_diagonal_block_index" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (unsigned int)SBM_diagonal_block_index(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_zentry(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SparseBlockStructuredMatrix *arg1 = (SparseBlockStructuredMatrix *) (SparseBlockStructuredMatrix *)0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:SBM_zentry",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBM_zentry" "', argument " "1"" of type '" "SparseBlockStructuredMatrix const *const""'"); 
  }
  arg1 = (SparseBlockStructuredMatrix *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SBM_zentry" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SBM_zentry" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  ecode4 = SWIG_AsVal_double(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SBM_zentry" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)SBM_zentry((SparseBlockStructuredMatrix const *)arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_get_value(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SparseBlockStructuredMatrix *arg1 = (SparseBlockStructuredMatrix *) (SparseBlockStructuredMatrix *)0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  double result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:SBM_get_value",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBM_get_value" "', argument " "1"" of type '" "SparseBlockStructuredMatrix const *const""'"); 
  }
  arg1 = (SparseBlockStructuredMatrix *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SBM_get_value" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SBM_get_value" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (double)SBM_get_value((SparseBlockStructuredMatrix const *)arg1,arg2,arg3);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_double((double)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_copy(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SparseBlockStructuredMatrix *arg1 = (SparseBlockStructuredMatrix *) (SparseBlockStructuredMatrix *)0 ;
  SparseBlockStructuredMatrix *arg2 = (SparseBlockStructuredMatrix *) 0 ;
  unsigned int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:SBM_copy",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBM_copy" "', argument " "1"" of type '" "SparseBlockStructuredMatrix const *const""'"); 
  }
  arg1 = (SparseBlockStructuredMatrix *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBM_copy" "', argument " "2"" of type '" "SparseBlockStructuredMatrix *""'"); 
  }
  arg2 = (SparseBlockStructuredMatrix *)(argp2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SBM_copy" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)SBM_copy((SparseBlockStructuredMatrix const *)arg1,arg2,arg3);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_transpose(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SparseBlockStructuredMatrix *arg1 = (SparseBlockStructuredMatrix *) (SparseBlockStructuredMatrix *)0 ;
  SparseBlockStructuredMatrix *arg2 = (SparseBlockStructuredMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBM_transpose",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBM_transpose" "', argument " "1"" of type '" "SparseBlockStructuredMatrix const *const""'"); 
  }
  arg1 = (SparseBlockStructuredMatrix *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBM_transpose" "', argument " "2"" of type '" "SparseBlockStructuredMatrix *""'"); 
  }
  arg2 = (SparseBlockStructuredMatrix *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)SBM_transpose((SparseBlockStructuredMatrix const *)arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_inverse_diagonal_block_matrix_in_place(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SparseBlockStructuredMatrix *arg1 = (SparseBlockStructuredMatrix *) 0 ;
  int *arg2 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBM_inverse_diagonal_block_matrix_in_place",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBM_inverse_diagonal_block_matrix_in_place" "', argument " "1"" of type '" "SparseBlockStructuredMatrix const *""'"); 
  }
  arg1 = (SparseBlockStructuredMatrix *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_int, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBM_inverse_diagonal_block_matrix_in_place" "', argument " "2"" of type '" "int *""'"); 
  }
  arg2 = (int *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)SBM_inverse_diagonal_block_matrix_in_place((SparseBlockStructuredMatrix const *)arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_to_dense(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SparseBlockStructuredMatrix *arg1 = (SparseBlockStructuredMatrix *) (SparseBlockStructuredMatrix *)0 ;
  double *arg2 = (double *) 0 ;
  int dims1[2] ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBM_to_dense",&obj0)) SWIG_fail;
  {
    int res1=0;
    void* temp = NULL;
    res1 = SWIG_ConvertPtr(obj0, &temp, SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0);
    if (!SWIG_IsOK(res1))
    {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBM_to_dense" "', argument " "1"" of type '" "SparseBlockStructuredMatrix const *const""'");
    };
    SparseBlockStructuredMatrix* A = (SparseBlockStructuredMatrix *)temp;
    assert(A);
    dims1[0] = A->blocksize0[A->blocknumber0-1];
    dims1[1] = A->blocksize1[A->blocknumber1-1];
    arg1 = A;
    
    arg2 = (double *) malloc(dims1[0] * dims1[1] * sizeof(double));
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        SBM_to_dense((SparseBlockStructuredMatrix const *)arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    PyObject* out;
    C_to_target_lang2(out, arg1->blocksize0[arg1->blocknumber0-1], arg1->blocksize1[arg1->blocknumber1-1], arg2, SWIG_fail);
    resultobj = out;
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_to_sparse(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SparseBlockStructuredMatrix *arg1 = (SparseBlockStructuredMatrix *) (SparseBlockStructuredMatrix *)0 ;
  CSparseMatrix *arg2 = (CSparseMatrix *) 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBM_to_sparse",&obj0)) SWIG_fail;
  {
    void *swig_arp;
    int swig_res = SWIG_ConvertPtr(obj0,&swig_arp,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 | 0);
    
    if (SWIG_IsOK(swig_res))
    {
      arg1 = (SparseBlockStructuredMatrix*) swig_arp;
      arg2 = (struct cs_dl_sparse*) malloc(sizeof(struct cs_dl_sparse));
      if(!arg2) SWIG_fail;
      
      SBM_to_sparse_init_memory(arg1,arg2);
    }
    else
    SWIG_fail;
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)SBM_to_sparse((SparseBlockStructuredMatrix const *)arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    PyObject* csrm = cs_sparse_to_csr_matrix(arg2, true);
    
    
    
    
    
    
    if (!csrm) {
      SWIG_fail; 
    }
    resultobj = SWIG_Python_AppendOutput(resultobj, csrm);
    cs_spfree(arg2);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_to_sparse_init_memory(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SparseBlockStructuredMatrix *arg1 = (SparseBlockStructuredMatrix *) (SparseBlockStructuredMatrix *)0 ;
  CSparseMatrix *arg2 = (CSparseMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int array_data_ctrl_2 = 0 ;
  int array_i_ctrl_2 = 0 ;
  int array_p_ctrl_2 = 0 ;
  PyArrayObject *array_data_2 = NULL ;
  PyArrayObject *array_i_2 = NULL ;
  PyArrayObject *array_p_2 = NULL ;
  int alloc_ctrl_2 = 0 ;
  struct cs_dl_sparse *M2 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBM_to_sparse_init_memory",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBM_to_sparse_init_memory" "', argument " "1"" of type '" "SparseBlockStructuredMatrix const *const""'"); 
  }
  arg1 = (SparseBlockStructuredMatrix *)(argp1);
  {
    int res = cs_convert_from_scipy_sparse(obj1, &M2, &array_data_2, &array_data_ctrl_2, &array_i_2, &array_i_ctrl_2, &array_p_2, &array_p_ctrl_2, &alloc_ctrl_2);
    
    
    
    
    
    
    if (!res) {
      SWIG_fail; 
    }
    else if (res < 0) {
      SWIG_exception_fail(SWIG_RuntimeError, "Error the matrix is not sparse!"); 
    }
    
    arg2 = M2;
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)SBM_to_sparse_init_memory((SparseBlockStructuredMatrix const *)arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    if(array_data_ctrl_2 && array_data_2) {
      Py_DECREF(array_data_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if(M2) {
      NM_clean_cs(M2, alloc_ctrl_2); cs_spfree(M2); 
    }
  }
  return resultobj;
fail:
  {
    if(array_data_ctrl_2 && array_data_2) {
      Py_DECREF(array_data_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if(M2) {
      NM_clean_cs(M2, alloc_ctrl_2); cs_spfree(M2); 
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_row_permutation(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int *arg1 = (unsigned int *) 0 ;
  SparseBlockStructuredMatrix *arg2 = (SparseBlockStructuredMatrix *) 0 ;
  SparseBlockStructuredMatrix *arg3 = (SparseBlockStructuredMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:SBM_row_permutation",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_unsigned_int, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBM_row_permutation" "', argument " "1"" of type '" "unsigned int *""'"); 
  }
  arg1 = (unsigned int *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBM_row_permutation" "', argument " "2"" of type '" "SparseBlockStructuredMatrix *""'"); 
  }
  arg2 = (SparseBlockStructuredMatrix *)(argp2);
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SBM_row_permutation" "', argument " "3"" of type '" "SparseBlockStructuredMatrix *""'"); 
  }
  arg3 = (SparseBlockStructuredMatrix *)(argp3);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        SBM_row_permutation(arg1,arg2,arg3);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_column_permutation(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int *arg1 = (unsigned int *) 0 ;
  SparseBlockStructuredMatrix *arg2 = (SparseBlockStructuredMatrix *) 0 ;
  SparseBlockStructuredMatrix *arg3 = (SparseBlockStructuredMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:SBM_column_permutation",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_unsigned_int, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBM_column_permutation" "', argument " "1"" of type '" "unsigned int *""'"); 
  }
  arg1 = (unsigned int *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBM_column_permutation" "', argument " "2"" of type '" "SparseBlockStructuredMatrix *""'"); 
  }
  arg2 = (SparseBlockStructuredMatrix *)(argp2);
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SBM_column_permutation" "', argument " "3"" of type '" "SparseBlockStructuredMatrix *""'"); 
  }
  arg3 = (SparseBlockStructuredMatrix *)(argp3);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        SBM_column_permutation(arg1,arg2,arg3);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBCM_null(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SparseBlockCoordinateMatrix *arg1 = (SparseBlockCoordinateMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBCM_null",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockCoordinateMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBCM_null" "', argument " "1"" of type '" "SparseBlockCoordinateMatrix *""'"); 
  }
  arg1 = (SparseBlockCoordinateMatrix *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        SBCM_null(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBCM_new(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SparseBlockCoordinateMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":SBCM_new")) SWIG_fail;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (SparseBlockCoordinateMatrix *)SBCM_new();
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SparseBlockCoordinateMatrix, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBCM_new_3x3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  unsigned int *arg4 = (unsigned int *) 0 ;
  unsigned int *arg5 = (unsigned int *) 0 ;
  double *arg6 = (double *) 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  SparseBlockCoordinateMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOO:SBCM_new_3x3",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBCM_new_3x3" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = (unsigned int)(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SBCM_new_3x3" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SBCM_new_3x3" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_unsigned_int, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SBCM_new_3x3" "', argument " "4"" of type '" "unsigned int *""'"); 
  }
  arg4 = (unsigned int *)(argp4);
  res5 = SWIG_ConvertPtr(obj4, &argp5,SWIGTYPE_p_unsigned_int, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "SBCM_new_3x3" "', argument " "5"" of type '" "unsigned int *""'"); 
  }
  arg5 = (unsigned int *)(argp5);
  res6 = SWIG_ConvertPtr(obj5, &argp6,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "SBCM_new_3x3" "', argument " "6"" of type '" "double *""'"); 
  }
  arg6 = (double *)(argp6);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (SparseBlockCoordinateMatrix *)SBCM_new_3x3(arg1,arg2,arg3,arg4,arg5,arg6);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SparseBlockCoordinateMatrix, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBCM_free_3x3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SparseBlockCoordinateMatrix *arg1 = (SparseBlockCoordinateMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBCM_free_3x3",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockCoordinateMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBCM_free_3x3" "', argument " "1"" of type '" "SparseBlockCoordinateMatrix *""'"); 
  }
  arg1 = (SparseBlockCoordinateMatrix *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        SBCM_free_3x3(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBCM_to_SBM(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SparseBlockCoordinateMatrix *arg1 = (SparseBlockCoordinateMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SparseBlockStructuredMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBCM_to_SBM",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockCoordinateMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBCM_to_SBM" "', argument " "1"" of type '" "SparseBlockCoordinateMatrix *""'"); 
  }
  arg1 = (SparseBlockCoordinateMatrix *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (SparseBlockStructuredMatrix *)SBCM_to_SBM(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SparseBlockStructuredMatrix, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_free_from_SBCM(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SparseBlockStructuredMatrix *arg1 = (SparseBlockStructuredMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBM_free_from_SBCM",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBM_free_from_SBCM" "', argument " "1"" of type '" "SparseBlockStructuredMatrix *""'"); 
  }
  arg1 = (SparseBlockStructuredMatrix *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        SBM_free_from_SBCM(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBM_from_csparse(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  CSparseMatrix *arg2 = (CSparseMatrix *) (CSparseMatrix *)0 ;
  SparseBlockStructuredMatrix *arg3 = (SparseBlockStructuredMatrix *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int array_data_ctrl_2 = 0 ;
  int array_i_ctrl_2 = 0 ;
  int array_p_ctrl_2 = 0 ;
  PyArrayObject *array_data_2 = NULL ;
  PyArrayObject *array_i_2 = NULL ;
  PyArrayObject *array_p_2 = NULL ;
  int alloc_ctrl_2 = 0 ;
  struct cs_dl_sparse *M2 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  {
    arg3 = SBM_new();
    if(!arg3) SWIG_fail;
  }
  if (!PyArg_ParseTuple(args,(char *)"OO:SBM_from_csparse",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBM_from_csparse" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  {
    int res = cs_convert_from_scipy_sparse(obj1, &M2, &array_data_2, &array_data_ctrl_2, &array_i_2, &array_i_ctrl_2, &array_p_2, &array_p_ctrl_2, &alloc_ctrl_2);
    
    
    
    
    
    
    if (!res) {
      SWIG_fail; 
    }
    else if (res < 0) {
      SWIG_exception_fail(SWIG_RuntimeError, "Error the matrix is not sparse!"); 
    }
    
    arg2 = M2;
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)SBM_from_csparse(arg1,(struct cs_dl_sparse const *)arg2,arg3);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    if(!arg3) SWIG_fail;
    
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj(SWIG_as_voidptr(arg3), SWIGTYPE_p_SparseBlockStructuredMatrix, SWIG_POINTER_OWN))
    ;
  }
  {
    if(array_data_ctrl_2 && array_data_2) {
      Py_DECREF(array_data_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if(M2) {
      NM_clean_cs(M2, alloc_ctrl_2); cs_spfree(M2); 
    }
  }
  return resultobj;
fail:
  {
    if(array_data_ctrl_2 && array_data_2) {
      Py_DECREF(array_data_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if(M2) {
      NM_clean_cs(M2, alloc_ctrl_2); cs_spfree(M2); 
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsMatrixInternalData_iWorkSize_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrixInternalData *arg1 = (NumericsMatrixInternalData *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NumericsMatrixInternalData_iWorkSize_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsMatrixInternalData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsMatrixInternalData_iWorkSize_set" "', argument " "1"" of type '" "NumericsMatrixInternalData *""'"); 
  }
  arg1 = (NumericsMatrixInternalData *)(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NumericsMatrixInternalData_iWorkSize_set" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = (size_t)(val2);
  if (arg1) (arg1)->iWorkSize = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsMatrixInternalData_iWorkSize_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrixInternalData *arg1 = (NumericsMatrixInternalData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  size_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NumericsMatrixInternalData_iWorkSize_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsMatrixInternalData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsMatrixInternalData_iWorkSize_get" "', argument " "1"" of type '" "NumericsMatrixInternalData *""'"); 
  }
  arg1 = (NumericsMatrixInternalData *)(argp1);
  result =  ((arg1)->iWorkSize);
  resultobj = SWIG_From_size_t((size_t)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsMatrixInternalData_iWork_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrixInternalData *arg1 = (NumericsMatrixInternalData *) 0 ;
  void *arg2 = (void *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NumericsMatrixInternalData_iWork_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsMatrixInternalData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsMatrixInternalData_iWork_set" "', argument " "1"" of type '" "NumericsMatrixInternalData *""'"); 
  }
  arg1 = (NumericsMatrixInternalData *)(argp1);
  res2 = SWIG_ConvertPtr(obj1,SWIG_as_voidptrptr(&arg2), 0, SWIG_POINTER_DISOWN);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NumericsMatrixInternalData_iWork_set" "', argument " "2"" of type '" "void *""'"); 
  }
  if (arg1) (arg1)->iWork = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsMatrixInternalData_iWork_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrixInternalData *arg1 = (NumericsMatrixInternalData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  void *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NumericsMatrixInternalData_iWork_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsMatrixInternalData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsMatrixInternalData_iWork_get" "', argument " "1"" of type '" "NumericsMatrixInternalData *""'"); 
  }
  arg1 = (NumericsMatrixInternalData *)(argp1);
  result = (void *) ((arg1)->iWork);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsMatrixInternalData_sizeof_elt_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrixInternalData *arg1 = (NumericsMatrixInternalData *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NumericsMatrixInternalData_sizeof_elt_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsMatrixInternalData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsMatrixInternalData_sizeof_elt_set" "', argument " "1"" of type '" "NumericsMatrixInternalData *""'"); 
  }
  arg1 = (NumericsMatrixInternalData *)(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NumericsMatrixInternalData_sizeof_elt_set" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = (size_t)(val2);
  if (arg1) (arg1)->sizeof_elt = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsMatrixInternalData_sizeof_elt_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrixInternalData *arg1 = (NumericsMatrixInternalData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  size_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NumericsMatrixInternalData_sizeof_elt_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsMatrixInternalData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsMatrixInternalData_sizeof_elt_get" "', argument " "1"" of type '" "NumericsMatrixInternalData *""'"); 
  }
  arg1 = (NumericsMatrixInternalData *)(argp1);
  result =  ((arg1)->sizeof_elt);
  resultobj = SWIG_From_size_t((size_t)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsMatrixInternalData_dWorkSize_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrixInternalData *arg1 = (NumericsMatrixInternalData *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NumericsMatrixInternalData_dWorkSize_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsMatrixInternalData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsMatrixInternalData_dWorkSize_set" "', argument " "1"" of type '" "NumericsMatrixInternalData *""'"); 
  }
  arg1 = (NumericsMatrixInternalData *)(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NumericsMatrixInternalData_dWorkSize_set" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = (size_t)(val2);
  if (arg1) (arg1)->dWorkSize = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsMatrixInternalData_dWorkSize_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrixInternalData *arg1 = (NumericsMatrixInternalData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  size_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NumericsMatrixInternalData_dWorkSize_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsMatrixInternalData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsMatrixInternalData_dWorkSize_get" "', argument " "1"" of type '" "NumericsMatrixInternalData *""'"); 
  }
  arg1 = (NumericsMatrixInternalData *)(argp1);
  result =  ((arg1)->dWorkSize);
  resultobj = SWIG_From_size_t((size_t)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsMatrixInternalData_dWork_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrixInternalData *arg1 = (NumericsMatrixInternalData *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NumericsMatrixInternalData_dWork_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsMatrixInternalData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsMatrixInternalData_dWork_set" "', argument " "1"" of type '" "NumericsMatrixInternalData *""'"); 
  }
  arg1 = (NumericsMatrixInternalData *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_double, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NumericsMatrixInternalData_dWork_set" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = (double *)(argp2);
  if (arg1) (arg1)->dWork = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsMatrixInternalData_dWork_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrixInternalData *arg1 = (NumericsMatrixInternalData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NumericsMatrixInternalData_dWork_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsMatrixInternalData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsMatrixInternalData_dWork_get" "', argument " "1"" of type '" "NumericsMatrixInternalData *""'"); 
  }
  arg1 = (NumericsMatrixInternalData *)(argp1);
  result = (double *) ((arg1)->dWork);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsMatrixInternalData_isLUfactorized_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrixInternalData *arg1 = (NumericsMatrixInternalData *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NumericsMatrixInternalData_isLUfactorized_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsMatrixInternalData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsMatrixInternalData_isLUfactorized_set" "', argument " "1"" of type '" "NumericsMatrixInternalData *""'"); 
  }
  arg1 = (NumericsMatrixInternalData *)(argp1);
  ecode2 = SWIG_AsVal_bool(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NumericsMatrixInternalData_isLUfactorized_set" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = (bool)(val2);
  if (arg1) (arg1)->isLUfactorized = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsMatrixInternalData_isLUfactorized_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrixInternalData *arg1 = (NumericsMatrixInternalData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NumericsMatrixInternalData_isLUfactorized_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsMatrixInternalData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsMatrixInternalData_isLUfactorized_get" "', argument " "1"" of type '" "NumericsMatrixInternalData *""'"); 
  }
  arg1 = (NumericsMatrixInternalData *)(argp1);
  result = (bool) ((arg1)->isLUfactorized);
  resultobj = SWIG_From_bool((bool)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsMatrixInternalData_isInversed_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrixInternalData *arg1 = (NumericsMatrixInternalData *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NumericsMatrixInternalData_isInversed_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsMatrixInternalData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsMatrixInternalData_isInversed_set" "', argument " "1"" of type '" "NumericsMatrixInternalData *""'"); 
  }
  arg1 = (NumericsMatrixInternalData *)(argp1);
  ecode2 = SWIG_AsVal_bool(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NumericsMatrixInternalData_isInversed_set" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = (bool)(val2);
  if (arg1) (arg1)->isInversed = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsMatrixInternalData_isInversed_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrixInternalData *arg1 = (NumericsMatrixInternalData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NumericsMatrixInternalData_isInversed_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsMatrixInternalData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsMatrixInternalData_isInversed_get" "', argument " "1"" of type '" "NumericsMatrixInternalData *""'"); 
  }
  arg1 = (NumericsMatrixInternalData *)(argp1);
  result = (bool) ((arg1)->isInversed);
  resultobj = SWIG_From_bool((bool)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_NumericsMatrixInternalData(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrixInternalData *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_NumericsMatrixInternalData")) SWIG_fail;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (NumericsMatrixInternalData *)calloc(1, sizeof(NumericsMatrixInternalData));
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NumericsMatrixInternalData, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_NumericsMatrixInternalData(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrixInternalData *arg1 = (NumericsMatrixInternalData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_NumericsMatrixInternalData",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsMatrixInternalData, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_NumericsMatrixInternalData" "', argument " "1"" of type '" "NumericsMatrixInternalData *""'"); 
  }
  arg1 = (NumericsMatrixInternalData *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        free((char *) arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *NumericsMatrixInternalData_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_NumericsMatrixInternalData, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_NumericsMatrix_storageType_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NumericsMatrix *arg1 = (struct NumericsMatrix *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NumericsMatrix_storageType_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsMatrix_storageType_set" "', argument " "1"" of type '" "struct NumericsMatrix *""'"); 
  }
  arg1 = (struct NumericsMatrix *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NumericsMatrix_storageType_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->storageType = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsMatrix_storageType_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NumericsMatrix *arg1 = (struct NumericsMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NumericsMatrix_storageType_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsMatrix_storageType_get" "', argument " "1"" of type '" "struct NumericsMatrix *""'"); 
  }
  arg1 = (struct NumericsMatrix *)(argp1);
  result = (int) ((arg1)->storageType);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsMatrix_size0_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NumericsMatrix *arg1 = (struct NumericsMatrix *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NumericsMatrix_size0_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsMatrix_size0_set" "', argument " "1"" of type '" "struct NumericsMatrix *""'"); 
  }
  arg1 = (struct NumericsMatrix *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NumericsMatrix_size0_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->size0 = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsMatrix_size0_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NumericsMatrix *arg1 = (struct NumericsMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NumericsMatrix_size0_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsMatrix_size0_get" "', argument " "1"" of type '" "struct NumericsMatrix *""'"); 
  }
  arg1 = (struct NumericsMatrix *)(argp1);
  result = (int) ((arg1)->size0);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsMatrix_size1_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NumericsMatrix *arg1 = (struct NumericsMatrix *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NumericsMatrix_size1_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsMatrix_size1_set" "', argument " "1"" of type '" "struct NumericsMatrix *""'"); 
  }
  arg1 = (struct NumericsMatrix *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NumericsMatrix_size1_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->size1 = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsMatrix_size1_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NumericsMatrix *arg1 = (struct NumericsMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NumericsMatrix_size1_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsMatrix_size1_get" "', argument " "1"" of type '" "struct NumericsMatrix *""'"); 
  }
  arg1 = (struct NumericsMatrix *)(argp1);
  result = (int) ((arg1)->size1);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsMatrix_matrix0_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NumericsMatrix *arg1 = (struct NumericsMatrix *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NumericsMatrix_matrix0_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsMatrix_matrix0_set" "', argument " "1"" of type '" "struct NumericsMatrix *""'"); 
  }
  arg1 = (struct NumericsMatrix *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_double, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NumericsMatrix_matrix0_set" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = (double *)(argp2);
  if (arg1) (arg1)->matrix0 = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsMatrix_matrix0_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NumericsMatrix *arg1 = (struct NumericsMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NumericsMatrix_matrix0_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsMatrix_matrix0_get" "', argument " "1"" of type '" "struct NumericsMatrix *""'"); 
  }
  arg1 = (struct NumericsMatrix *)(argp1);
  result = (double *) ((arg1)->matrix0);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsMatrix_matrix1_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NumericsMatrix *arg1 = (struct NumericsMatrix *) 0 ;
  SparseBlockStructuredMatrix *arg2 = (SparseBlockStructuredMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NumericsMatrix_matrix1_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsMatrix_matrix1_set" "', argument " "1"" of type '" "struct NumericsMatrix *""'"); 
  }
  arg1 = (struct NumericsMatrix *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SparseBlockStructuredMatrix, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NumericsMatrix_matrix1_set" "', argument " "2"" of type '" "SparseBlockStructuredMatrix *""'"); 
  }
  arg2 = (SparseBlockStructuredMatrix *)(argp2);
  if (arg1) (arg1)->matrix1 = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsMatrix_matrix1_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NumericsMatrix *arg1 = (struct NumericsMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SparseBlockStructuredMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NumericsMatrix_matrix1_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsMatrix_matrix1_get" "', argument " "1"" of type '" "struct NumericsMatrix *""'"); 
  }
  arg1 = (struct NumericsMatrix *)(argp1);
  result = (SparseBlockStructuredMatrix *) ((arg1)->matrix1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsMatrix_matrix2_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NumericsMatrix *arg1 = (struct NumericsMatrix *) 0 ;
  NumericsSparseMatrix *arg2 = (NumericsSparseMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NumericsMatrix_matrix2_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsMatrix_matrix2_set" "', argument " "1"" of type '" "struct NumericsMatrix *""'"); 
  }
  arg1 = (struct NumericsMatrix *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_NumericsSparseMatrix, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NumericsMatrix_matrix2_set" "', argument " "2"" of type '" "NumericsSparseMatrix *""'"); 
  }
  arg2 = (NumericsSparseMatrix *)(argp2);
  if (arg1) (arg1)->matrix2 = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsMatrix_matrix2_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NumericsMatrix *arg1 = (struct NumericsMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  NumericsSparseMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NumericsMatrix_matrix2_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsMatrix_matrix2_get" "', argument " "1"" of type '" "struct NumericsMatrix *""'"); 
  }
  arg1 = (struct NumericsMatrix *)(argp1);
  result = (NumericsSparseMatrix *) ((arg1)->matrix2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NumericsSparseMatrix, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsMatrix_internalData_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NumericsMatrix *arg1 = (struct NumericsMatrix *) 0 ;
  NumericsMatrixInternalData *arg2 = (NumericsMatrixInternalData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NumericsMatrix_internalData_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsMatrix_internalData_set" "', argument " "1"" of type '" "struct NumericsMatrix *""'"); 
  }
  arg1 = (struct NumericsMatrix *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_NumericsMatrixInternalData, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NumericsMatrix_internalData_set" "', argument " "2"" of type '" "NumericsMatrixInternalData *""'"); 
  }
  arg2 = (NumericsMatrixInternalData *)(argp2);
  if (arg1) (arg1)->internalData = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsMatrix_internalData_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NumericsMatrix *arg1 = (struct NumericsMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  NumericsMatrixInternalData *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NumericsMatrix_internalData_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsMatrix_internalData_get" "', argument " "1"" of type '" "struct NumericsMatrix *""'"); 
  }
  arg1 = (struct NumericsMatrix *)(argp1);
  result = (NumericsMatrixInternalData *) ((arg1)->internalData);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NumericsMatrixInternalData, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_NumericsMatrix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  PyObject * obj0 = 0 ;
  struct NumericsMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_NumericsMatrix",&obj0)) SWIG_fail;
  arg1 = obj0;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct NumericsMatrix *)new_NumericsMatrix(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NumericsMatrix, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsMatrix_set_matrix0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NumericsMatrix *arg1 = (struct NumericsMatrix *) 0 ;
  int arg2 ;
  int arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:NumericsMatrix_set_matrix0",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsMatrix_set_matrix0" "', argument " "1"" of type '" "struct NumericsMatrix *""'"); 
  }
  arg1 = (struct NumericsMatrix *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NumericsMatrix_set_matrix0" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "NumericsMatrix_set_matrix0" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_double(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "NumericsMatrix_set_matrix0" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NumericsMatrix_set_matrix0(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsMatrix_get_matrix0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NumericsMatrix *arg1 = (struct NumericsMatrix *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  double result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:NumericsMatrix_get_matrix0",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsMatrix_get_matrix0" "', argument " "1"" of type '" "struct NumericsMatrix *""'"); 
  }
  arg1 = (struct NumericsMatrix *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NumericsMatrix_get_matrix0" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "NumericsMatrix_get_matrix0" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (double)NumericsMatrix_get_matrix0(arg1,arg2,arg3);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_double((double)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsMatrix___setitem__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NumericsMatrix *arg1 = (struct NumericsMatrix *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:NumericsMatrix___setitem__",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsMatrix___setitem__" "', argument " "1"" of type '" "struct NumericsMatrix *""'"); 
  }
  arg1 = (struct NumericsMatrix *)(argp1);
  arg2 = obj1;
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "NumericsMatrix___setitem__" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (PyObject *)NumericsMatrix___setitem__(arg1,arg2,arg3);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsMatrix___getitem__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NumericsMatrix *arg1 = (struct NumericsMatrix *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NumericsMatrix___getitem__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsMatrix___getitem__" "', argument " "1"" of type '" "struct NumericsMatrix *""'"); 
  }
  arg1 = (struct NumericsMatrix *)(argp1);
  arg2 = obj1;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (PyObject *)NumericsMatrix___getitem__(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsMatrix___len__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NumericsMatrix *arg1 = (struct NumericsMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NumericsMatrix___len__",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsMatrix___len__" "', argument " "1"" of type '" "struct NumericsMatrix *""'"); 
  }
  arg1 = (struct NumericsMatrix *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)NumericsMatrix___len__(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_NumericsMatrix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NumericsMatrix *arg1 = (struct NumericsMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_NumericsMatrix",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsMatrix, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_NumericsMatrix" "', argument " "1"" of type '" "struct NumericsMatrix *""'"); 
  }
  arg1 = (struct NumericsMatrix *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        delete_NumericsMatrix(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *NumericsMatrix_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_NumericsMatrix, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_NM_new(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":NM_new")) SWIG_fail;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (NumericsMatrix *)NM_new();
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  {
    if (strcmp("NM_new", "new_NumericsMatrix"))
    {
      resultobj = NM_to_python(result);
      
      
      
      if (!resultobj) SWIG_fail;
    }
    else
    {
      resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NumericsMatrix, SWIG_POINTER_NEW |  0 );
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_eye(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  NumericsMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NM_eye",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "NM_eye" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (NumericsMatrix *)NM_eye(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  {
    if (strcmp("NM_eye", "new_NumericsMatrix"))
    {
      resultobj = NM_to_python(result);
      
      
      
      if (!resultobj) SWIG_fail;
    }
    else
    {
      resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NumericsMatrix, SWIG_POINTER_NEW |  0 );
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_create(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  NumericsMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:NM_create",&obj0,&obj1,&obj2)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "NM_create" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NM_create" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "NM_create" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (NumericsMatrix *)NM_create(arg1,arg2,arg3);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  {
    if (strcmp("NM_create", "new_NumericsMatrix"))
    {
      resultobj = NM_to_python(result);
      
      
      
      if (!resultobj) SWIG_fail;
    }
    else
    {
      resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NumericsMatrix, SWIG_POINTER_NEW |  0 );
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_create_from_data(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  int arg2 ;
  int arg3 ;
  void *arg4 = (void *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  NumericsMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:NM_create_from_data",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "NM_create_from_data" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NM_create_from_data" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "NM_create_from_data" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  res4 = SWIG_ConvertPtr(obj3,SWIG_as_voidptrptr(&arg4), 0, 0);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "NM_create_from_data" "', argument " "4"" of type '" "void *""'"); 
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (NumericsMatrix *)NM_create_from_data(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  {
    if (strcmp("NM_create_from_data", "new_NumericsMatrix"))
    {
      resultobj = NM_to_python(result);
      
      
      
      if (!resultobj) SWIG_fail;
    }
    else
    {
      resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NumericsMatrix, SWIG_POINTER_NEW |  0 );
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_create_from_filename(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  PyObject * obj0 = 0 ;
  NumericsMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NM_create_from_filename",&obj0)) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NM_create_from_filename" "', argument " "1"" of type '" "char *""'");
  }
  arg1 = (char *)(buf1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (NumericsMatrix *)NM_create_from_filename(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  {
    if (strcmp("NM_create_from_filename", "new_NumericsMatrix"))
    {
      resultobj = NM_to_python(result);
      
      
      
      if (!resultobj) SWIG_fail;
    }
    else
    {
      resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NumericsMatrix, SWIG_POINTER_NEW |  0 );
    }
  }
  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
  return resultobj;
fail:
  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_create_from_file(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FILE *arg1 = (FILE *) 0 ;
  PyObject * obj0 = 0 ;
  NumericsMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NM_create_from_file",&obj0)) SWIG_fail;
  {
    // %typemap(in) (FILE *file)
    int alloc = 1;
    char* cstr;
    int res = SWIG_AsCharPtrAndSize(obj0, &cstr, NULL, &alloc);
    if (!SWIG_IsOK(res)) {
      SWIG_Error(SWIG_ArgError(res), "in method unknown', argument " "1"" of type '" "char *""'");
    }
    arg1 = fopen(cstr, "r");
    if (!arg1)
    {
      SWIG_Error(SWIG_IOError, format_msg_concat("in method '" "NM_create_from_file" "' cannot fopen file", cstr));
      if (alloc == SWIG_NEWOBJ) free(cstr);
      SWIG_fail;
    }
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (NumericsMatrix *)NM_create_from_file(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  {
    if (strcmp("NM_create_from_file", "new_NumericsMatrix"))
    {
      resultobj = NM_to_python(result);
      
      
      
      if (!resultobj) SWIG_fail;
    }
    else
    {
      resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NumericsMatrix, SWIG_POINTER_NEW |  0 );
    }
  }
  {
    // %typemap(freearg) (FILE *file)
    if(arg1)
    {
      fclose(arg1);
    }
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (FILE *file)
    if(arg1)
    {
      fclose(arg1);
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_copy(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) (NumericsMatrix *)0 ;
  NumericsMatrix *arg2 = (NumericsMatrix *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyArrayObject *array_2 = NULL ;
  int array_ctrl_2 = 0 ;
  PyArrayObject *array_i_2 = NULL ;
  int array_i_ctrl_2 = 0 ;
  PyArrayObject *array_p_2 = NULL ;
  int array_p_ctrl_2 = 0 ;
  int alloc_ctrl_2 = 0 ;
  NumericsMatrix *nummat2 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NM_copy",&obj0,&obj1)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    arg2 = NM_convert_from_python(obj1, &nummat2, &array_2, &array_ctrl_2, &array_i_2, &array_i_ctrl_2, &array_p_2, &array_p_ctrl_2, &alloc_ctrl_2);
    
    
    
    
    
    if (!arg2) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_copy((NumericsMatrix const *)arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_copy_to_sparse(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) (NumericsMatrix *)0 ;
  NumericsMatrix *arg2 = (NumericsMatrix *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyArrayObject *array_2 = NULL ;
  int array_ctrl_2 = 0 ;
  PyArrayObject *array_i_2 = NULL ;
  int array_i_ctrl_2 = 0 ;
  PyArrayObject *array_p_2 = NULL ;
  int array_p_ctrl_2 = 0 ;
  int alloc_ctrl_2 = 0 ;
  NumericsMatrix *nummat2 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NM_copy_to_sparse",&obj0,&obj1)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    arg2 = NM_convert_from_python(obj1, &nummat2, &array_2, &array_ctrl_2, &array_i_2, &array_i_ctrl_2, &array_p_2, &array_p_ctrl_2, &alloc_ctrl_2);
    
    
    
    
    
    if (!arg2) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_copy_to_sparse((NumericsMatrix const *)arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_duplicate(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyObject * obj0 = 0 ;
  NumericsMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NM_duplicate",&obj0)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (NumericsMatrix *)NM_duplicate(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  {
    if (strcmp("NM_duplicate", "new_NumericsMatrix"))
    {
      resultobj = NM_to_python(result);
      
      
      
      if (!resultobj) SWIG_fail;
    }
    else
    {
      resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NumericsMatrix, SWIG_POINTER_NEW |  0 );
    }
  }
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_numericsSparseMatrix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyObject * obj0 = 0 ;
  NumericsSparseMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:numericsSparseMatrix",&obj0)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (NumericsSparseMatrix *)numericsSparseMatrix(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NumericsSparseMatrix, 0 |  0 );
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_triplet(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyObject * obj0 = 0 ;
  CSparseMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NM_triplet",&obj0)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (CSparseMatrix *)NM_triplet(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  {
    if (result->nz == -1)
    {
      resultobj = cs_sparse_to_csc_matrix(result, true);
    }
    else if (result->nz == -2)
    {
      resultobj = cs_sparse_to_csr_matrix(result, true);
    }
    else if (result->nz >= 0)
    {
      resultobj = cs_sparse_to_coo_matrix(result, true);
    }
    else
    {
      SWIG_exception_fail(SWIG_RuntimeError, "The given sparse matrix is of unknown type. Please file a bug");
    }
    
    
    
    
    
    
    if (!resultobj) {
      SWIG_fail; 
    }
  }
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_csc(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyObject * obj0 = 0 ;
  CSparseMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NM_csc",&obj0)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (CSparseMatrix *)NM_csc(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  {
    if (result->nz == -1)
    {
      resultobj = cs_sparse_to_csc_matrix(result, true);
    }
    else if (result->nz == -2)
    {
      resultobj = cs_sparse_to_csr_matrix(result, true);
    }
    else if (result->nz >= 0)
    {
      resultobj = cs_sparse_to_coo_matrix(result, true);
    }
    else
    {
      SWIG_exception_fail(SWIG_RuntimeError, "The given sparse matrix is of unknown type. Please file a bug");
    }
    
    
    
    
    
    
    if (!resultobj) {
      SWIG_fail; 
    }
  }
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_csc_trans(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyObject * obj0 = 0 ;
  CSparseMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NM_csc_trans",&obj0)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (CSparseMatrix *)NM_csc_trans(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  {
    if (result->nz == -1)
    {
      resultobj = cs_sparse_to_csc_matrix(result, true);
    }
    else if (result->nz == -2)
    {
      resultobj = cs_sparse_to_csr_matrix(result, true);
    }
    else if (result->nz >= 0)
    {
      resultobj = cs_sparse_to_coo_matrix(result, true);
    }
    else
    {
      SWIG_exception_fail(SWIG_RuntimeError, "The given sparse matrix is of unknown type. Please file a bug");
    }
    
    
    
    
    
    
    if (!resultobj) {
      SWIG_fail; 
    }
  }
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_csr(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyObject * obj0 = 0 ;
  CSparseMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NM_csr",&obj0)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (CSparseMatrix *)NM_csr(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  {
    if (result->nz == -1)
    {
      resultobj = cs_sparse_to_csc_matrix(result, true);
    }
    else if (result->nz == -2)
    {
      resultobj = cs_sparse_to_csr_matrix(result, true);
    }
    else if (result->nz >= 0)
    {
      resultobj = cs_sparse_to_coo_matrix(result, true);
    }
    else
    {
      SWIG_exception_fail(SWIG_RuntimeError, "The given sparse matrix is of unknown type. Please file a bug");
    }
    
    
    
    
    
    
    if (!resultobj) {
      SWIG_fail; 
    }
  }
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_fill(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  void *arg5 = (void *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:NM_fill",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NM_fill" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "NM_fill" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "NM_fill" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  res5 = SWIG_ConvertPtr(obj4,SWIG_as_voidptrptr(&arg5), 0, 0);
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "NM_fill" "', argument " "5"" of type '" "void *""'"); 
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_fill(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_new_SBM(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  int arg2 ;
  SparseBlockStructuredMatrix *arg3 = (SparseBlockStructuredMatrix *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  NumericsMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:NM_new_SBM",&obj0,&obj1,&obj2)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "NM_new_SBM" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NM_new_SBM" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "NM_new_SBM" "', argument " "3"" of type '" "SparseBlockStructuredMatrix *""'"); 
  }
  arg3 = (SparseBlockStructuredMatrix *)(argp3);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (NumericsMatrix *)NM_new_SBM(arg1,arg2,arg3);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  {
    if (strcmp("NM_new_SBM", "new_NumericsMatrix"))
    {
      resultobj = NM_to_python(result);
      
      
      
      if (!resultobj) SWIG_fail;
    }
    else
    {
      resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NumericsMatrix, SWIG_POINTER_NEW |  0 );
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_transpose(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyObject * obj0 = 0 ;
  NumericsMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NM_transpose",&obj0)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (NumericsMatrix *)NM_transpose(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  {
    if (strcmp("NM_transpose", "new_NumericsMatrix"))
    {
      resultobj = NM_to_python(result);
      
      
      
      if (!resultobj) SWIG_fail;
    }
    else
    {
      resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NumericsMatrix, SWIG_POINTER_NEW |  0 );
    }
  }
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_null(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NM_null",&obj0)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_null(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_update_size(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NM_update_size",&obj0)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_update_size(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_csc_alloc(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  long arg2 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  long val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NM_csc_alloc",&obj0,&obj1)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  ecode2 = SWIG_AsVal_long(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NM_csc_alloc" "', argument " "2"" of type '" "long""'");
  } 
  arg2 = (long)(val2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_csc_alloc(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_csc_empty_alloc(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  long arg2 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  long val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NM_csc_empty_alloc",&obj0,&obj1)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  ecode2 = SWIG_AsVal_long(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NM_csc_empty_alloc" "', argument " "2"" of type '" "long""'");
  } 
  arg2 = (long)(val2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_csc_empty_alloc(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_triplet_alloc(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  long arg2 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  long val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NM_triplet_alloc",&obj0,&obj1)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  ecode2 = SWIG_AsVal_long(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NM_triplet_alloc" "', argument " "2"" of type '" "long""'");
  } 
  arg2 = (long)(val2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_triplet_alloc(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_csr_alloc(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  long arg2 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  long val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NM_csr_alloc",&obj0,&obj1)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  ecode2 = SWIG_AsVal_long(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NM_csr_alloc" "', argument " "2"" of type '" "long""'");
  } 
  arg2 = (long)(val2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_csr_alloc(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_free(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NM_free",&obj0)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_free(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_zentry(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  int arg2 ;
  int arg3 ;
  double arg4 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:NM_zentry",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NM_zentry" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "NM_zentry" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_double(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "NM_zentry" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_zentry(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_get_value(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  int arg2 ;
  int arg3 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  double result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:NM_get_value",&obj0,&obj1,&obj2)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NM_get_value" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "NM_get_value" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (double)NM_get_value(arg1,arg2,arg3);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_double((double)(result));
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_equal(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  NumericsMatrix *arg2 = (NumericsMatrix *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyArrayObject *array_2 = NULL ;
  int array_ctrl_2 = 0 ;
  PyArrayObject *array_i_2 = NULL ;
  int array_i_ctrl_2 = 0 ;
  PyArrayObject *array_p_2 = NULL ;
  int array_p_ctrl_2 = 0 ;
  int alloc_ctrl_2 = 0 ;
  NumericsMatrix *nummat2 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NM_equal",&obj0,&obj1)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    arg2 = NM_convert_from_python(obj1, &nummat2, &array_2, &array_ctrl_2, &array_i_2, &array_i_ctrl_2, &array_p_2, &array_p_ctrl_2, &alloc_ctrl_2);
    
    
    
    
    
    if (!arg2) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (bool)NM_equal(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_bool((bool)(result));
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_compare(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  NumericsMatrix *arg2 = (NumericsMatrix *) 0 ;
  double arg3 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyArrayObject *array_2 = NULL ;
  int array_ctrl_2 = 0 ;
  PyArrayObject *array_i_2 = NULL ;
  int array_i_ctrl_2 = 0 ;
  PyArrayObject *array_p_2 = NULL ;
  int array_p_ctrl_2 = 0 ;
  int alloc_ctrl_2 = 0 ;
  NumericsMatrix *nummat2 = NULL ;
  double val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:NM_compare",&obj0,&obj1,&obj2)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    arg2 = NM_convert_from_python(obj1, &nummat2, &array_2, &array_ctrl_2, &array_i_2, &array_i_ctrl_2, &array_p_2, &array_p_ctrl_2, &alloc_ctrl_2);
    
    
    
    
    
    if (!arg2) {
      SWIG_fail; 
    }
  }
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "NM_compare" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (bool)NM_compare(arg1,arg2,arg3);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_bool((bool)(result));
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_nnz(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyObject * obj0 = 0 ;
  size_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NM_nnz",&obj0)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = NM_nnz((NumericsMatrix const *)arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_size_t((size_t)(result));
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_extract_diag_block(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  int arg2 ;
  size_t arg3 ;
  int arg4 ;
  double **arg5 = (double **) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  int val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:NM_extract_diag_block",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NM_extract_diag_block" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "NM_extract_diag_block" "', argument " "3"" of type '" "size_t""'");
  } 
  arg3 = (size_t)(val3);
  ecode4 = SWIG_AsVal_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "NM_extract_diag_block" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  res5 = SWIG_ConvertPtr(obj4, &argp5,SWIGTYPE_p_p_double, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "NM_extract_diag_block" "', argument " "5"" of type '" "double **""'"); 
  }
  arg5 = (double **)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_extract_diag_block(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_extract_diag_block3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  int arg2 ;
  double **arg3 = (double **) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:NM_extract_diag_block3",&obj0,&obj1,&obj2)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NM_extract_diag_block3" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "NM_extract_diag_block3" "', argument " "3"" of type '" "double **""'"); 
  }
  arg3 = (double **)(argp3);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_extract_diag_block3(arg1,arg2,arg3);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_copy_diag_block3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  int arg2 ;
  double **arg3 = (double **) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:NM_copy_diag_block3",&obj0,&obj1,&obj2)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NM_copy_diag_block3" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "NM_copy_diag_block3" "', argument " "3"" of type '" "double **""'"); 
  }
  arg3 = (double **)(argp3);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_copy_diag_block3(arg1,arg2,arg3);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_prod_mv_3x3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  int arg2 ;
  NumericsMatrix *arg3 = (NumericsMatrix *) 0 ;
  double *arg4 = (double *) (double *)0 ;
  double *arg5 = (double *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyArrayObject *array_3 = NULL ;
  int array_ctrl_3 = 0 ;
  PyArrayObject *array_i_3 = NULL ;
  int array_i_ctrl_3 = 0 ;
  PyArrayObject *array_p_3 = NULL ;
  int array_p_ctrl_3 = 0 ;
  int alloc_ctrl_3 = 0 ;
  NumericsMatrix *nummat3 = NULL ;
  PyArrayObject *array4 = NULL ;
  int is_new_object4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:NM_prod_mv_3x3",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "NM_prod_mv_3x3" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NM_prod_mv_3x3" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    arg3 = NM_convert_from_python(obj2, &nummat3, &array_3, &array_ctrl_3, &array_i_3, &array_i_ctrl_3, &array_p_3, &array_p_ctrl_3, &alloc_ctrl_3);
    
    
    
    
    
    if (!arg3) {
      SWIG_fail; 
    }
  }
  {
    array4 = obj_to_sn_vector(obj3, &is_new_object4);
    
    if (!array4)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array4))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg4 = (double *) array_data(array4);
    
  }
  res5 = SWIG_ConvertPtr(obj4, &argp5,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "NM_prod_mv_3x3" "', argument " "5"" of type '" "double *""'"); 
  }
  arg5 = (double *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_prod_mv_3x3(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_3 && array_3) {
      Py_DECREF(array_3); 
    };
    if(array_i_ctrl_3 && array_i_3) {
      Py_DECREF(array_i_3); 
    };
    if(array_p_ctrl_3 && array_p_3) {
      Py_DECREF(array_p_3); 
    };
    
    if (nummat3)
    {
      if (!NM_clean(nummat3, alloc_ctrl_3)) {
        return NULL; 
      }
      NM_free(nummat3);
      free(nummat3);
    }
    
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_3 && array_3) {
      Py_DECREF(array_3); 
    };
    if(array_i_ctrl_3 && array_i_3) {
      Py_DECREF(array_i_3); 
    };
    if(array_p_ctrl_3 && array_p_3) {
      Py_DECREF(array_p_3); 
    };
    
    if (nummat3)
    {
      if (!NM_clean(nummat3, alloc_ctrl_3)) {
        return NULL; 
      }
      NM_free(nummat3);
      free(nummat3);
    }
    
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_row_prod(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  int arg2 ;
  int arg3 ;
  NumericsMatrix *arg4 = (NumericsMatrix *) (NumericsMatrix *)0 ;
  double *arg5 = (double *) (double *)0 ;
  double *arg6 = (double *) 0 ;
  int arg7 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyArrayObject *array_4 = NULL ;
  int array_ctrl_4 = 0 ;
  PyArrayObject *array_i_4 = NULL ;
  int array_i_ctrl_4 = 0 ;
  PyArrayObject *array_p_4 = NULL ;
  int array_p_ctrl_4 = 0 ;
  int alloc_ctrl_4 = 0 ;
  NumericsMatrix *nummat4 = NULL ;
  PyArrayObject *array5 = NULL ;
  int is_new_object5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:NM_row_prod",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "NM_row_prod" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NM_row_prod" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "NM_row_prod" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    arg4 = NM_convert_from_python(obj3, &nummat4, &array_4, &array_ctrl_4, &array_i_4, &array_i_ctrl_4, &array_p_4, &array_p_ctrl_4, &alloc_ctrl_4);
    
    
    
    
    
    if (!arg4) {
      SWIG_fail; 
    }
  }
  {
    array5 = obj_to_sn_vector(obj4, &is_new_object5);
    
    if (!array5)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array5))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg5 = (double *) array_data(array5);
    
  }
  res6 = SWIG_ConvertPtr(obj5, &argp6,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "NM_row_prod" "', argument " "6"" of type '" "double *""'"); 
  }
  arg6 = (double *)(argp6);
  ecode7 = SWIG_AsVal_int(obj6, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "NM_row_prod" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_row_prod(arg1,arg2,arg3,(NumericsMatrix const *)arg4,(double const *)arg5,arg6,arg7);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_4 && array_4) {
      Py_DECREF(array_4); 
    };
    if(array_i_ctrl_4 && array_i_4) {
      Py_DECREF(array_i_4); 
    };
    if(array_p_ctrl_4 && array_p_4) {
      Py_DECREF(array_p_4); 
    };
    
    if (nummat4)
    {
      if (!NM_clean(nummat4, alloc_ctrl_4)) {
        return NULL; 
      }
      NM_free(nummat4);
      free(nummat4);
    }
    
  }
  {
    if(is_new_object5 && array5) {
      Py_DECREF(array5); 
    };
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_4 && array_4) {
      Py_DECREF(array_4); 
    };
    if(array_i_ctrl_4 && array_i_4) {
      Py_DECREF(array_i_4); 
    };
    if(array_p_ctrl_4 && array_p_4) {
      Py_DECREF(array_p_4); 
    };
    
    if (nummat4)
    {
      if (!NM_clean(nummat4, alloc_ctrl_4)) {
        return NULL; 
      }
      NM_free(nummat4);
      free(nummat4);
    }
    
  }
  {
    if(is_new_object5 && array5) {
      Py_DECREF(array5); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_row_prod_no_diag(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  size_t arg1 ;
  size_t arg2 ;
  int arg3 ;
  size_t arg4 ;
  NumericsMatrix *arg5 = (NumericsMatrix *) 0 ;
  double *arg6 = (double *) 0 ;
  double *arg7 = (double *) 0 ;
  double *arg8 = (double *) 0 ;
  bool arg9 ;
  size_t val1 ;
  int ecode1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  PyArrayObject *array_5 = NULL ;
  int array_ctrl_5 = 0 ;
  PyArrayObject *array_i_5 = NULL ;
  int array_i_ctrl_5 = 0 ;
  PyArrayObject *array_p_5 = NULL ;
  int array_p_ctrl_5 = 0 ;
  int alloc_ctrl_5 = 0 ;
  NumericsMatrix *nummat5 = NULL ;
  PyArrayObject *array6 = NULL ;
  int is_new_object6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  bool val9 ;
  int ecode9 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOOO:NM_row_prod_no_diag",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8)) SWIG_fail;
  ecode1 = SWIG_AsVal_size_t(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "NM_row_prod_no_diag" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = (size_t)(val1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NM_row_prod_no_diag" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = (size_t)(val2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "NM_row_prod_no_diag" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_size_t(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "NM_row_prod_no_diag" "', argument " "4"" of type '" "size_t""'");
  } 
  arg4 = (size_t)(val4);
  {
    arg5 = NM_convert_from_python(obj4, &nummat5, &array_5, &array_ctrl_5, &array_i_5, &array_i_ctrl_5, &array_p_5, &array_p_ctrl_5, &alloc_ctrl_5);
    
    
    
    
    
    if (!arg5) {
      SWIG_fail; 
    }
  }
  {
    array6 = obj_to_sn_vector(obj5, &is_new_object6);
    
    if (!array6)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array6))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg6 = (double *) array_data(array6);
    
  }
  res7 = SWIG_ConvertPtr(obj6, &argp7,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res7)) {
    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "NM_row_prod_no_diag" "', argument " "7"" of type '" "double *""'"); 
  }
  arg7 = (double *)(argp7);
  res8 = SWIG_ConvertPtr(obj7, &argp8,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res8)) {
    SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "NM_row_prod_no_diag" "', argument " "8"" of type '" "double *""'"); 
  }
  arg8 = (double *)(argp8);
  ecode9 = SWIG_AsVal_bool(obj8, &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "NM_row_prod_no_diag" "', argument " "9"" of type '" "bool""'");
  } 
  arg9 = (bool)(val9);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_row_prod_no_diag(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_5 && array_5) {
      Py_DECREF(array_5); 
    };
    if(array_i_ctrl_5 && array_i_5) {
      Py_DECREF(array_i_5); 
    };
    if(array_p_ctrl_5 && array_p_5) {
      Py_DECREF(array_p_5); 
    };
    
    if (nummat5)
    {
      if (!NM_clean(nummat5, alloc_ctrl_5)) {
        return NULL; 
      }
      NM_free(nummat5);
      free(nummat5);
    }
    
  }
  {
    if(is_new_object6 && array6) {
      Py_DECREF(array6); 
    };
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_5 && array_5) {
      Py_DECREF(array_5); 
    };
    if(array_i_ctrl_5 && array_i_5) {
      Py_DECREF(array_i_5); 
    };
    if(array_p_ctrl_5 && array_p_5) {
      Py_DECREF(array_p_5); 
    };
    
    if (nummat5)
    {
      if (!NM_clean(nummat5, alloc_ctrl_5)) {
        return NULL; 
      }
      NM_free(nummat5);
      free(nummat5);
    }
    
  }
  {
    if(is_new_object6 && array6) {
      Py_DECREF(array6); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_row_prod_no_diag3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  size_t arg1 ;
  int arg2 ;
  size_t arg3 ;
  NumericsMatrix *arg4 = (NumericsMatrix *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  bool arg7 ;
  size_t val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyArrayObject *array_4 = NULL ;
  int array_ctrl_4 = 0 ;
  PyArrayObject *array_i_4 = NULL ;
  int array_i_ctrl_4 = 0 ;
  PyArrayObject *array_p_4 = NULL ;
  int array_p_ctrl_4 = 0 ;
  int alloc_ctrl_4 = 0 ;
  NumericsMatrix *nummat4 = NULL ;
  PyArrayObject *array5 = NULL ;
  int is_new_object5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  bool val7 ;
  int ecode7 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:NM_row_prod_no_diag3",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
  ecode1 = SWIG_AsVal_size_t(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "NM_row_prod_no_diag3" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = (size_t)(val1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NM_row_prod_no_diag3" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "NM_row_prod_no_diag3" "', argument " "3"" of type '" "size_t""'");
  } 
  arg3 = (size_t)(val3);
  {
    arg4 = NM_convert_from_python(obj3, &nummat4, &array_4, &array_ctrl_4, &array_i_4, &array_i_ctrl_4, &array_p_4, &array_p_ctrl_4, &alloc_ctrl_4);
    
    
    
    
    
    if (!arg4) {
      SWIG_fail; 
    }
  }
  {
    array5 = obj_to_sn_vector(obj4, &is_new_object5);
    
    if (!array5)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array5))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg5 = (double *) array_data(array5);
    
  }
  res6 = SWIG_ConvertPtr(obj5, &argp6,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "NM_row_prod_no_diag3" "', argument " "6"" of type '" "double *""'"); 
  }
  arg6 = (double *)(argp6);
  ecode7 = SWIG_AsVal_bool(obj6, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "NM_row_prod_no_diag3" "', argument " "7"" of type '" "bool""'");
  } 
  arg7 = (bool)(val7);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_row_prod_no_diag3(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_4 && array_4) {
      Py_DECREF(array_4); 
    };
    if(array_i_ctrl_4 && array_i_4) {
      Py_DECREF(array_i_4); 
    };
    if(array_p_ctrl_4 && array_p_4) {
      Py_DECREF(array_p_4); 
    };
    
    if (nummat4)
    {
      if (!NM_clean(nummat4, alloc_ctrl_4)) {
        return NULL; 
      }
      NM_free(nummat4);
      free(nummat4);
    }
    
  }
  {
    if(is_new_object5 && array5) {
      Py_DECREF(array5); 
    };
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_4 && array_4) {
      Py_DECREF(array_4); 
    };
    if(array_i_ctrl_4 && array_i_4) {
      Py_DECREF(array_i_4); 
    };
    if(array_p_ctrl_4 && array_p_4) {
      Py_DECREF(array_p_4); 
    };
    
    if (nummat4)
    {
      if (!NM_clean(nummat4, alloc_ctrl_4)) {
        return NULL; 
      }
      NM_free(nummat4);
      free(nummat4);
    }
    
  }
  {
    if(is_new_object5 && array5) {
      Py_DECREF(array5); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_row_prod_no_diag1x1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  size_t arg1 ;
  int arg2 ;
  size_t arg3 ;
  NumericsMatrix *arg4 = (NumericsMatrix *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  bool arg7 ;
  size_t val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyArrayObject *array_4 = NULL ;
  int array_ctrl_4 = 0 ;
  PyArrayObject *array_i_4 = NULL ;
  int array_i_ctrl_4 = 0 ;
  PyArrayObject *array_p_4 = NULL ;
  int array_p_ctrl_4 = 0 ;
  int alloc_ctrl_4 = 0 ;
  NumericsMatrix *nummat4 = NULL ;
  PyArrayObject *array5 = NULL ;
  int is_new_object5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  bool val7 ;
  int ecode7 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:NM_row_prod_no_diag1x1",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
  ecode1 = SWIG_AsVal_size_t(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "NM_row_prod_no_diag1x1" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = (size_t)(val1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NM_row_prod_no_diag1x1" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "NM_row_prod_no_diag1x1" "', argument " "3"" of type '" "size_t""'");
  } 
  arg3 = (size_t)(val3);
  {
    arg4 = NM_convert_from_python(obj3, &nummat4, &array_4, &array_ctrl_4, &array_i_4, &array_i_ctrl_4, &array_p_4, &array_p_ctrl_4, &alloc_ctrl_4);
    
    
    
    
    
    if (!arg4) {
      SWIG_fail; 
    }
  }
  {
    array5 = obj_to_sn_vector(obj4, &is_new_object5);
    
    if (!array5)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array5))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg5 = (double *) array_data(array5);
    
  }
  res6 = SWIG_ConvertPtr(obj5, &argp6,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "NM_row_prod_no_diag1x1" "', argument " "6"" of type '" "double *""'"); 
  }
  arg6 = (double *)(argp6);
  ecode7 = SWIG_AsVal_bool(obj6, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "NM_row_prod_no_diag1x1" "', argument " "7"" of type '" "bool""'");
  } 
  arg7 = (bool)(val7);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_row_prod_no_diag1x1(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_4 && array_4) {
      Py_DECREF(array_4); 
    };
    if(array_i_ctrl_4 && array_i_4) {
      Py_DECREF(array_i_4); 
    };
    if(array_p_ctrl_4 && array_p_4) {
      Py_DECREF(array_p_4); 
    };
    
    if (nummat4)
    {
      if (!NM_clean(nummat4, alloc_ctrl_4)) {
        return NULL; 
      }
      NM_free(nummat4);
      free(nummat4);
    }
    
  }
  {
    if(is_new_object5 && array5) {
      Py_DECREF(array5); 
    };
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_4 && array_4) {
      Py_DECREF(array_4); 
    };
    if(array_i_ctrl_4 && array_i_4) {
      Py_DECREF(array_i_4); 
    };
    if(array_p_ctrl_4 && array_p_4) {
      Py_DECREF(array_p_4); 
    };
    
    if (nummat4)
    {
      if (!NM_clean(nummat4, alloc_ctrl_4)) {
        return NULL; 
      }
      NM_free(nummat4);
      free(nummat4);
    }
    
  }
  {
    if(is_new_object5 && array5) {
      Py_DECREF(array5); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_gemv(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  double arg1 ;
  NumericsMatrix *arg2 = (NumericsMatrix *) 0 ;
  double *arg3 = (double *) 0 ;
  double arg4 ;
  double *arg5 = (double *) 0 ;
  double val1 ;
  int ecode1 = 0 ;
  PyArrayObject *array_2 = NULL ;
  int array_ctrl_2 = 0 ;
  PyArrayObject *array_i_2 = NULL ;
  int array_i_ctrl_2 = 0 ;
  PyArrayObject *array_p_2 = NULL ;
  int array_p_ctrl_2 = 0 ;
  int alloc_ctrl_2 = 0 ;
  NumericsMatrix *nummat2 = NULL ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:NM_gemv",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  ecode1 = SWIG_AsVal_double(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "NM_gemv" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = (double)(val1);
  {
    arg2 = NM_convert_from_python(obj1, &nummat2, &array_2, &array_ctrl_2, &array_i_2, &array_i_ctrl_2, &array_p_2, &array_p_ctrl_2, &alloc_ctrl_2);
    
    
    
    
    
    if (!arg2) {
      SWIG_fail; 
    }
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  ecode4 = SWIG_AsVal_double(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "NM_gemv" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  res5 = SWIG_ConvertPtr(obj4, &argp5,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "NM_gemv" "', argument " "5"" of type '" "double *""'"); 
  }
  arg5 = (double *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_gemv(arg1,arg2,(double const *)arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_gemm(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  double arg1 ;
  NumericsMatrix *arg2 = (NumericsMatrix *) 0 ;
  NumericsMatrix *arg3 = (NumericsMatrix *) 0 ;
  double arg4 ;
  NumericsMatrix *arg5 = (NumericsMatrix *) 0 ;
  double val1 ;
  int ecode1 = 0 ;
  PyArrayObject *array_2 = NULL ;
  int array_ctrl_2 = 0 ;
  PyArrayObject *array_i_2 = NULL ;
  int array_i_ctrl_2 = 0 ;
  PyArrayObject *array_p_2 = NULL ;
  int array_p_ctrl_2 = 0 ;
  int alloc_ctrl_2 = 0 ;
  NumericsMatrix *nummat2 = NULL ;
  PyArrayObject *array_3 = NULL ;
  int array_ctrl_3 = 0 ;
  PyArrayObject *array_i_3 = NULL ;
  int array_i_ctrl_3 = 0 ;
  PyArrayObject *array_p_3 = NULL ;
  int array_p_ctrl_3 = 0 ;
  int alloc_ctrl_3 = 0 ;
  NumericsMatrix *nummat3 = NULL ;
  double val4 ;
  int ecode4 = 0 ;
  PyArrayObject *array_5 = NULL ;
  int array_ctrl_5 = 0 ;
  PyArrayObject *array_i_5 = NULL ;
  int array_i_ctrl_5 = 0 ;
  PyArrayObject *array_p_5 = NULL ;
  int array_p_ctrl_5 = 0 ;
  int alloc_ctrl_5 = 0 ;
  NumericsMatrix *nummat5 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:NM_gemm",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  ecode1 = SWIG_AsVal_double(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "NM_gemm" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = (double)(val1);
  {
    arg2 = NM_convert_from_python(obj1, &nummat2, &array_2, &array_ctrl_2, &array_i_2, &array_i_ctrl_2, &array_p_2, &array_p_ctrl_2, &alloc_ctrl_2);
    
    
    
    
    
    if (!arg2) {
      SWIG_fail; 
    }
  }
  {
    arg3 = NM_convert_from_python(obj2, &nummat3, &array_3, &array_ctrl_3, &array_i_3, &array_i_ctrl_3, &array_p_3, &array_p_ctrl_3, &alloc_ctrl_3);
    
    
    
    
    
    if (!arg3) {
      SWIG_fail; 
    }
  }
  ecode4 = SWIG_AsVal_double(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "NM_gemm" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  {
    arg5 = NM_convert_from_python(obj4, &nummat5, &array_5, &array_ctrl_5, &array_i_5, &array_i_ctrl_5, &array_p_5, &array_p_ctrl_5, &alloc_ctrl_5);
    
    
    
    
    
    if (!arg5) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_gemm(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_3 && array_3) {
      Py_DECREF(array_3); 
    };
    if(array_i_ctrl_3 && array_i_3) {
      Py_DECREF(array_i_3); 
    };
    if(array_p_ctrl_3 && array_p_3) {
      Py_DECREF(array_p_3); 
    };
    
    if (nummat3)
    {
      if (!NM_clean(nummat3, alloc_ctrl_3)) {
        return NULL; 
      }
      NM_free(nummat3);
      free(nummat3);
    }
    
  }
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_5 && array_5) {
      Py_DECREF(array_5); 
    };
    if(array_i_ctrl_5 && array_i_5) {
      Py_DECREF(array_i_5); 
    };
    if(array_p_ctrl_5 && array_p_5) {
      Py_DECREF(array_p_5); 
    };
    
    if (nummat5)
    {
      if (!NM_clean(nummat5, alloc_ctrl_5)) {
        return NULL; 
      }
      NM_free(nummat5);
      free(nummat5);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_3 && array_3) {
      Py_DECREF(array_3); 
    };
    if(array_i_ctrl_3 && array_i_3) {
      Py_DECREF(array_i_3); 
    };
    if(array_p_ctrl_3 && array_p_3) {
      Py_DECREF(array_p_3); 
    };
    
    if (nummat3)
    {
      if (!NM_clean(nummat3, alloc_ctrl_3)) {
        return NULL; 
      }
      NM_free(nummat3);
      free(nummat3);
    }
    
  }
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_5 && array_5) {
      Py_DECREF(array_5); 
    };
    if(array_i_ctrl_5 && array_i_5) {
      Py_DECREF(array_i_5); 
    };
    if(array_p_ctrl_5 && array_p_5) {
      Py_DECREF(array_p_5); 
    };
    
    if (nummat5)
    {
      if (!NM_clean(nummat5, alloc_ctrl_5)) {
        return NULL; 
      }
      NM_free(nummat5);
      free(nummat5);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_multiply(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  NumericsMatrix *arg2 = (NumericsMatrix *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyArrayObject *array_2 = NULL ;
  int array_ctrl_2 = 0 ;
  PyArrayObject *array_i_2 = NULL ;
  int array_i_ctrl_2 = 0 ;
  PyArrayObject *array_p_2 = NULL ;
  int array_p_ctrl_2 = 0 ;
  int alloc_ctrl_2 = 0 ;
  NumericsMatrix *nummat2 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  NumericsMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NM_multiply",&obj0,&obj1)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    arg2 = NM_convert_from_python(obj1, &nummat2, &array_2, &array_ctrl_2, &array_i_2, &array_i_ctrl_2, &array_p_2, &array_p_ctrl_2, &alloc_ctrl_2);
    
    
    
    
    
    if (!arg2) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (NumericsMatrix *)NM_multiply(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  {
    if (strcmp("NM_multiply", "new_NumericsMatrix"))
    {
      resultobj = NM_to_python(result);
      
      
      
      if (!resultobj) SWIG_fail;
    }
    else
    {
      resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NumericsMatrix, SWIG_POINTER_NEW |  0 );
    }
  }
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_tgemv(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  double arg1 ;
  NumericsMatrix *arg2 = (NumericsMatrix *) 0 ;
  double *arg3 = (double *) 0 ;
  double arg4 ;
  double *arg5 = (double *) 0 ;
  double val1 ;
  int ecode1 = 0 ;
  PyArrayObject *array_2 = NULL ;
  int array_ctrl_2 = 0 ;
  PyArrayObject *array_i_2 = NULL ;
  int array_i_ctrl_2 = 0 ;
  PyArrayObject *array_p_2 = NULL ;
  int array_p_ctrl_2 = 0 ;
  int alloc_ctrl_2 = 0 ;
  NumericsMatrix *nummat2 = NULL ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:NM_tgemv",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  ecode1 = SWIG_AsVal_double(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "NM_tgemv" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = (double)(val1);
  {
    arg2 = NM_convert_from_python(obj1, &nummat2, &array_2, &array_ctrl_2, &array_i_2, &array_i_ctrl_2, &array_p_2, &array_p_ctrl_2, &alloc_ctrl_2);
    
    
    
    
    
    if (!arg2) {
      SWIG_fail; 
    }
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  ecode4 = SWIG_AsVal_double(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "NM_tgemv" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  res5 = SWIG_ConvertPtr(obj4, &argp5,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "NM_tgemv" "', argument " "5"" of type '" "double *""'"); 
  }
  arg5 = (double *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_tgemv(arg1,arg2,(double const *)arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_dense_to_sparse(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) (NumericsMatrix *)0 ;
  NumericsMatrix *arg2 = (NumericsMatrix *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyArrayObject *array_2 = NULL ;
  int array_ctrl_2 = 0 ;
  PyArrayObject *array_i_2 = NULL ;
  int array_i_ctrl_2 = 0 ;
  PyArrayObject *array_p_2 = NULL ;
  int array_p_ctrl_2 = 0 ;
  int alloc_ctrl_2 = 0 ;
  NumericsMatrix *nummat2 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NM_dense_to_sparse",&obj0,&obj1)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    arg2 = NM_convert_from_python(obj1, &nummat2, &array_2, &array_ctrl_2, &array_i_2, &array_i_ctrl_2, &array_p_2, &array_p_ctrl_2, &alloc_ctrl_2);
    
    
    
    
    
    if (!arg2) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_dense_to_sparse((NumericsMatrix const *)arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_to_dense(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) (NumericsMatrix *)0 ;
  NumericsMatrix *arg2 = (NumericsMatrix *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyArrayObject *array_2 = NULL ;
  int array_ctrl_2 = 0 ;
  PyArrayObject *array_i_2 = NULL ;
  int array_i_ctrl_2 = 0 ;
  PyArrayObject *array_p_2 = NULL ;
  int array_p_ctrl_2 = 0 ;
  int alloc_ctrl_2 = 0 ;
  NumericsMatrix *nummat2 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NM_to_dense",&obj0,&obj1)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    arg2 = NM_convert_from_python(obj1, &nummat2, &array_2, &array_ctrl_2, &array_i_2, &array_i_ctrl_2, &array_p_2, &array_p_ctrl_2, &alloc_ctrl_2);
    
    
    
    
    
    if (!arg2) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)NM_to_dense((NumericsMatrix const *)arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_dense_display_matlab(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  double *arg1 = (double *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:NM_dense_display_matlab",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NM_dense_display_matlab" "', argument " "1"" of type '" "double *""'"); 
  }
  arg1 = (double *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NM_dense_display_matlab" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "NM_dense_display_matlab" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "NM_dense_display_matlab" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_dense_display_matlab(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_dense_display(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  double *arg1 = (double *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:NM_dense_display",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NM_dense_display" "', argument " "1"" of type '" "double *""'"); 
  }
  arg1 = (double *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NM_dense_display" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "NM_dense_display" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "NM_dense_display" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_dense_display(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_vector_display(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  double *arg1 = (double *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NM_vector_display",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NM_vector_display" "', argument " "1"" of type '" "double *""'"); 
  }
  arg1 = (double *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NM_vector_display" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_vector_display(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_display(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) (NumericsMatrix *)0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NM_display",&obj0)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_display((NumericsMatrix const *)arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_display_row_by_row(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) (NumericsMatrix *)0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NM_display_row_by_row",&obj0)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_display_row_by_row((NumericsMatrix const *)arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_write_in_filename(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) (NumericsMatrix *)0 ;
  char *arg2 = (char *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NM_write_in_filename",&obj0,&obj1)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NM_write_in_filename" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_write_in_filename((NumericsMatrix const *)arg1,(char const *)arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_read_in_filename(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) (NumericsMatrix *)0 ;
  char *arg2 = (char *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NM_read_in_filename",&obj0,&obj1)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NM_read_in_filename" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_read_in_filename(arg1,(char const *)arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_write_in_file(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) (NumericsMatrix *)0 ;
  FILE *arg2 = (FILE *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NM_write_in_file",&obj0,&obj1)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    // %typemap(in) (FILE *file)
    int alloc = 1;
    char* cstr;
    int res = SWIG_AsCharPtrAndSize(obj1, &cstr, NULL, &alloc);
    if (!SWIG_IsOK(res)) {
      SWIG_Error(SWIG_ArgError(res), "in method unknown', argument " "1"" of type '" "char *""'");
    }
    arg2 = fopen(cstr, "r");
    if (!arg2)
    {
      SWIG_Error(SWIG_IOError, format_msg_concat("in method '" "NM_write_in_file" "' cannot fopen file", cstr));
      if (alloc == SWIG_NEWOBJ) free(cstr);
      SWIG_fail;
    }
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_write_in_file((NumericsMatrix const *)arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_read_in_file(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) (NumericsMatrix *)0 ;
  FILE *arg2 = (FILE *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NM_read_in_file",&obj0,&obj1)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    // %typemap(in) (FILE *file)
    int alloc = 1;
    char* cstr;
    int res = SWIG_AsCharPtrAndSize(obj1, &cstr, NULL, &alloc);
    if (!SWIG_IsOK(res)) {
      SWIG_Error(SWIG_ArgError(res), "in method unknown', argument " "1"" of type '" "char *""'");
    }
    arg2 = fopen(cstr, "r");
    if (!arg2)
    {
      SWIG_Error(SWIG_IOError, format_msg_concat("in method '" "NM_read_in_file" "' cannot fopen file", cstr));
      if (alloc == SWIG_NEWOBJ) free(cstr);
      SWIG_fail;
    }
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_read_in_file(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_new_from_file(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FILE *arg1 = (FILE *) 0 ;
  PyObject * obj0 = 0 ;
  NumericsMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NM_new_from_file",&obj0)) SWIG_fail;
  {
    // %typemap(in) (FILE *file)
    int alloc = 1;
    char* cstr;
    int res = SWIG_AsCharPtrAndSize(obj0, &cstr, NULL, &alloc);
    if (!SWIG_IsOK(res)) {
      SWIG_Error(SWIG_ArgError(res), "in method unknown', argument " "1"" of type '" "char *""'");
    }
    arg1 = fopen(cstr, "r");
    if (!arg1)
    {
      SWIG_Error(SWIG_IOError, format_msg_concat("in method '" "NM_new_from_file" "' cannot fopen file", cstr));
      if (alloc == SWIG_NEWOBJ) free(cstr);
      SWIG_fail;
    }
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (NumericsMatrix *)NM_new_from_file(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  {
    if (strcmp("NM_new_from_file", "new_NumericsMatrix"))
    {
      resultobj = NM_to_python(result);
      
      
      
      if (!resultobj) SWIG_fail;
    }
    else
    {
      resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NumericsMatrix, SWIG_POINTER_NEW |  0 );
    }
  }
  {
    // %typemap(freearg) (FILE *file)
    if(arg1)
    {
      fclose(arg1);
    }
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (FILE *file)
    if(arg1)
    {
      fclose(arg1);
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_new_from_filename(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  PyObject * obj0 = 0 ;
  NumericsMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NM_new_from_filename",&obj0)) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NM_new_from_filename" "', argument " "1"" of type '" "char *""'");
  }
  arg1 = (char *)(buf1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (NumericsMatrix *)NM_new_from_filename(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  {
    if (strcmp("NM_new_from_filename", "new_NumericsMatrix"))
    {
      resultobj = NM_to_python(result);
      
      
      
      if (!resultobj) SWIG_fail;
    }
    else
    {
      resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NumericsMatrix, SWIG_POINTER_NEW |  0 );
    }
  }
  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
  return resultobj;
fail:
  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_write_in_file_scilab(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) (NumericsMatrix *)0 ;
  FILE *arg2 = (FILE *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NM_write_in_file_scilab",&obj0,&obj1)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    // %typemap(in) (FILE *file)
    int alloc = 1;
    char* cstr;
    int res = SWIG_AsCharPtrAndSize(obj1, &cstr, NULL, &alloc);
    if (!SWIG_IsOK(res)) {
      SWIG_Error(SWIG_ArgError(res), "in method unknown', argument " "1"" of type '" "char *""'");
    }
    arg2 = fopen(cstr, "r");
    if (!arg2)
    {
      SWIG_Error(SWIG_IOError, format_msg_concat("in method '" "NM_write_in_file_scilab" "' cannot fopen file", cstr));
      if (alloc == SWIG_NEWOBJ) free(cstr);
      SWIG_fail;
    }
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_write_in_file_scilab((NumericsMatrix const *)arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_write_in_file_python(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) (NumericsMatrix *)0 ;
  FILE *arg2 = (FILE *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NM_write_in_file_python",&obj0,&obj1)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    // %typemap(in) (FILE *file)
    int alloc = 1;
    char* cstr;
    int res = SWIG_AsCharPtrAndSize(obj1, &cstr, NULL, &alloc);
    if (!SWIG_IsOK(res)) {
      SWIG_Error(SWIG_ArgError(res), "in method unknown', argument " "1"" of type '" "char *""'");
    }
    arg2 = fopen(cstr, "r");
    if (!arg2)
    {
      SWIG_Error(SWIG_IOError, format_msg_concat("in method '" "NM_write_in_file_python" "' cannot fopen file", cstr));
      if (alloc == SWIG_NEWOBJ) free(cstr);
      SWIG_fail;
    }
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_write_in_file_python((NumericsMatrix const *)arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_read_in_file_scilab(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) (NumericsMatrix *)0 ;
  FILE *arg2 = (FILE *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NM_read_in_file_scilab",&obj0,&obj1)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    // %typemap(in) (FILE *file)
    int alloc = 1;
    char* cstr;
    int res = SWIG_AsCharPtrAndSize(obj1, &cstr, NULL, &alloc);
    if (!SWIG_IsOK(res)) {
      SWIG_Error(SWIG_ArgError(res), "in method unknown', argument " "1"" of type '" "char *""'");
    }
    arg2 = fopen(cstr, "r");
    if (!arg2)
    {
      SWIG_Error(SWIG_IOError, format_msg_concat("in method '" "NM_read_in_file_scilab" "' cannot fopen file", cstr));
      if (alloc == SWIG_NEWOBJ) free(cstr);
      SWIG_fail;
    }
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_read_in_file_scilab(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_clearDense(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NM_clearDense",&obj0)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_clearDense(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_clearSparseBlock(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NM_clearSparseBlock",&obj0)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_clearSparseBlock(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_clearSparse(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NM_clearSparse",&obj0)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_clearSparse(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_clearTriplet(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NM_clearTriplet",&obj0)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_clearTriplet(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_clearCSC(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NM_clearCSC",&obj0)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_clearCSC(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_clearCSCTranspose(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NM_clearCSCTranspose",&obj0)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_clearCSCTranspose(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_clearCSR(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NM_clearCSR",&obj0)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_clearCSR(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_clearSparseStorage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NM_clearSparseStorage",&obj0)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_clearSparseStorage(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_gesv_expert(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  double *arg2 = (double *) 0 ;
  unsigned int arg3 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:NM_gesv_expert",&obj0,&obj1,&obj2)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "NM_gesv_expert" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)NM_gesv_expert(arg1,arg2,arg3);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_gesv_expert_multiple_rhs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  double *arg2 = (double *) 0 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:NM_gesv_expert_multiple_rhs",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "NM_gesv_expert_multiple_rhs" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "NM_gesv_expert_multiple_rhs" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = (unsigned int)(val4);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)NM_gesv_expert_multiple_rhs(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_inv(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  NumericsMatrix *arg2 = (NumericsMatrix *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyArrayObject *array_2 = NULL ;
  int array_ctrl_2 = 0 ;
  PyArrayObject *array_i_2 = NULL ;
  int array_i_ctrl_2 = 0 ;
  PyArrayObject *array_p_2 = NULL ;
  int array_p_ctrl_2 = 0 ;
  int alloc_ctrl_2 = 0 ;
  NumericsMatrix *nummat2 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NM_inv",&obj0,&obj1)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    arg2 = NM_convert_from_python(obj1, &nummat2, &array_2, &array_ctrl_2, &array_i_2, &array_i_ctrl_2, &array_p_2, &array_p_ctrl_2, &alloc_ctrl_2);
    
    
    
    
    
    if (!arg2) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)NM_inv(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_inverse_diagonal_block_matrix_in_place(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NM_inverse_diagonal_block_matrix_in_place",&obj0)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)NM_inverse_diagonal_block_matrix_in_place(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_gesv(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  double *arg2 = (double *) 0 ;
  bool arg3 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:NM_gesv",&obj0,&obj1,&obj2)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  ecode3 = SWIG_AsVal_bool(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "NM_gesv" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = (bool)(val3);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)NM_gesv(arg1,arg2,arg3);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_setSparseSolver(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  unsigned int arg2 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NM_setSparseSolver",&obj0,&obj1)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NM_setSparseSolver" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_setSparseSolver(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_internalData(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyObject * obj0 = 0 ;
  NumericsMatrixInternalData *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NM_internalData",&obj0)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (NumericsMatrixInternalData *)NM_internalData(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NumericsMatrixInternalData, 0 |  0 );
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_internalData_new(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NM_internalData_new",&obj0)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_internalData_new(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_internalData_copy(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) (NumericsMatrix *)0 ;
  NumericsMatrix *arg2 = (NumericsMatrix *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyArrayObject *array_2 = NULL ;
  int array_ctrl_2 = 0 ;
  PyArrayObject *array_i_2 = NULL ;
  int array_i_ctrl_2 = 0 ;
  PyArrayObject *array_p_2 = NULL ;
  int array_p_ctrl_2 = 0 ;
  int alloc_ctrl_2 = 0 ;
  NumericsMatrix *nummat2 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NM_internalData_copy",&obj0,&obj1)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    arg2 = NM_convert_from_python(obj1, &nummat2, &array_2, &array_ctrl_2, &array_i_2, &array_i_ctrl_2, &array_p_2, &array_p_ctrl_2, &alloc_ctrl_2);
    
    
    
    
    
    if (!arg2) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_internalData_copy((NumericsMatrix const *)arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_iWork(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  void *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:NM_iWork",&obj0,&obj1,&obj2)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NM_iWork" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = (size_t)(val2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "NM_iWork" "', argument " "3"" of type '" "size_t""'");
  } 
  arg3 = (size_t)(val3);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (void *)NM_iWork(arg1,arg2,arg3);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_dWork(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  int arg2 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  double *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NM_dWork",&obj0,&obj1)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NM_dWork" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (double *)NM_dWork(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_add_to_diag3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  double arg2 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NM_add_to_diag3",&obj0,&obj1)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NM_add_to_diag3" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_add_to_diag3(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_add(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  double arg1 ;
  NumericsMatrix *arg2 = (NumericsMatrix *) 0 ;
  double arg3 ;
  NumericsMatrix *arg4 = (NumericsMatrix *) 0 ;
  double val1 ;
  int ecode1 = 0 ;
  PyArrayObject *array_2 = NULL ;
  int array_ctrl_2 = 0 ;
  PyArrayObject *array_i_2 = NULL ;
  int array_i_ctrl_2 = 0 ;
  PyArrayObject *array_p_2 = NULL ;
  int array_p_ctrl_2 = 0 ;
  int alloc_ctrl_2 = 0 ;
  NumericsMatrix *nummat2 = NULL ;
  double val3 ;
  int ecode3 = 0 ;
  PyArrayObject *array_4 = NULL ;
  int array_ctrl_4 = 0 ;
  PyArrayObject *array_i_4 = NULL ;
  int array_i_ctrl_4 = 0 ;
  PyArrayObject *array_p_4 = NULL ;
  int array_p_ctrl_4 = 0 ;
  int alloc_ctrl_4 = 0 ;
  NumericsMatrix *nummat4 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  NumericsMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:NM_add",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  ecode1 = SWIG_AsVal_double(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "NM_add" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = (double)(val1);
  {
    arg2 = NM_convert_from_python(obj1, &nummat2, &array_2, &array_ctrl_2, &array_i_2, &array_i_ctrl_2, &array_p_2, &array_p_ctrl_2, &alloc_ctrl_2);
    
    
    
    
    
    if (!arg2) {
      SWIG_fail; 
    }
  }
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "NM_add" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    arg4 = NM_convert_from_python(obj3, &nummat4, &array_4, &array_ctrl_4, &array_i_4, &array_i_ctrl_4, &array_p_4, &array_p_ctrl_4, &alloc_ctrl_4);
    
    
    
    
    
    if (!arg4) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (NumericsMatrix *)NM_add(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  {
    if (strcmp("NM_add", "new_NumericsMatrix"))
    {
      resultobj = NM_to_python(result);
      
      
      
      if (!resultobj) SWIG_fail;
    }
    else
    {
      resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NumericsMatrix, SWIG_POINTER_NEW |  0 );
    }
  }
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_4 && array_4) {
      Py_DECREF(array_4); 
    };
    if(array_i_ctrl_4 && array_i_4) {
      Py_DECREF(array_i_4); 
    };
    if(array_p_ctrl_4 && array_p_4) {
      Py_DECREF(array_p_4); 
    };
    
    if (nummat4)
    {
      if (!NM_clean(nummat4, alloc_ctrl_4)) {
        return NULL; 
      }
      NM_free(nummat4);
      free(nummat4);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_4 && array_4) {
      Py_DECREF(array_4); 
    };
    if(array_i_ctrl_4 && array_i_4) {
      Py_DECREF(array_i_4); 
    };
    if(array_p_ctrl_4 && array_p_4) {
      Py_DECREF(array_p_4); 
    };
    
    if (nummat4)
    {
      if (!NM_clean(nummat4, alloc_ctrl_4)) {
        return NULL; 
      }
      NM_free(nummat4);
      free(nummat4);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_assert(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  NumericsMatrix *arg2 = (NumericsMatrix *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  PyArrayObject *array_2 = NULL ;
  int array_ctrl_2 = 0 ;
  PyArrayObject *array_i_2 = NULL ;
  int array_i_ctrl_2 = 0 ;
  PyArrayObject *array_p_2 = NULL ;
  int array_p_ctrl_2 = 0 ;
  int alloc_ctrl_2 = 0 ;
  NumericsMatrix *nummat2 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NM_assert",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "NM_assert" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  {
    arg2 = NM_convert_from_python(obj1, &nummat2, &array_2, &array_ctrl_2, &array_i_2, &array_i_ctrl_2, &array_p_2, &array_p_ctrl_2, &alloc_ctrl_2);
    
    
    
    
    
    if (!arg2) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NM_assert(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_check(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) (NumericsMatrix *)0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NM_check",&obj0)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)NM_check((NumericsMatrix const *)arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_norm_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) (NumericsMatrix *)0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyObject * obj0 = 0 ;
  double result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NM_norm_1",&obj0)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (double)NM_norm_1(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_double((double)(result));
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_norm_inf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) (NumericsMatrix *)0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyObject * obj0 = 0 ;
  double result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NM_norm_inf",&obj0)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (double)NM_norm_inf(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_double((double)(result));
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_is_symmetric(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NM_is_symmetric",&obj0)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)NM_is_symmetric(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NM_symmetry_discrepancy(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyObject * obj0 = 0 ;
  double result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NM_symmetry_discrepancy",&obj0)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (double)NM_symmetry_discrepancy(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_double((double)(result));
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_linalg_data_t_id_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct linalg_data_t *arg1 = (struct linalg_data_t *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:linalg_data_t_id_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_linalg_data_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "linalg_data_t_id_set" "', argument " "1"" of type '" "struct linalg_data_t *""'"); 
  }
  arg1 = (struct linalg_data_t *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "linalg_data_t_id_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->id = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_linalg_data_t_id_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct linalg_data_t *arg1 = (struct linalg_data_t *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:linalg_data_t_id_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_linalg_data_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "linalg_data_t_id_get" "', argument " "1"" of type '" "struct linalg_data_t *""'"); 
  }
  arg1 = (struct linalg_data_t *)(argp1);
  result = (int) ((arg1)->id);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_linalg_data_t_free_fn_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct linalg_data_t *arg1 = (struct linalg_data_t *) 0 ;
  void (*arg2)(struct linalg_data_t *) = (void (*)(struct linalg_data_t *)) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:linalg_data_t_free_fn_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_linalg_data_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "linalg_data_t_free_fn_set" "', argument " "1"" of type '" "struct linalg_data_t *""'"); 
  }
  arg1 = (struct linalg_data_t *)(argp1);
  {
    int res = SWIG_ConvertFunctionPtr(obj1, (void**)(&arg2), SWIGTYPE_p_f_p_struct_linalg_data_t__void);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "linalg_data_t_free_fn_set" "', argument " "2"" of type '" "void (*)(struct linalg_data_t *)""'"); 
    }
  }
  if (arg1) (arg1)->free_fn = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_linalg_data_t_free_fn_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct linalg_data_t *arg1 = (struct linalg_data_t *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  void (*result)(struct linalg_data_t *) = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:linalg_data_t_free_fn_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_linalg_data_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "linalg_data_t_free_fn_get" "', argument " "1"" of type '" "struct linalg_data_t *""'"); 
  }
  arg1 = (struct linalg_data_t *)(argp1);
  result = (void (*)(struct linalg_data_t *)) ((arg1)->free_fn);
  resultobj = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_struct_linalg_data_t__void);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_linalg_data_t(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct linalg_data_t *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_linalg_data_t")) SWIG_fail;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct linalg_data_t *)calloc(1, sizeof(struct linalg_data_t));
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_linalg_data_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_linalg_data_t(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct linalg_data_t *arg1 = (struct linalg_data_t *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_linalg_data_t",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_linalg_data_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_linalg_data_t" "', argument " "1"" of type '" "struct linalg_data_t *""'"); 
  }
  arg1 = (struct linalg_data_t *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        free((char *) arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *linalg_data_t_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_linalg_data_t, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_NSM_linear_solver_params_solver_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NSM_linear_solver_params *arg1 = (struct NSM_linear_solver_params *) 0 ;
  NSM_linear_solver arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NSM_linear_solver_params_solver_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NSM_linear_solver_params, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NSM_linear_solver_params_solver_set" "', argument " "1"" of type '" "struct NSM_linear_solver_params *""'"); 
  }
  arg1 = (struct NSM_linear_solver_params *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NSM_linear_solver_params_solver_set" "', argument " "2"" of type '" "NSM_linear_solver""'");
  } 
  arg2 = (NSM_linear_solver)(val2);
  if (arg1) (arg1)->solver = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NSM_linear_solver_params_solver_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NSM_linear_solver_params *arg1 = (struct NSM_linear_solver_params *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  NSM_linear_solver result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NSM_linear_solver_params_solver_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NSM_linear_solver_params, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NSM_linear_solver_params_solver_get" "', argument " "1"" of type '" "struct NSM_linear_solver_params *""'"); 
  }
  arg1 = (struct NSM_linear_solver_params *)(argp1);
  result = (NSM_linear_solver) ((arg1)->solver);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NSM_linear_solver_params_solver_data_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NSM_linear_solver_params *arg1 = (struct NSM_linear_solver_params *) 0 ;
  void *arg2 = (void *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NSM_linear_solver_params_solver_data_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NSM_linear_solver_params, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NSM_linear_solver_params_solver_data_set" "', argument " "1"" of type '" "struct NSM_linear_solver_params *""'"); 
  }
  arg1 = (struct NSM_linear_solver_params *)(argp1);
  res2 = SWIG_ConvertPtr(obj1,SWIG_as_voidptrptr(&arg2), 0, SWIG_POINTER_DISOWN);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NSM_linear_solver_params_solver_data_set" "', argument " "2"" of type '" "void *""'"); 
  }
  if (arg1) (arg1)->solver_data = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NSM_linear_solver_params_solver_data_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NSM_linear_solver_params *arg1 = (struct NSM_linear_solver_params *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  void *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NSM_linear_solver_params_solver_data_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NSM_linear_solver_params, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NSM_linear_solver_params_solver_data_get" "', argument " "1"" of type '" "struct NSM_linear_solver_params *""'"); 
  }
  arg1 = (struct NSM_linear_solver_params *)(argp1);
  result = (void *) ((arg1)->solver_data);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NSM_linear_solver_params_solver_free_hook_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NSM_linear_solver_params *arg1 = (struct NSM_linear_solver_params *) 0 ;
  freeNSLSP arg2 = (freeNSLSP) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NSM_linear_solver_params_solver_free_hook_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NSM_linear_solver_params, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NSM_linear_solver_params_solver_free_hook_set" "', argument " "1"" of type '" "struct NSM_linear_solver_params *""'"); 
  }
  arg1 = (struct NSM_linear_solver_params *)(argp1);
  {
    int res = SWIG_ConvertFunctionPtr(obj1, (void**)(&arg2), SWIGTYPE_p_f_p_void__void);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "NSM_linear_solver_params_solver_free_hook_set" "', argument " "2"" of type '" "freeNSLSP""'"); 
    }
  }
  if (arg1) (arg1)->solver_free_hook = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NSM_linear_solver_params_solver_free_hook_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NSM_linear_solver_params *arg1 = (struct NSM_linear_solver_params *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  freeNSLSP result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NSM_linear_solver_params_solver_free_hook_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NSM_linear_solver_params, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NSM_linear_solver_params_solver_free_hook_get" "', argument " "1"" of type '" "struct NSM_linear_solver_params *""'"); 
  }
  arg1 = (struct NSM_linear_solver_params *)(argp1);
  result = (freeNSLSP) ((arg1)->solver_free_hook);
  resultobj = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_void__void);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NSM_linear_solver_params_iWork_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NSM_linear_solver_params *arg1 = (struct NSM_linear_solver_params *) 0 ;
  int *arg2 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NSM_linear_solver_params_iWork_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NSM_linear_solver_params, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NSM_linear_solver_params_iWork_set" "', argument " "1"" of type '" "struct NSM_linear_solver_params *""'"); 
  }
  arg1 = (struct NSM_linear_solver_params *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_int, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NSM_linear_solver_params_iWork_set" "', argument " "2"" of type '" "int *""'"); 
  }
  arg2 = (int *)(argp2);
  if (arg1) (arg1)->iWork = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NSM_linear_solver_params_iWork_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NSM_linear_solver_params *arg1 = (struct NSM_linear_solver_params *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NSM_linear_solver_params_iWork_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NSM_linear_solver_params, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NSM_linear_solver_params_iWork_get" "', argument " "1"" of type '" "struct NSM_linear_solver_params *""'"); 
  }
  arg1 = (struct NSM_linear_solver_params *)(argp1);
  result = (int *) ((arg1)->iWork);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_int, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NSM_linear_solver_params_iWorkSize_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NSM_linear_solver_params *arg1 = (struct NSM_linear_solver_params *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NSM_linear_solver_params_iWorkSize_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NSM_linear_solver_params, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NSM_linear_solver_params_iWorkSize_set" "', argument " "1"" of type '" "struct NSM_linear_solver_params *""'"); 
  }
  arg1 = (struct NSM_linear_solver_params *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NSM_linear_solver_params_iWorkSize_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->iWorkSize = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NSM_linear_solver_params_iWorkSize_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NSM_linear_solver_params *arg1 = (struct NSM_linear_solver_params *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NSM_linear_solver_params_iWorkSize_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NSM_linear_solver_params, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NSM_linear_solver_params_iWorkSize_get" "', argument " "1"" of type '" "struct NSM_linear_solver_params *""'"); 
  }
  arg1 = (struct NSM_linear_solver_params *)(argp1);
  result = (int) ((arg1)->iWorkSize);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NSM_linear_solver_params_dWork_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NSM_linear_solver_params *arg1 = (struct NSM_linear_solver_params *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NSM_linear_solver_params_dWork_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NSM_linear_solver_params, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NSM_linear_solver_params_dWork_set" "', argument " "1"" of type '" "struct NSM_linear_solver_params *""'"); 
  }
  arg1 = (struct NSM_linear_solver_params *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_double, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NSM_linear_solver_params_dWork_set" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = (double *)(argp2);
  if (arg1) (arg1)->dWork = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NSM_linear_solver_params_dWork_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NSM_linear_solver_params *arg1 = (struct NSM_linear_solver_params *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NSM_linear_solver_params_dWork_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NSM_linear_solver_params, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NSM_linear_solver_params_dWork_get" "', argument " "1"" of type '" "struct NSM_linear_solver_params *""'"); 
  }
  arg1 = (struct NSM_linear_solver_params *)(argp1);
  result = (double *) ((arg1)->dWork);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NSM_linear_solver_params_dWorkSize_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NSM_linear_solver_params *arg1 = (struct NSM_linear_solver_params *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NSM_linear_solver_params_dWorkSize_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NSM_linear_solver_params, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NSM_linear_solver_params_dWorkSize_set" "', argument " "1"" of type '" "struct NSM_linear_solver_params *""'"); 
  }
  arg1 = (struct NSM_linear_solver_params *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NSM_linear_solver_params_dWorkSize_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->dWorkSize = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NSM_linear_solver_params_dWorkSize_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NSM_linear_solver_params *arg1 = (struct NSM_linear_solver_params *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NSM_linear_solver_params_dWorkSize_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NSM_linear_solver_params, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NSM_linear_solver_params_dWorkSize_get" "', argument " "1"" of type '" "struct NSM_linear_solver_params *""'"); 
  }
  arg1 = (struct NSM_linear_solver_params *)(argp1);
  result = (int) ((arg1)->dWorkSize);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NSM_linear_solver_params_linalg_data_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NSM_linear_solver_params *arg1 = (struct NSM_linear_solver_params *) 0 ;
  linalg_data_t *arg2 = (linalg_data_t *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NSM_linear_solver_params_linalg_data_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NSM_linear_solver_params, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NSM_linear_solver_params_linalg_data_set" "', argument " "1"" of type '" "struct NSM_linear_solver_params *""'"); 
  }
  arg1 = (struct NSM_linear_solver_params *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_linalg_data_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NSM_linear_solver_params_linalg_data_set" "', argument " "2"" of type '" "linalg_data_t *""'"); 
  }
  arg2 = (linalg_data_t *)(argp2);
  if (arg1) (arg1)->linalg_data = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NSM_linear_solver_params_linalg_data_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NSM_linear_solver_params *arg1 = (struct NSM_linear_solver_params *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  linalg_data_t *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NSM_linear_solver_params_linalg_data_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NSM_linear_solver_params, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NSM_linear_solver_params_linalg_data_get" "', argument " "1"" of type '" "struct NSM_linear_solver_params *""'"); 
  }
  arg1 = (struct NSM_linear_solver_params *)(argp1);
  result = (linalg_data_t *) ((arg1)->linalg_data);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_linalg_data_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_NSM_linear_solver_params(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NSM_linear_solver_params *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_NSM_linear_solver_params")) SWIG_fail;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct NSM_linear_solver_params *)calloc(1, sizeof(struct NSM_linear_solver_params));
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NSM_linear_solver_params, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_NSM_linear_solver_params(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NSM_linear_solver_params *arg1 = (struct NSM_linear_solver_params *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_NSM_linear_solver_params",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NSM_linear_solver_params, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_NSM_linear_solver_params" "', argument " "1"" of type '" "struct NSM_linear_solver_params *""'"); 
  }
  arg1 = (struct NSM_linear_solver_params *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        free((char *) arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *NSM_linear_solver_params_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_NSM_linear_solver_params, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_NumericsSparseMatrix_triplet_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NumericsSparseMatrix *arg1 = (struct NumericsSparseMatrix *) 0 ;
  CSparseMatrix *arg2 = (CSparseMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int array_data_ctrl_2 = 0 ;
  int array_i_ctrl_2 = 0 ;
  int array_p_ctrl_2 = 0 ;
  PyArrayObject *array_data_2 = NULL ;
  PyArrayObject *array_i_2 = NULL ;
  PyArrayObject *array_p_2 = NULL ;
  int alloc_ctrl_2 = 0 ;
  struct cs_dl_sparse *M2 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NumericsSparseMatrix_triplet_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsSparseMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsSparseMatrix_triplet_set" "', argument " "1"" of type '" "struct NumericsSparseMatrix *""'"); 
  }
  arg1 = (struct NumericsSparseMatrix *)(argp1);
  {
    int res = cs_convert_from_scipy_sparse(obj1, &M2, &array_data_2, &array_data_ctrl_2, &array_i_2, &array_i_ctrl_2, &array_p_2, &array_p_ctrl_2, &alloc_ctrl_2);
    
    
    
    
    
    
    if (!res) {
      SWIG_fail; 
    }
    else if (res < 0) {
      SWIG_exception_fail(SWIG_RuntimeError, "Error the matrix is not sparse!"); 
    }
    
    arg2 = M2;
  }
  {
    // perform a deep copy
    if (!arg1->triplet) {
      arg1->triplet = CSparseMatrix_alloc_for_copy(arg2); 
    }
    CSparseMatrix_copy(arg2, arg1->triplet);
  }
  resultobj = SWIG_Py_Void();
  {
    if(array_data_ctrl_2 && array_data_2) {
      Py_DECREF(array_data_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if(M2) {
      NM_clean_cs(M2, alloc_ctrl_2); cs_spfree(M2); 
    }
  }
  return resultobj;
fail:
  {
    if(array_data_ctrl_2 && array_data_2) {
      Py_DECREF(array_data_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if(M2) {
      NM_clean_cs(M2, alloc_ctrl_2); cs_spfree(M2); 
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsSparseMatrix_triplet_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NumericsSparseMatrix *arg1 = (struct NumericsSparseMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  CSparseMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NumericsSparseMatrix_triplet_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsSparseMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsSparseMatrix_triplet_get" "', argument " "1"" of type '" "struct NumericsSparseMatrix *""'"); 
  }
  arg1 = (struct NumericsSparseMatrix *)(argp1);
  result = (CSparseMatrix *) ((arg1)->triplet);
  {
    if (result->nz == -1)
    {
      resultobj = cs_sparse_to_csc_matrix(result, true);
    }
    else if (result->nz == -2)
    {
      resultobj = cs_sparse_to_csr_matrix(result, true);
    }
    else if (result->nz >= 0)
    {
      resultobj = cs_sparse_to_coo_matrix(result, true);
    }
    else
    {
      SWIG_exception_fail(SWIG_RuntimeError, "The given sparse matrix is of unknown type. Please file a bug");
    }
    
    
    
    
    
    
    if (!resultobj) {
      SWIG_fail; 
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsSparseMatrix_csc_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NumericsSparseMatrix *arg1 = (struct NumericsSparseMatrix *) 0 ;
  CSparseMatrix *arg2 = (CSparseMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int array_data_ctrl_2 = 0 ;
  int array_i_ctrl_2 = 0 ;
  int array_p_ctrl_2 = 0 ;
  PyArrayObject *array_data_2 = NULL ;
  PyArrayObject *array_i_2 = NULL ;
  PyArrayObject *array_p_2 = NULL ;
  int alloc_ctrl_2 = 0 ;
  struct cs_dl_sparse *M2 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NumericsSparseMatrix_csc_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsSparseMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsSparseMatrix_csc_set" "', argument " "1"" of type '" "struct NumericsSparseMatrix *""'"); 
  }
  arg1 = (struct NumericsSparseMatrix *)(argp1);
  {
    int res = cs_convert_from_scipy_sparse(obj1, &M2, &array_data_2, &array_data_ctrl_2, &array_i_2, &array_i_ctrl_2, &array_p_2, &array_p_ctrl_2, &alloc_ctrl_2);
    
    
    
    
    
    
    if (!res) {
      SWIG_fail; 
    }
    else if (res < 0) {
      SWIG_exception_fail(SWIG_RuntimeError, "Error the matrix is not sparse!"); 
    }
    
    arg2 = M2;
  }
  {
    // perform a deep copy
    if (!arg1->csc) {
      arg1->csc = CSparseMatrix_alloc_for_copy(arg2); 
    }
    CSparseMatrix_copy(arg2, arg1->csc);
  }
  resultobj = SWIG_Py_Void();
  {
    if(array_data_ctrl_2 && array_data_2) {
      Py_DECREF(array_data_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if(M2) {
      NM_clean_cs(M2, alloc_ctrl_2); cs_spfree(M2); 
    }
  }
  return resultobj;
fail:
  {
    if(array_data_ctrl_2 && array_data_2) {
      Py_DECREF(array_data_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if(M2) {
      NM_clean_cs(M2, alloc_ctrl_2); cs_spfree(M2); 
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsSparseMatrix_csc_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NumericsSparseMatrix *arg1 = (struct NumericsSparseMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  CSparseMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NumericsSparseMatrix_csc_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsSparseMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsSparseMatrix_csc_get" "', argument " "1"" of type '" "struct NumericsSparseMatrix *""'"); 
  }
  arg1 = (struct NumericsSparseMatrix *)(argp1);
  result = (CSparseMatrix *) ((arg1)->csc);
  {
    if (result->nz == -1)
    {
      resultobj = cs_sparse_to_csc_matrix(result, true);
    }
    else if (result->nz == -2)
    {
      resultobj = cs_sparse_to_csr_matrix(result, true);
    }
    else if (result->nz >= 0)
    {
      resultobj = cs_sparse_to_coo_matrix(result, true);
    }
    else
    {
      SWIG_exception_fail(SWIG_RuntimeError, "The given sparse matrix is of unknown type. Please file a bug");
    }
    
    
    
    
    
    
    if (!resultobj) {
      SWIG_fail; 
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsSparseMatrix_trans_csc_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NumericsSparseMatrix *arg1 = (struct NumericsSparseMatrix *) 0 ;
  CSparseMatrix *arg2 = (CSparseMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int array_data_ctrl_2 = 0 ;
  int array_i_ctrl_2 = 0 ;
  int array_p_ctrl_2 = 0 ;
  PyArrayObject *array_data_2 = NULL ;
  PyArrayObject *array_i_2 = NULL ;
  PyArrayObject *array_p_2 = NULL ;
  int alloc_ctrl_2 = 0 ;
  struct cs_dl_sparse *M2 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NumericsSparseMatrix_trans_csc_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsSparseMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsSparseMatrix_trans_csc_set" "', argument " "1"" of type '" "struct NumericsSparseMatrix *""'"); 
  }
  arg1 = (struct NumericsSparseMatrix *)(argp1);
  {
    int res = cs_convert_from_scipy_sparse(obj1, &M2, &array_data_2, &array_data_ctrl_2, &array_i_2, &array_i_ctrl_2, &array_p_2, &array_p_ctrl_2, &alloc_ctrl_2);
    
    
    
    
    
    
    if (!res) {
      SWIG_fail; 
    }
    else if (res < 0) {
      SWIG_exception_fail(SWIG_RuntimeError, "Error the matrix is not sparse!"); 
    }
    
    arg2 = M2;
  }
  {
    // perform a deep copy
    if (!arg1->trans_csc) {
      arg1->trans_csc = CSparseMatrix_alloc_for_copy(arg2); 
    }
    CSparseMatrix_copy(arg2, arg1->trans_csc);
  }
  resultobj = SWIG_Py_Void();
  {
    if(array_data_ctrl_2 && array_data_2) {
      Py_DECREF(array_data_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if(M2) {
      NM_clean_cs(M2, alloc_ctrl_2); cs_spfree(M2); 
    }
  }
  return resultobj;
fail:
  {
    if(array_data_ctrl_2 && array_data_2) {
      Py_DECREF(array_data_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if(M2) {
      NM_clean_cs(M2, alloc_ctrl_2); cs_spfree(M2); 
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsSparseMatrix_trans_csc_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NumericsSparseMatrix *arg1 = (struct NumericsSparseMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  CSparseMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NumericsSparseMatrix_trans_csc_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsSparseMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsSparseMatrix_trans_csc_get" "', argument " "1"" of type '" "struct NumericsSparseMatrix *""'"); 
  }
  arg1 = (struct NumericsSparseMatrix *)(argp1);
  result = (CSparseMatrix *) ((arg1)->trans_csc);
  {
    if (result->nz == -1)
    {
      resultobj = cs_sparse_to_csc_matrix(result, true);
    }
    else if (result->nz == -2)
    {
      resultobj = cs_sparse_to_csr_matrix(result, true);
    }
    else if (result->nz >= 0)
    {
      resultobj = cs_sparse_to_coo_matrix(result, true);
    }
    else
    {
      SWIG_exception_fail(SWIG_RuntimeError, "The given sparse matrix is of unknown type. Please file a bug");
    }
    
    
    
    
    
    
    if (!resultobj) {
      SWIG_fail; 
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsSparseMatrix_csr_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NumericsSparseMatrix *arg1 = (struct NumericsSparseMatrix *) 0 ;
  CSparseMatrix *arg2 = (CSparseMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int array_data_ctrl_2 = 0 ;
  int array_i_ctrl_2 = 0 ;
  int array_p_ctrl_2 = 0 ;
  PyArrayObject *array_data_2 = NULL ;
  PyArrayObject *array_i_2 = NULL ;
  PyArrayObject *array_p_2 = NULL ;
  int alloc_ctrl_2 = 0 ;
  struct cs_dl_sparse *M2 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NumericsSparseMatrix_csr_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsSparseMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsSparseMatrix_csr_set" "', argument " "1"" of type '" "struct NumericsSparseMatrix *""'"); 
  }
  arg1 = (struct NumericsSparseMatrix *)(argp1);
  {
    int res = cs_convert_from_scipy_sparse(obj1, &M2, &array_data_2, &array_data_ctrl_2, &array_i_2, &array_i_ctrl_2, &array_p_2, &array_p_ctrl_2, &alloc_ctrl_2);
    
    
    
    
    
    
    if (!res) {
      SWIG_fail; 
    }
    else if (res < 0) {
      SWIG_exception_fail(SWIG_RuntimeError, "Error the matrix is not sparse!"); 
    }
    
    arg2 = M2;
  }
  {
    // perform a deep copy
    if (!arg1->csr) {
      arg1->csr = CSparseMatrix_alloc_for_copy(arg2); 
    }
    CSparseMatrix_copy(arg2, arg1->csr);
  }
  resultobj = SWIG_Py_Void();
  {
    if(array_data_ctrl_2 && array_data_2) {
      Py_DECREF(array_data_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if(M2) {
      NM_clean_cs(M2, alloc_ctrl_2); cs_spfree(M2); 
    }
  }
  return resultobj;
fail:
  {
    if(array_data_ctrl_2 && array_data_2) {
      Py_DECREF(array_data_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if(M2) {
      NM_clean_cs(M2, alloc_ctrl_2); cs_spfree(M2); 
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsSparseMatrix_csr_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NumericsSparseMatrix *arg1 = (struct NumericsSparseMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  CSparseMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NumericsSparseMatrix_csr_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsSparseMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsSparseMatrix_csr_get" "', argument " "1"" of type '" "struct NumericsSparseMatrix *""'"); 
  }
  arg1 = (struct NumericsSparseMatrix *)(argp1);
  result = (CSparseMatrix *) ((arg1)->csr);
  {
    if (result->nz == -1)
    {
      resultobj = cs_sparse_to_csc_matrix(result, true);
    }
    else if (result->nz == -2)
    {
      resultobj = cs_sparse_to_csr_matrix(result, true);
    }
    else if (result->nz >= 0)
    {
      resultobj = cs_sparse_to_coo_matrix(result, true);
    }
    else
    {
      SWIG_exception_fail(SWIG_RuntimeError, "The given sparse matrix is of unknown type. Please file a bug");
    }
    
    
    
    
    
    
    if (!resultobj) {
      SWIG_fail; 
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsSparseMatrix_diag_indx_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NumericsSparseMatrix *arg1 = (struct NumericsSparseMatrix *) 0 ;
  long *arg2 = (long *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NumericsSparseMatrix_diag_indx_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsSparseMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsSparseMatrix_diag_indx_set" "', argument " "1"" of type '" "struct NumericsSparseMatrix *""'"); 
  }
  arg1 = (struct NumericsSparseMatrix *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_long, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NumericsSparseMatrix_diag_indx_set" "', argument " "2"" of type '" "long *""'"); 
  }
  arg2 = (long *)(argp2);
  if (arg1) (arg1)->diag_indx = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsSparseMatrix_diag_indx_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NumericsSparseMatrix *arg1 = (struct NumericsSparseMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  long *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NumericsSparseMatrix_diag_indx_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsSparseMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsSparseMatrix_diag_indx_get" "', argument " "1"" of type '" "struct NumericsSparseMatrix *""'"); 
  }
  arg1 = (struct NumericsSparseMatrix *)(argp1);
  result = (long *) ((arg1)->diag_indx);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_long, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsSparseMatrix_origin_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NumericsSparseMatrix *arg1 = (struct NumericsSparseMatrix *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NumericsSparseMatrix_origin_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsSparseMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsSparseMatrix_origin_set" "', argument " "1"" of type '" "struct NumericsSparseMatrix *""'"); 
  }
  arg1 = (struct NumericsSparseMatrix *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NumericsSparseMatrix_origin_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  if (arg1) (arg1)->origin = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsSparseMatrix_origin_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NumericsSparseMatrix *arg1 = (struct NumericsSparseMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NumericsSparseMatrix_origin_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsSparseMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsSparseMatrix_origin_get" "', argument " "1"" of type '" "struct NumericsSparseMatrix *""'"); 
  }
  arg1 = (struct NumericsSparseMatrix *)(argp1);
  result = (unsigned int) ((arg1)->origin);
  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsSparseMatrix_linearSolverParams_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NumericsSparseMatrix *arg1 = (struct NumericsSparseMatrix *) 0 ;
  NSM_linear_solver_params *arg2 = (NSM_linear_solver_params *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NumericsSparseMatrix_linearSolverParams_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsSparseMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsSparseMatrix_linearSolverParams_set" "', argument " "1"" of type '" "struct NumericsSparseMatrix *""'"); 
  }
  arg1 = (struct NumericsSparseMatrix *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_NSM_linear_solver_params, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NumericsSparseMatrix_linearSolverParams_set" "', argument " "2"" of type '" "NSM_linear_solver_params *""'"); 
  }
  arg2 = (NSM_linear_solver_params *)(argp2);
  if (arg1) (arg1)->linearSolverParams = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NumericsSparseMatrix_linearSolverParams_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NumericsSparseMatrix *arg1 = (struct NumericsSparseMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  NSM_linear_solver_params *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NumericsSparseMatrix_linearSolverParams_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsSparseMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumericsSparseMatrix_linearSolverParams_get" "', argument " "1"" of type '" "struct NumericsSparseMatrix *""'"); 
  }
  arg1 = (struct NumericsSparseMatrix *)(argp1);
  result = (NSM_linear_solver_params *) ((arg1)->linearSolverParams);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NSM_linear_solver_params, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_NumericsSparseMatrix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NumericsSparseMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_NumericsSparseMatrix")) SWIG_fail;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct NumericsSparseMatrix *)calloc(1, sizeof(struct NumericsSparseMatrix));
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NumericsSparseMatrix, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_NumericsSparseMatrix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NumericsSparseMatrix *arg1 = (struct NumericsSparseMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_NumericsSparseMatrix",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsSparseMatrix, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_NumericsSparseMatrix" "', argument " "1"" of type '" "struct NumericsSparseMatrix *""'"); 
  }
  arg1 = (struct NumericsSparseMatrix *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        free((char *) arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *NumericsSparseMatrix_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_NumericsSparseMatrix, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_NSM_null(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsSparseMatrix *arg1 = (NumericsSparseMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NSM_null",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsSparseMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NSM_null" "', argument " "1"" of type '" "NumericsSparseMatrix *""'"); 
  }
  arg1 = (NumericsSparseMatrix *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NSM_null(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NSM_new(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsSparseMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":NSM_new")) SWIG_fail;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (NumericsSparseMatrix *)NSM_new();
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NumericsSparseMatrix, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NSM_triplet_eye(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  NumericsSparseMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NSM_triplet_eye",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "NSM_triplet_eye" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = (unsigned int)(val1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (NumericsSparseMatrix *)NSM_triplet_eye(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NumericsSparseMatrix, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NSM_free(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsSparseMatrix *arg1 = (NumericsSparseMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  NumericsSparseMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NSM_free",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsSparseMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NSM_free" "', argument " "1"" of type '" "NumericsSparseMatrix *""'"); 
  }
  arg1 = (NumericsSparseMatrix *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (NumericsSparseMatrix *)NSM_free(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NumericsSparseMatrix, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NSM_free_p(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  void *arg1 = (void *) 0 ;
  int res1 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NSM_free_p",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0,SWIG_as_voidptrptr(&arg1), 0, 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NSM_free_p" "', argument " "1"" of type '" "void *""'"); 
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NSM_free_p(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NSM_data(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsSparseMatrix *arg1 = (NumericsSparseMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NSM_data",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsSparseMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NSM_data" "', argument " "1"" of type '" "NumericsSparseMatrix *""'"); 
  }
  arg1 = (NumericsSparseMatrix *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (double *)NSM_data(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NSM_solver_data(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NSM_linear_solver_params *arg1 = (NSM_linear_solver_params *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  void *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NSM_solver_data",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NSM_linear_solver_params, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NSM_solver_data" "', argument " "1"" of type '" "NSM_linear_solver_params *""'"); 
  }
  arg1 = (NSM_linear_solver_params *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (void *)NSM_solver_data(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NSM_workspace(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NSM_linear_solver_params *arg1 = (NSM_linear_solver_params *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NSM_workspace",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NSM_linear_solver_params, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NSM_workspace" "', argument " "1"" of type '" "NSM_linear_solver_params *""'"); 
  }
  arg1 = (NSM_linear_solver_params *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (double *)NSM_workspace(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NSM_nnz(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CSparseMatrix *arg1 = (CSparseMatrix *) (CSparseMatrix *)0 ;
  int array_data_ctrl_1 = 0 ;
  int array_i_ctrl_1 = 0 ;
  int array_p_ctrl_1 = 0 ;
  PyArrayObject *array_data_1 = NULL ;
  PyArrayObject *array_i_1 = NULL ;
  PyArrayObject *array_p_1 = NULL ;
  int alloc_ctrl_1 = 0 ;
  struct cs_dl_sparse *M1 = NULL ;
  PyObject * obj0 = 0 ;
  size_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NSM_nnz",&obj0)) SWIG_fail;
  {
    int res = cs_convert_from_scipy_sparse(obj0, &M1, &array_data_1, &array_data_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    
    if (!res) {
      SWIG_fail; 
    }
    else if (res < 0) {
      SWIG_exception_fail(SWIG_RuntimeError, "Error the matrix is not sparse!"); 
    }
    
    arg1 = M1;
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = NSM_nnz((struct cs_dl_sparse const *)arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_size_t((size_t)(result));
  {
    if(array_data_ctrl_1 && array_data_1) {
      Py_DECREF(array_data_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if(M1) {
      NM_clean_cs(M1, alloc_ctrl_1); cs_spfree(M1); 
    }
  }
  return resultobj;
fail:
  {
    if(array_data_ctrl_1 && array_data_1) {
      Py_DECREF(array_data_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if(M1) {
      NM_clean_cs(M1, alloc_ctrl_1); cs_spfree(M1); 
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NSM_diag_indices(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyObject * obj0 = 0 ;
  long *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NSM_diag_indices",&obj0)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (long *)NSM_diag_indices(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_long, 0 |  0 );
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NSM_extract_block(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  double *arg2 = (double *) 0 ;
  size_t arg3 ;
  size_t arg4 ;
  size_t arg5 ;
  size_t arg6 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  size_t val5 ;
  int ecode5 = 0 ;
  size_t val6 ;
  int ecode6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOO:NSM_extract_block",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NSM_extract_block" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = (double *)(argp2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "NSM_extract_block" "', argument " "3"" of type '" "size_t""'");
  } 
  arg3 = (size_t)(val3);
  ecode4 = SWIG_AsVal_size_t(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "NSM_extract_block" "', argument " "4"" of type '" "size_t""'");
  } 
  arg4 = (size_t)(val4);
  ecode5 = SWIG_AsVal_size_t(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "NSM_extract_block" "', argument " "5"" of type '" "size_t""'");
  } 
  arg5 = (size_t)(val5);
  ecode6 = SWIG_AsVal_size_t(obj5, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "NSM_extract_block" "', argument " "6"" of type '" "size_t""'");
  } 
  arg6 = (size_t)(val6);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NSM_extract_block(arg1,arg2,arg3,arg4,arg5,arg6);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NSM_linearSolverParams_free(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NSM_linear_solver_params *arg1 = (NSM_linear_solver_params *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  NSM_linear_solver_params *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NSM_linearSolverParams_free",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NSM_linear_solver_params, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NSM_linearSolverParams_free" "', argument " "1"" of type '" "NSM_linear_solver_params *""'"); 
  }
  arg1 = (NSM_linear_solver_params *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (NSM_linear_solver_params *)NSM_linearSolverParams_free(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NSM_linear_solver_params, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NSM_linearSolverParams_new(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NSM_linear_solver_params *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":NSM_linearSolverParams_new")) SWIG_fail;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (NSM_linear_solver_params *)NSM_linearSolverParams_new();
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NSM_linear_solver_params, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NSM_linearSolverParams(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsMatrix *arg1 = (NumericsMatrix *) 0 ;
  PyArrayObject *array_1 = NULL ;
  int array_ctrl_1 = 0 ;
  PyArrayObject *array_i_1 = NULL ;
  int array_i_ctrl_1 = 0 ;
  PyArrayObject *array_p_1 = NULL ;
  int array_p_ctrl_1 = 0 ;
  int alloc_ctrl_1 = 0 ;
  NumericsMatrix *nummat1 = NULL ;
  PyObject * obj0 = 0 ;
  NSM_linear_solver_params *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NSM_linearSolverParams",&obj0)) SWIG_fail;
  {
    arg1 = NM_convert_from_python(obj0, &nummat1, &array_1, &array_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    if (!arg1) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (NSM_linear_solver_params *)NSM_linearSolverParams(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NSM_linear_solver_params, 0 |  0 );
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_1 && array_1) {
      Py_DECREF(array_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if (nummat1)
    {
      if (!NM_clean(nummat1, alloc_ctrl_1)) {
        return NULL; 
      }
      NM_free(nummat1);
      free(nummat1);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NSM_fix_csc(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CSparseMatrix *arg1 = (CSparseMatrix *) 0 ;
  int array_data_ctrl_1 = 0 ;
  int array_i_ctrl_1 = 0 ;
  int array_p_ctrl_1 = 0 ;
  PyArrayObject *array_data_1 = NULL ;
  PyArrayObject *array_i_1 = NULL ;
  PyArrayObject *array_p_1 = NULL ;
  int alloc_ctrl_1 = 0 ;
  struct cs_dl_sparse *M1 = NULL ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NSM_fix_csc",&obj0)) SWIG_fail;
  {
    int res = cs_convert_from_scipy_sparse(obj0, &M1, &array_data_1, &array_data_ctrl_1, &array_i_1, &array_i_ctrl_1, &array_p_1, &array_p_ctrl_1, &alloc_ctrl_1);
    
    
    
    
    
    
    if (!res) {
      SWIG_fail; 
    }
    else if (res < 0) {
      SWIG_exception_fail(SWIG_RuntimeError, "Error the matrix is not sparse!"); 
    }
    
    arg1 = M1;
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NSM_fix_csc(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    if(array_data_ctrl_1 && array_data_1) {
      Py_DECREF(array_data_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if(M1) {
      NM_clean_cs(M1, alloc_ctrl_1); cs_spfree(M1); 
    }
  }
  return resultobj;
fail:
  {
    if(array_data_ctrl_1 && array_data_1) {
      Py_DECREF(array_data_1); 
    };
    if(array_i_ctrl_1 && array_i_1) {
      Py_DECREF(array_i_1); 
    };
    if(array_p_ctrl_1 && array_p_1) {
      Py_DECREF(array_p_1); 
    };
    
    if(M1) {
      NM_clean_cs(M1, alloc_ctrl_1); cs_spfree(M1); 
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NSM_origin(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsSparseMatrix *arg1 = (NumericsSparseMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NSM_origin",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsSparseMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NSM_origin" "', argument " "1"" of type '" "NumericsSparseMatrix const *""'"); 
  }
  arg1 = (NumericsSparseMatrix *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (unsigned int)NSM_origin((NumericsSparseMatrix const *)arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NSM_get_origin(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsSparseMatrix *arg1 = (NumericsSparseMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  CSparseMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NSM_get_origin",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsSparseMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NSM_get_origin" "', argument " "1"" of type '" "NumericsSparseMatrix const *""'"); 
  }
  arg1 = (NumericsSparseMatrix *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (CSparseMatrix *)NSM_get_origin((NumericsSparseMatrix const *)arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  {
    if (result->nz == -1)
    {
      resultobj = cs_sparse_to_csc_matrix(result, true);
    }
    else if (result->nz == -2)
    {
      resultobj = cs_sparse_to_csr_matrix(result, true);
    }
    else if (result->nz >= 0)
    {
      resultobj = cs_sparse_to_coo_matrix(result, true);
    }
    else
    {
      SWIG_exception_fail(SWIG_RuntimeError, "The given sparse matrix is of unknown type. Please file a bug");
    }
    
    
    
    
    
    
    if (!resultobj) {
      SWIG_fail; 
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NSM_write_in_file(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsSparseMatrix *arg1 = (NumericsSparseMatrix *) 0 ;
  FILE *arg2 = (FILE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NSM_write_in_file",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsSparseMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NSM_write_in_file" "', argument " "1"" of type '" "NumericsSparseMatrix const *""'"); 
  }
  arg1 = (NumericsSparseMatrix *)(argp1);
  {
    // %typemap(in) (FILE *file)
    int alloc = 1;
    char* cstr;
    int res = SWIG_AsCharPtrAndSize(obj1, &cstr, NULL, &alloc);
    if (!SWIG_IsOK(res)) {
      SWIG_Error(SWIG_ArgError(res), "in method unknown', argument " "1"" of type '" "char *""'");
    }
    arg2 = fopen(cstr, "r");
    if (!arg2)
    {
      SWIG_Error(SWIG_IOError, format_msg_concat("in method '" "NSM_write_in_file" "' cannot fopen file", cstr));
      if (alloc == SWIG_NEWOBJ) free(cstr);
      SWIG_fail;
    }
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NSM_write_in_file((NumericsSparseMatrix const *)arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NSM_new_from_file(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FILE *arg1 = (FILE *) 0 ;
  PyObject * obj0 = 0 ;
  NumericsSparseMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NSM_new_from_file",&obj0)) SWIG_fail;
  {
    // %typemap(in) (FILE *file)
    int alloc = 1;
    char* cstr;
    int res = SWIG_AsCharPtrAndSize(obj0, &cstr, NULL, &alloc);
    if (!SWIG_IsOK(res)) {
      SWIG_Error(SWIG_ArgError(res), "in method unknown', argument " "1"" of type '" "char *""'");
    }
    arg1 = fopen(cstr, "r");
    if (!arg1)
    {
      SWIG_Error(SWIG_IOError, format_msg_concat("in method '" "NSM_new_from_file" "' cannot fopen file", cstr));
      if (alloc == SWIG_NEWOBJ) free(cstr);
      SWIG_fail;
    }
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (NumericsSparseMatrix *)NSM_new_from_file(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NumericsSparseMatrix, 0 |  0 );
  {
    // %typemap(freearg) (FILE *file)
    if(arg1)
    {
      fclose(arg1);
    }
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (FILE *file)
    if(arg1)
    {
      fclose(arg1);
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NSM_to_dense(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NumericsSparseMatrix *arg1 = (NumericsSparseMatrix *) (NumericsSparseMatrix *)0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NSM_to_dense",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NumericsSparseMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NSM_to_dense" "', argument " "1"" of type '" "NumericsSparseMatrix const *const""'"); 
  }
  arg1 = (NumericsSparseMatrix *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NSM_to_dense" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = (double *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)NSM_to_dense((NumericsSparseMatrix const *)arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int Swig_var_SICONOS_NONAME_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_NONAME_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_NONAME_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_NONAME_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_MLCP_PGS_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_MLCP_PGS_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_MLCP_PGS_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_MLCP_PGS_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_MLCP_RPGS_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_MLCP_RPGS_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_MLCP_RPGS_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_MLCP_RPGS_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_MLCP_PSOR_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_MLCP_PSOR_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_MLCP_PSOR_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_MLCP_PSOR_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_MLCP_RPSOR_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_MLCP_RPSOR_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_MLCP_RPSOR_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_MLCP_RPSOR_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_MLCP_PATH_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_MLCP_PATH_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_MLCP_PATH_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_MLCP_PATH_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_MLCP_ENUM_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_MLCP_ENUM_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_MLCP_ENUM_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_MLCP_ENUM_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_MLCP_SIMPLEX_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_MLCP_SIMPLEX_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_MLCP_SIMPLEX_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_MLCP_SIMPLEX_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_MLCP_DIRECT_ENUM_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_MLCP_DIRECT_ENUM_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_MLCP_DIRECT_ENUM_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_MLCP_DIRECT_ENUM_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_MLCP_PATH_ENUM_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_MLCP_PATH_ENUM_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_MLCP_PATH_ENUM_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_MLCP_PATH_ENUM_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_MLCP_DIRECT_SIMPLEX_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_MLCP_DIRECT_SIMPLEX_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_MLCP_DIRECT_SIMPLEX_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_MLCP_DIRECT_SIMPLEX_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_MLCP_DIRECT_PATH_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_MLCP_DIRECT_PATH_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_MLCP_DIRECT_PATH_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_MLCP_DIRECT_PATH_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_MLCP_DIRECT_PATH_ENUM_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_MLCP_DIRECT_PATH_ENUM_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_MLCP_DIRECT_PATH_ENUM_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_MLCP_DIRECT_PATH_ENUM_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_MLCP_FB_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_MLCP_FB_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_MLCP_FB_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_MLCP_FB_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_MLCP_DIRECT_FB_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_MLCP_DIRECT_FB_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_MLCP_DIRECT_FB_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_MLCP_DIRECT_FB_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_MLCP_PGS_SBM_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_MLCP_PGS_SBM_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_MLCP_PGS_SBM_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_MLCP_PGS_SBM_STR);
  return pyobj;
}


SWIGINTERN PyObject *_wrap_MLCP_isStorageType1_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedLinearComplementarityProblem *arg1 = (struct MixedLinearComplementarityProblem *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:MLCP_isStorageType1_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MLCP_isStorageType1_set" "', argument " "1"" of type '" "struct MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedLinearComplementarityProblem *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "MLCP_isStorageType1_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->isStorageType1 = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MLCP_isStorageType1_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedLinearComplementarityProblem *arg1 = (struct MixedLinearComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:MLCP_isStorageType1_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MLCP_isStorageType1_get" "', argument " "1"" of type '" "struct MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedLinearComplementarityProblem *)(argp1);
  result = (int) ((arg1)->isStorageType1);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MLCP_isStorageType2_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedLinearComplementarityProblem *arg1 = (struct MixedLinearComplementarityProblem *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:MLCP_isStorageType2_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MLCP_isStorageType2_set" "', argument " "1"" of type '" "struct MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedLinearComplementarityProblem *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "MLCP_isStorageType2_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->isStorageType2 = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MLCP_isStorageType2_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedLinearComplementarityProblem *arg1 = (struct MixedLinearComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:MLCP_isStorageType2_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MLCP_isStorageType2_get" "', argument " "1"" of type '" "struct MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedLinearComplementarityProblem *)(argp1);
  result = (int) ((arg1)->isStorageType2);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MLCP_n_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedLinearComplementarityProblem *arg1 = (struct MixedLinearComplementarityProblem *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:MLCP_n_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MLCP_n_set" "', argument " "1"" of type '" "struct MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedLinearComplementarityProblem *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "MLCP_n_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->n = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MLCP_n_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedLinearComplementarityProblem *arg1 = (struct MixedLinearComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:MLCP_n_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MLCP_n_get" "', argument " "1"" of type '" "struct MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedLinearComplementarityProblem *)(argp1);
  result = (int) ((arg1)->n);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MLCP_m_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedLinearComplementarityProblem *arg1 = (struct MixedLinearComplementarityProblem *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:MLCP_m_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MLCP_m_set" "', argument " "1"" of type '" "struct MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedLinearComplementarityProblem *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "MLCP_m_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->m = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MLCP_m_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedLinearComplementarityProblem *arg1 = (struct MixedLinearComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:MLCP_m_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MLCP_m_get" "', argument " "1"" of type '" "struct MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedLinearComplementarityProblem *)(argp1);
  result = (int) ((arg1)->m);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MLCP_blocksRows_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedLinearComplementarityProblem *arg1 = (struct MixedLinearComplementarityProblem *) 0 ;
  int *arg2 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:MLCP_blocksRows_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MLCP_blocksRows_set" "', argument " "1"" of type '" "struct MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedLinearComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_int, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MLCP_blocksRows_set" "', argument " "2"" of type '" "int *""'"); 
  }
  arg2 = (int *)(argp2);
  if (arg1) (arg1)->blocksRows = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MLCP_blocksRows_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedLinearComplementarityProblem *arg1 = (struct MixedLinearComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:MLCP_blocksRows_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MLCP_blocksRows_get" "', argument " "1"" of type '" "struct MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedLinearComplementarityProblem *)(argp1);
  result = (int *) ((arg1)->blocksRows);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_int, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MLCP_blocksIsComp_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedLinearComplementarityProblem *arg1 = (struct MixedLinearComplementarityProblem *) 0 ;
  int *arg2 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:MLCP_blocksIsComp_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MLCP_blocksIsComp_set" "', argument " "1"" of type '" "struct MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedLinearComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_int, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MLCP_blocksIsComp_set" "', argument " "2"" of type '" "int *""'"); 
  }
  arg2 = (int *)(argp2);
  if (arg1) (arg1)->blocksIsComp = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MLCP_blocksIsComp_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedLinearComplementarityProblem *arg1 = (struct MixedLinearComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:MLCP_blocksIsComp_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MLCP_blocksIsComp_get" "', argument " "1"" of type '" "struct MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedLinearComplementarityProblem *)(argp1);
  result = (int *) ((arg1)->blocksIsComp);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_int, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MLCP_M_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedLinearComplementarityProblem *arg1 = (struct MixedLinearComplementarityProblem *) 0 ;
  NumericsMatrix *arg2 = (NumericsMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array_2 = NULL ;
  int array_ctrl_2 = 0 ;
  PyArrayObject *array_i_2 = NULL ;
  int array_i_ctrl_2 = 0 ;
  PyArrayObject *array_p_2 = NULL ;
  int array_p_ctrl_2 = 0 ;
  int alloc_ctrl_2 = 0 ;
  NumericsMatrix *nummat2 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:MLCP_M_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MLCP_M_set" "', argument " "1"" of type '" "struct MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedLinearComplementarityProblem *)(argp1);
  {
    arg2 = NM_convert_from_python(obj1, &nummat2, &array_2, &array_ctrl_2, &array_i_2, &array_i_ctrl_2, &array_p_2, &array_p_ctrl_2, &alloc_ctrl_2);
    
    
    
    
    
    if (!arg2) {
      SWIG_fail; 
    }
  }
  {
    //  %typemap(memberin) (NumericsMatrix*)
    // perform a deep copy
    if (!arg1->M) {
      arg1->M = NM_create(arg2->storageType, arg2->size0, arg2->size1); 
    }
    NM_copy(arg2, arg1->M);
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_MLCP_M_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedLinearComplementarityProblem *arg1 = (struct MixedLinearComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  NumericsMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:MLCP_M_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MLCP_M_get" "', argument " "1"" of type '" "struct MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedLinearComplementarityProblem *)(argp1);
  result = (NumericsMatrix *) ((arg1)->M);
  {
    if (strcmp("MLCP_M_get", "new_NumericsMatrix"))
    {
      resultobj = NM_to_python(result);
      
      
      
      if (!resultobj) SWIG_fail;
    }
    else
    {
      resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NumericsMatrix, SWIG_POINTER_NEW |  0 );
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MLCP_q_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedLinearComplementarityProblem *arg1 = (struct MixedLinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:MLCP_q_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MLCP_q_set" "', argument " "1"" of type '" "struct MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedLinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  if (arg1) (arg1)->q = arg2;
  resultobj = SWIG_Py_Void();
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_MLCP_q_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedLinearComplementarityProblem *arg1 = (struct MixedLinearComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:MLCP_q_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MLCP_q_get" "', argument " "1"" of type '" "struct MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedLinearComplementarityProblem *)(argp1);
  result = (double *) ((arg1)->q);
  {
    if (result)
    {
      PyObject *obj;
      C_to_target_lang1(obj, arg1->m + arg1->n, result, SWIG_fail);
      resultobj = obj;
    }
    else
    SWIG_fail;
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MLCP_A_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedLinearComplementarityProblem *arg1 = (struct MixedLinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:MLCP_A_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MLCP_A_set" "', argument " "1"" of type '" "struct MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedLinearComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_double, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MLCP_A_set" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = (double *)(argp2);
  if (arg1) (arg1)->A = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MLCP_A_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedLinearComplementarityProblem *arg1 = (struct MixedLinearComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:MLCP_A_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MLCP_A_get" "', argument " "1"" of type '" "struct MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedLinearComplementarityProblem *)(argp1);
  result = (double *) ((arg1)->A);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MLCP_B_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedLinearComplementarityProblem *arg1 = (struct MixedLinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:MLCP_B_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MLCP_B_set" "', argument " "1"" of type '" "struct MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedLinearComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_double, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MLCP_B_set" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = (double *)(argp2);
  if (arg1) (arg1)->B = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MLCP_B_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedLinearComplementarityProblem *arg1 = (struct MixedLinearComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:MLCP_B_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MLCP_B_get" "', argument " "1"" of type '" "struct MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedLinearComplementarityProblem *)(argp1);
  result = (double *) ((arg1)->B);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MLCP_C_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedLinearComplementarityProblem *arg1 = (struct MixedLinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:MLCP_C_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MLCP_C_set" "', argument " "1"" of type '" "struct MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedLinearComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_double, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MLCP_C_set" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = (double *)(argp2);
  if (arg1) (arg1)->C = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MLCP_C_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedLinearComplementarityProblem *arg1 = (struct MixedLinearComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:MLCP_C_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MLCP_C_get" "', argument " "1"" of type '" "struct MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedLinearComplementarityProblem *)(argp1);
  result = (double *) ((arg1)->C);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MLCP_D_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedLinearComplementarityProblem *arg1 = (struct MixedLinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:MLCP_D_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MLCP_D_set" "', argument " "1"" of type '" "struct MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedLinearComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_double, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MLCP_D_set" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = (double *)(argp2);
  if (arg1) (arg1)->D = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MLCP_D_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedLinearComplementarityProblem *arg1 = (struct MixedLinearComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:MLCP_D_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MLCP_D_get" "', argument " "1"" of type '" "struct MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedLinearComplementarityProblem *)(argp1);
  result = (double *) ((arg1)->D);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MLCP_a_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedLinearComplementarityProblem *arg1 = (struct MixedLinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:MLCP_a_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MLCP_a_set" "', argument " "1"" of type '" "struct MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedLinearComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_double, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MLCP_a_set" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = (double *)(argp2);
  if (arg1) (arg1)->a = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MLCP_a_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedLinearComplementarityProblem *arg1 = (struct MixedLinearComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:MLCP_a_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MLCP_a_get" "', argument " "1"" of type '" "struct MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedLinearComplementarityProblem *)(argp1);
  result = (double *) ((arg1)->a);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MLCP_b_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedLinearComplementarityProblem *arg1 = (struct MixedLinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:MLCP_b_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MLCP_b_set" "', argument " "1"" of type '" "struct MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedLinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  if (arg1) (arg1)->b = arg2;
  resultobj = SWIG_Py_Void();
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_MLCP_b_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedLinearComplementarityProblem *arg1 = (struct MixedLinearComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:MLCP_b_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MLCP_b_get" "', argument " "1"" of type '" "struct MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedLinearComplementarityProblem *)(argp1);
  result = (double *) ((arg1)->b);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_MLCP__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedLinearComplementarityProblem *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_MLCP")) SWIG_fail;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct MixedLinearComplementarityProblem *)new_MixedLinearComplementarityProblem__SWIG_0();
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_MixedLinearComplementarityProblem, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_MLCP__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  struct MixedLinearComplementarityProblem *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:new_MLCP",&obj0,&obj1,&obj2)) SWIG_fail;
  arg1 = obj0;
  arg2 = obj1;
  arg3 = obj2;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct MixedLinearComplementarityProblem *)new_MixedLinearComplementarityProblem__SWIG_1(arg1,arg2,arg3);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_MixedLinearComplementarityProblem, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_MLCP(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  Py_ssize_t ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = args ? PyObject_Length(args) : 0;
  for (ii = 0; (ii < 3) && (ii < argc); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_MLCP__SWIG_0(self, args);
  }
  if (argc == 3) {
    int _v;
    _v = (argv[0] != 0);
    if (_v) {
      _v = (argv[1] != 0);
      if (_v) {
        _v = (argv[2] != 0);
        if (_v) {
          return _wrap_new_MLCP__SWIG_1(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_MLCP'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    MixedLinearComplementarityProblem::MixedLinearComplementarityProblem()\n"
    "    MixedLinearComplementarityProblem::MixedLinearComplementarityProblem(PyObject *,PyObject *,PyObject *)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_MLCP(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedLinearComplementarityProblem *arg1 = (struct MixedLinearComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_MLCP",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_MLCP" "', argument " "1"" of type '" "struct MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedLinearComplementarityProblem *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        delete_MixedLinearComplementarityProblem(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *MLCP_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_MixedLinearComplementarityProblem, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_mixedLinearComplementarity_display(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:mixedLinearComplementarity_display",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mixedLinearComplementarity_display" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        mixedLinearComplementarity_display(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mixedLinearComplementarity_printInFile(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  FILE *arg2 = (FILE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:mixedLinearComplementarity_printInFile",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mixedLinearComplementarity_printInFile" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  {
    // %typemap(in) (FILE *file)
    int alloc = 1;
    char* cstr;
    int res = SWIG_AsCharPtrAndSize(obj1, &cstr, NULL, &alloc);
    if (!SWIG_IsOK(res)) {
      SWIG_Error(SWIG_ArgError(res), "in method unknown', argument " "1"" of type '" "char *""'");
    }
    arg2 = fopen(cstr, "r");
    if (!arg2)
    {
      SWIG_Error(SWIG_IOError, format_msg_concat("in method '" "mixedLinearComplementarity_printInFile" "' cannot fopen file", cstr));
      if (alloc == SWIG_NEWOBJ) free(cstr);
      SWIG_fail;
    }
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)mixedLinearComplementarity_printInFile(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_mixedLinearComplementarity_newFromFile(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  FILE *arg2 = (FILE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:mixedLinearComplementarity_newFromFile",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mixedLinearComplementarity_newFromFile" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  {
    // %typemap(in) (FILE *file)
    int alloc = 1;
    char* cstr;
    int res = SWIG_AsCharPtrAndSize(obj1, &cstr, NULL, &alloc);
    if (!SWIG_IsOK(res)) {
      SWIG_Error(SWIG_ArgError(res), "in method unknown', argument " "1"" of type '" "char *""'");
    }
    arg2 = fopen(cstr, "r");
    if (!arg2)
    {
      SWIG_Error(SWIG_IOError, format_msg_concat("in method '" "mixedLinearComplementarity_newFromFile" "' cannot fopen file", cstr));
      if (alloc == SWIG_NEWOBJ) free(cstr);
      SWIG_fail;
    }
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)mixedLinearComplementarity_newFromFile(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_mixedLinearComplementarity_newFromFileOld(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  FILE *arg2 = (FILE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:mixedLinearComplementarity_newFromFileOld",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mixedLinearComplementarity_newFromFileOld" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  {
    // %typemap(in) (FILE *file)
    int alloc = 1;
    char* cstr;
    int res = SWIG_AsCharPtrAndSize(obj1, &cstr, NULL, &alloc);
    if (!SWIG_IsOK(res)) {
      SWIG_Error(SWIG_ArgError(res), "in method unknown', argument " "1"" of type '" "char *""'");
    }
    arg2 = fopen(cstr, "r");
    if (!arg2)
    {
      SWIG_Error(SWIG_IOError, format_msg_concat("in method '" "mixedLinearComplementarity_newFromFileOld" "' cannot fopen file", cstr));
      if (alloc == SWIG_NEWOBJ) free(cstr);
      SWIG_fail;
    }
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)mixedLinearComplementarity_newFromFileOld(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_mixedLinearComplementarity_newFromFilename(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:mixedLinearComplementarity_newFromFilename",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mixedLinearComplementarity_newFromFilename" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "mixedLinearComplementarity_newFromFilename" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)mixedLinearComplementarity_newFromFilename(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_freeMixedLinearComplementarityProblem(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:freeMixedLinearComplementarityProblem",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "freeMixedLinearComplementarityProblem" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        freeMixedLinearComplementarityProblem(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_newMLCP(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":newMLCP")) SWIG_fail;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (MixedLinearComplementarityProblem *)newMLCP();
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mlcp_driver_init(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:mlcp_driver_init",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mlcp_driver_init" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "mlcp_driver_init" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        mlcp_driver_init(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mlcp_driver_reset(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:mlcp_driver_reset",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mlcp_driver_reset" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "mlcp_driver_reset" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        mlcp_driver_reset(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mlcp_alloc_working_memory(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:mlcp_alloc_working_memory",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mlcp_alloc_working_memory" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "mlcp_alloc_working_memory" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)mlcp_alloc_working_memory(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mlcp_free_working_memory(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:mlcp_free_working_memory",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mlcp_free_working_memory" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "mlcp_free_working_memory" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        mlcp_free_working_memory(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mlcp_driver_get_iwork(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:mlcp_driver_get_iwork",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mlcp_driver_get_iwork" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "mlcp_driver_get_iwork" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)mlcp_driver_get_iwork(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mlcp_driver_get_dwork(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:mlcp_driver_get_dwork",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mlcp_driver_get_dwork" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "mlcp_driver_get_dwork" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)mlcp_driver_get_dwork(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mlcp_pgs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:mlcp_pgs",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mlcp_pgs" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "mlcp_pgs" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        mlcp_pgs(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_mlcp_rpgs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:mlcp_rpgs",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mlcp_rpgs" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "mlcp_rpgs" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        mlcp_rpgs(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_mlcp_psor(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:mlcp_psor",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mlcp_psor" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "mlcp_psor" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        mlcp_psor(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_mlcp_rpsor(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:mlcp_rpsor",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mlcp_rpsor" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "mlcp_rpsor" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        mlcp_rpsor(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_mlcp_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:mlcp_path",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mlcp_path" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "mlcp_path" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        mlcp_path(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_mlcp_enum(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:mlcp_enum",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mlcp_enum" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "mlcp_enum" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        mlcp_enum(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_mlcp_direct(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:mlcp_direct",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mlcp_direct" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "mlcp_direct" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        mlcp_direct(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_mlcp_direct_enum(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:mlcp_direct_enum",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mlcp_direct_enum" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "mlcp_direct_enum" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        mlcp_direct_enum(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_mlcp_direct_simplex(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:mlcp_direct_simplex",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mlcp_direct_simplex" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "mlcp_direct_simplex" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        mlcp_direct_simplex(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_mlcp_direct_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:mlcp_direct_path",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mlcp_direct_path" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "mlcp_direct_path" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        mlcp_direct_path(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_mlcp_simplex(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:mlcp_simplex",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mlcp_simplex" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "mlcp_simplex" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        mlcp_simplex(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_mlcp_FB(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:mlcp_FB",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mlcp_FB" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "mlcp_FB" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        mlcp_FB(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_mlcp_direct_FB(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:mlcp_direct_FB",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mlcp_direct_FB" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "mlcp_direct_FB" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        mlcp_direct_FB(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_mlcp_pgs_SBM(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:mlcp_pgs_SBM",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mlcp_pgs_SBM" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "mlcp_pgs_SBM" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        mlcp_pgs_SBM(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_mixedLinearComplementarity_pgs_SBM_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:mixedLinearComplementarity_pgs_SBM_setDefaultSolverOptions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mixedLinearComplementarity_pgs_SBM_setDefaultSolverOptions" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "mixedLinearComplementarity_pgs_SBM_setDefaultSolverOptions" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)mixedLinearComplementarity_pgs_SBM_setDefaultSolverOptions(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mlcp_compute_error(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double arg4 ;
  double *arg5 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  double temp5 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  int result;
  
  {
    arg5 = &temp5;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:mlcp_compute_error",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mlcp_compute_error" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  ecode4 = SWIG_AsVal_double(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "mlcp_compute_error" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)mlcp_compute_error(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_double(*arg5);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_mixedLinearComplementarity_default_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:mixedLinearComplementarity_default_setDefaultSolverOptions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mixedLinearComplementarity_default_setDefaultSolverOptions" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "mixedLinearComplementarity_default_setDefaultSolverOptions" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        mixedLinearComplementarity_default_setDefaultSolverOptions(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mixedLinearComplementarity_deleteDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:mixedLinearComplementarity_deleteDefaultSolverOptions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mixedLinearComplementarity_deleteDefaultSolverOptions" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "mixedLinearComplementarity_deleteDefaultSolverOptions" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        mixedLinearComplementarity_deleteDefaultSolverOptions(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mixedLinearComplementarity_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:mixedLinearComplementarity_setDefaultSolverOptions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mixedLinearComplementarity_setDefaultSolverOptions" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "mixedLinearComplementarity_setDefaultSolverOptions" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)mixedLinearComplementarity_setDefaultSolverOptions(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mixedLinearComplementarity_directEnum_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:mixedLinearComplementarity_directEnum_setDefaultSolverOptions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mixedLinearComplementarity_directEnum_setDefaultSolverOptions" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "mixedLinearComplementarity_directEnum_setDefaultSolverOptions" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)mixedLinearComplementarity_directEnum_setDefaultSolverOptions(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mixedLinearComplementarity_directFB_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:mixedLinearComplementarity_directFB_setDefaultSolverOptions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mixedLinearComplementarity_directFB_setDefaultSolverOptions" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "mixedLinearComplementarity_directFB_setDefaultSolverOptions" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)mixedLinearComplementarity_directFB_setDefaultSolverOptions(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mixedLinearComplementarity_directPath_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:mixedLinearComplementarity_directPath_setDefaultSolverOptions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mixedLinearComplementarity_directPath_setDefaultSolverOptions" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "mixedLinearComplementarity_directPath_setDefaultSolverOptions" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)mixedLinearComplementarity_directPath_setDefaultSolverOptions(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mixedLinearComplementarity_directPathEnum_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:mixedLinearComplementarity_directPathEnum_setDefaultSolverOptions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mixedLinearComplementarity_directPathEnum_setDefaultSolverOptions" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "mixedLinearComplementarity_directPathEnum_setDefaultSolverOptions" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)mixedLinearComplementarity_directPathEnum_setDefaultSolverOptions(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mixedLinearComplementarity_directSimplex_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:mixedLinearComplementarity_directSimplex_setDefaultSolverOptions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mixedLinearComplementarity_directSimplex_setDefaultSolverOptions" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "mixedLinearComplementarity_directSimplex_setDefaultSolverOptions" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)mixedLinearComplementarity_directSimplex_setDefaultSolverOptions(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mixedLinearComplementarity_enum_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:mixedLinearComplementarity_enum_setDefaultSolverOptions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mixedLinearComplementarity_enum_setDefaultSolverOptions" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "mixedLinearComplementarity_enum_setDefaultSolverOptions" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)mixedLinearComplementarity_enum_setDefaultSolverOptions(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mixedLinearComplementarity_fb_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:mixedLinearComplementarity_fb_setDefaultSolverOptions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mixedLinearComplementarity_fb_setDefaultSolverOptions" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "mixedLinearComplementarity_fb_setDefaultSolverOptions" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)mixedLinearComplementarity_fb_setDefaultSolverOptions(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mixedLinearComplementarity_path_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:mixedLinearComplementarity_path_setDefaultSolverOptions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mixedLinearComplementarity_path_setDefaultSolverOptions" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "mixedLinearComplementarity_path_setDefaultSolverOptions" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)mixedLinearComplementarity_path_setDefaultSolverOptions(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mixedLinearComplementarity_pathEnum_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:mixedLinearComplementarity_pathEnum_setDefaultSolverOptions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mixedLinearComplementarity_pathEnum_setDefaultSolverOptions" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "mixedLinearComplementarity_pathEnum_setDefaultSolverOptions" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)mixedLinearComplementarity_pathEnum_setDefaultSolverOptions(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mixedLinearComplementarity_pgs_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:mixedLinearComplementarity_pgs_setDefaultSolverOptions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mixedLinearComplementarity_pgs_setDefaultSolverOptions" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "mixedLinearComplementarity_pgs_setDefaultSolverOptions" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)mixedLinearComplementarity_pgs_setDefaultSolverOptions(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mixedLinearComplementarity_rpgs_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:mixedLinearComplementarity_rpgs_setDefaultSolverOptions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mixedLinearComplementarity_rpgs_setDefaultSolverOptions" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "mixedLinearComplementarity_rpgs_setDefaultSolverOptions" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)mixedLinearComplementarity_rpgs_setDefaultSolverOptions(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mixedLinearComplementarity_simplex_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:mixedLinearComplementarity_simplex_setDefaultSolverOptions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mixedLinearComplementarity_simplex_setDefaultSolverOptions" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "mixedLinearComplementarity_simplex_setDefaultSolverOptions" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)mixedLinearComplementarity_simplex_setDefaultSolverOptions(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mixedLinearComplementarity_rpsor_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:mixedLinearComplementarity_rpsor_setDefaultSolverOptions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mixedLinearComplementarity_rpsor_setDefaultSolverOptions" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "mixedLinearComplementarity_rpsor_setDefaultSolverOptions" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)mixedLinearComplementarity_rpsor_setDefaultSolverOptions(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mixedLinearComplementarity_psor_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedLinearComplementarityProblem *arg1 = (MixedLinearComplementarityProblem *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:mixedLinearComplementarity_psor_setDefaultSolverOptions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mixedLinearComplementarity_psor_setDefaultSolverOptions" "', argument " "1"" of type '" "MixedLinearComplementarityProblem *""'"); 
  }
  arg1 = (MixedLinearComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "mixedLinearComplementarity_psor_setDefaultSolverOptions" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)mixedLinearComplementarity_psor_setDefaultSolverOptions(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_LCP_size_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct LinearComplementarityProblem *arg1 = (struct LinearComplementarityProblem *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:LCP_size_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LCP_size_set" "', argument " "1"" of type '" "struct LinearComplementarityProblem *""'"); 
  }
  arg1 = (struct LinearComplementarityProblem *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "LCP_size_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->size = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_LCP_size_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct LinearComplementarityProblem *arg1 = (struct LinearComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:LCP_size_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LCP_size_get" "', argument " "1"" of type '" "struct LinearComplementarityProblem *""'"); 
  }
  arg1 = (struct LinearComplementarityProblem *)(argp1);
  result = (int) ((arg1)->size);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_LCP_M_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct LinearComplementarityProblem *arg1 = (struct LinearComplementarityProblem *) 0 ;
  NumericsMatrix *arg2 = (NumericsMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array_2 = NULL ;
  int array_ctrl_2 = 0 ;
  PyArrayObject *array_i_2 = NULL ;
  int array_i_ctrl_2 = 0 ;
  PyArrayObject *array_p_2 = NULL ;
  int array_p_ctrl_2 = 0 ;
  int alloc_ctrl_2 = 0 ;
  NumericsMatrix *nummat2 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:LCP_M_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LCP_M_set" "', argument " "1"" of type '" "struct LinearComplementarityProblem *""'"); 
  }
  arg1 = (struct LinearComplementarityProblem *)(argp1);
  {
    arg2 = NM_convert_from_python(obj1, &nummat2, &array_2, &array_ctrl_2, &array_i_2, &array_i_ctrl_2, &array_p_2, &array_p_ctrl_2, &alloc_ctrl_2);
    
    
    
    
    
    if (!arg2) {
      SWIG_fail; 
    }
  }
  {
    //  %typemap(memberin) (NumericsMatrix*)
    // perform a deep copy
    if (!arg1->M) {
      arg1->M = NM_create(arg2->storageType, arg2->size0, arg2->size1); 
    }
    NM_copy(arg2, arg1->M);
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_LCP_M_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct LinearComplementarityProblem *arg1 = (struct LinearComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  NumericsMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:LCP_M_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LCP_M_get" "', argument " "1"" of type '" "struct LinearComplementarityProblem *""'"); 
  }
  arg1 = (struct LinearComplementarityProblem *)(argp1);
  result = (NumericsMatrix *) ((arg1)->M);
  {
    if (strcmp("LCP_M_get", "new_NumericsMatrix"))
    {
      resultobj = NM_to_python(result);
      
      
      
      if (!resultobj) SWIG_fail;
    }
    else
    {
      resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NumericsMatrix, SWIG_POINTER_NEW |  0 );
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_LCP_q_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct LinearComplementarityProblem *arg1 = (struct LinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:LCP_q_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LCP_q_set" "', argument " "1"" of type '" "struct LinearComplementarityProblem *""'"); 
  }
  arg1 = (struct LinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    // Still some dark magic :( --xhub
    char msg[1024];
    assert(arg1);
    if (!arg1->M)
    {
      SWIG_exception_fail(SWIG_RuntimeError, "M is not initialized, it sould be done first!");
    }
    
    int size = arg1->M->size0;
    if (size !=  array_size(array2, 0))
    {
      snprintf(msg, sizeof(msg), "Size of q is %ld, but the size of M is %d! Both should be equal!\n", array_size(array2, 0), size);
      SWIG_exception_fail(SWIG_RuntimeError, msg);
    }
    
    if (!arg1->q) {
      arg1->q = (double*)malloc(size * sizeof(double)); 
    }
    memcpy(arg1->q, arg2, size * sizeof(double));
    
  }
  resultobj = SWIG_Py_Void();
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_LCP_q_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct LinearComplementarityProblem *arg1 = (struct LinearComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:LCP_q_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LCP_q_get" "', argument " "1"" of type '" "struct LinearComplementarityProblem *""'"); 
  }
  arg1 = (struct LinearComplementarityProblem *)(argp1);
  result = (double *) ((arg1)->q);
  {
    if (!arg1->M) {
      SWIG_exception_fail(SWIG_RuntimeError, "M is not present, don't known the size"); 
    }
    
    if (result)
    {
      PyObject *obj;
      C_to_target_lang1(obj, arg1->M->size0, result, SWIG_fail);
      resultobj = obj;
    }
    else
    SWIG_fail;
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_LCP(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  struct LinearComplementarityProblem *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_LCP",&obj0,&obj1)) SWIG_fail;
  arg1 = obj0;
  arg2 = obj1;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct LinearComplementarityProblem *)new_LinearComplementarityProblem(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LinearComplementarityProblem, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_LCP(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct LinearComplementarityProblem *arg1 = (struct LinearComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_LCP",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_LCP" "', argument " "1"" of type '" "struct LinearComplementarityProblem *""'"); 
  }
  arg1 = (struct LinearComplementarityProblem *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        delete_LinearComplementarityProblem(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *LCP_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_LinearComplementarityProblem, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_linearComplementarity_display(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LinearComplementarityProblem *arg1 = (LinearComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:linearComplementarity_display",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "linearComplementarity_display" "', argument " "1"" of type '" "LinearComplementarityProblem *""'"); 
  }
  arg1 = (LinearComplementarityProblem *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        linearComplementarity_display(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_linearComplementarity_printInFile(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LinearComplementarityProblem *arg1 = (LinearComplementarityProblem *) 0 ;
  FILE *arg2 = (FILE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:linearComplementarity_printInFile",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "linearComplementarity_printInFile" "', argument " "1"" of type '" "LinearComplementarityProblem *""'"); 
  }
  arg1 = (LinearComplementarityProblem *)(argp1);
  {
    // %typemap(in) (FILE *file)
    int alloc = 1;
    char* cstr;
    int res = SWIG_AsCharPtrAndSize(obj1, &cstr, NULL, &alloc);
    if (!SWIG_IsOK(res)) {
      SWIG_Error(SWIG_ArgError(res), "in method unknown', argument " "1"" of type '" "char *""'");
    }
    arg2 = fopen(cstr, "r");
    if (!arg2)
    {
      SWIG_Error(SWIG_IOError, format_msg_concat("in method '" "linearComplementarity_printInFile" "' cannot fopen file", cstr));
      if (alloc == SWIG_NEWOBJ) free(cstr);
      SWIG_fail;
    }
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)linearComplementarity_printInFile(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_linearComplementarity_newFromFile(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LinearComplementarityProblem *arg1 = (LinearComplementarityProblem *) 0 ;
  FILE *arg2 = (FILE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:linearComplementarity_newFromFile",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "linearComplementarity_newFromFile" "', argument " "1"" of type '" "LinearComplementarityProblem *""'"); 
  }
  arg1 = (LinearComplementarityProblem *)(argp1);
  {
    // %typemap(in) (FILE *file)
    int alloc = 1;
    char* cstr;
    int res = SWIG_AsCharPtrAndSize(obj1, &cstr, NULL, &alloc);
    if (!SWIG_IsOK(res)) {
      SWIG_Error(SWIG_ArgError(res), "in method unknown', argument " "1"" of type '" "char *""'");
    }
    arg2 = fopen(cstr, "r");
    if (!arg2)
    {
      SWIG_Error(SWIG_IOError, format_msg_concat("in method '" "linearComplementarity_newFromFile" "' cannot fopen file", cstr));
      if (alloc == SWIG_NEWOBJ) free(cstr);
      SWIG_fail;
    }
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)linearComplementarity_newFromFile(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_linearComplementarity_newFromFilename(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LinearComplementarityProblem *arg1 = (LinearComplementarityProblem *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:linearComplementarity_newFromFilename",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "linearComplementarity_newFromFilename" "', argument " "1"" of type '" "LinearComplementarityProblem *""'"); 
  }
  arg1 = (LinearComplementarityProblem *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "linearComplementarity_newFromFilename" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)linearComplementarity_newFromFilename(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_freeLinearComplementarityProblem(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LinearComplementarityProblem *arg1 = (LinearComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:freeLinearComplementarityProblem",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "freeLinearComplementarityProblem" "', argument " "1"" of type '" "LinearComplementarityProblem *""'"); 
  }
  arg1 = (LinearComplementarityProblem *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        freeLinearComplementarityProblem(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_newLCP(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LinearComplementarityProblem *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":newLCP")) SWIG_fail;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (LinearComplementarityProblem *)newLCP();
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_linearComplementarity_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LinearComplementarityProblem *arg1 = (LinearComplementarityProblem *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:linearComplementarity_setDefaultSolverOptions",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "linearComplementarity_setDefaultSolverOptions" "', argument " "1"" of type '" "LinearComplementarityProblem *""'"); 
  }
  arg1 = (LinearComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "linearComplementarity_setDefaultSolverOptions" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "linearComplementarity_setDefaultSolverOptions" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)linearComplementarity_setDefaultSolverOptions(arg1,arg2,arg3);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_lcp_qp(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LinearComplementarityProblem *arg1 = (LinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:lcp_qp",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lcp_qp" "', argument " "1"" of type '" "LinearComplementarityProblem *""'"); 
  }
  arg1 = (LinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "lcp_qp" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        lcp_qp(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_linearComplementarity_qp_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:linearComplementarity_qp_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "linearComplementarity_qp_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)linearComplementarity_qp_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_lcp_cpg(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LinearComplementarityProblem *arg1 = (LinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:lcp_cpg",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lcp_cpg" "', argument " "1"" of type '" "LinearComplementarityProblem *""'"); 
  }
  arg1 = (LinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "lcp_cpg" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        lcp_cpg(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_linearComplementarity_cpg_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:linearComplementarity_cpg_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "linearComplementarity_cpg_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)linearComplementarity_cpg_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_lcp_pgs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LinearComplementarityProblem *arg1 = (LinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:lcp_pgs",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lcp_pgs" "', argument " "1"" of type '" "LinearComplementarityProblem *""'"); 
  }
  arg1 = (LinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "lcp_pgs" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        lcp_pgs(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_linearComplementarity_pgs_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:linearComplementarity_pgs_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "linearComplementarity_pgs_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)linearComplementarity_pgs_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_lcp_rpgs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LinearComplementarityProblem *arg1 = (LinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:lcp_rpgs",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lcp_rpgs" "', argument " "1"" of type '" "LinearComplementarityProblem *""'"); 
  }
  arg1 = (LinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "lcp_rpgs" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        lcp_rpgs(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_linearComplementarity_rpgs_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:linearComplementarity_rpgs_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "linearComplementarity_rpgs_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)linearComplementarity_rpgs_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_lcp_psor(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LinearComplementarityProblem *arg1 = (LinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:lcp_psor",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lcp_psor" "', argument " "1"" of type '" "LinearComplementarityProblem *""'"); 
  }
  arg1 = (LinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "lcp_psor" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        lcp_psor(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_linearComplementarity_psor_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:linearComplementarity_psor_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "linearComplementarity_psor_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)linearComplementarity_psor_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_lcp_nsqp(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LinearComplementarityProblem *arg1 = (LinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:lcp_nsqp",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lcp_nsqp" "', argument " "1"" of type '" "LinearComplementarityProblem *""'"); 
  }
  arg1 = (LinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "lcp_nsqp" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        lcp_nsqp(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_linearComplementarity_nsqp_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:linearComplementarity_nsqp_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "linearComplementarity_nsqp_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)linearComplementarity_nsqp_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_lcp_latin(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LinearComplementarityProblem *arg1 = (LinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:lcp_latin",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lcp_latin" "', argument " "1"" of type '" "LinearComplementarityProblem *""'"); 
  }
  arg1 = (LinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "lcp_latin" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        lcp_latin(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_linearComplementarity_latin_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:linearComplementarity_latin_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "linearComplementarity_latin_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)linearComplementarity_latin_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_lcp_latin_w(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LinearComplementarityProblem *arg1 = (LinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:lcp_latin_w",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lcp_latin_w" "', argument " "1"" of type '" "LinearComplementarityProblem *""'"); 
  }
  arg1 = (LinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "lcp_latin_w" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        lcp_latin_w(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_linearComplementarity_latin_w_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:linearComplementarity_latin_w_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "linearComplementarity_latin_w_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)linearComplementarity_latin_w_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_lcp_lexicolemke(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LinearComplementarityProblem *arg1 = (LinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:lcp_lexicolemke",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lcp_lexicolemke" "', argument " "1"" of type '" "LinearComplementarityProblem *""'"); 
  }
  arg1 = (LinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "lcp_lexicolemke" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        lcp_lexicolemke(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_linearComplementarity_lexicolemke_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:linearComplementarity_lexicolemke_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "linearComplementarity_lexicolemke_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)linearComplementarity_lexicolemke_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_lcp_newton_min(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LinearComplementarityProblem *arg1 = (LinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:lcp_newton_min",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lcp_newton_min" "', argument " "1"" of type '" "LinearComplementarityProblem *""'"); 
  }
  arg1 = (LinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "lcp_newton_min" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        lcp_newton_min(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_linearComplementarity_newton_min_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:linearComplementarity_newton_min_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "linearComplementarity_newton_min_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)linearComplementarity_newton_min_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_lcp_newton_FB(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LinearComplementarityProblem *arg1 = (LinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:lcp_newton_FB",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lcp_newton_FB" "', argument " "1"" of type '" "LinearComplementarityProblem *""'"); 
  }
  arg1 = (LinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "lcp_newton_FB" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        lcp_newton_FB(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_lcp_newton_minFB(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LinearComplementarityProblem *arg1 = (LinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:lcp_newton_minFB",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lcp_newton_minFB" "', argument " "1"" of type '" "LinearComplementarityProblem *""'"); 
  }
  arg1 = (LinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "lcp_newton_minFB" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        lcp_newton_minFB(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_lcp_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LinearComplementarityProblem *arg1 = (LinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:lcp_path",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lcp_path" "', argument " "1"" of type '" "LinearComplementarityProblem *""'"); 
  }
  arg1 = (LinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "lcp_path" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        lcp_path(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_lcp_enum(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LinearComplementarityProblem *arg1 = (LinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:lcp_enum",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lcp_enum" "', argument " "1"" of type '" "LinearComplementarityProblem *""'"); 
  }
  arg1 = (LinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "lcp_enum" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        lcp_enum(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_lcp_enum_init(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LinearComplementarityProblem *arg1 = (LinearComplementarityProblem *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:lcp_enum_init",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lcp_enum_init" "', argument " "1"" of type '" "LinearComplementarityProblem *""'"); 
  }
  arg1 = (LinearComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lcp_enum_init" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "lcp_enum_init" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        lcp_enum_init(arg1,arg2,arg3);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_lcp_enum_reset(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LinearComplementarityProblem *arg1 = (LinearComplementarityProblem *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:lcp_enum_reset",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lcp_enum_reset" "', argument " "1"" of type '" "LinearComplementarityProblem *""'"); 
  }
  arg1 = (LinearComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lcp_enum_reset" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "lcp_enum_reset" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        lcp_enum_reset(arg1,arg2,arg3);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_linearComplementarity_enum_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LinearComplementarityProblem *arg1 = (LinearComplementarityProblem *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:linearComplementarity_enum_setDefaultSolverOptions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "linearComplementarity_enum_setDefaultSolverOptions" "', argument " "1"" of type '" "LinearComplementarityProblem *""'"); 
  }
  arg1 = (LinearComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "linearComplementarity_enum_setDefaultSolverOptions" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)linearComplementarity_enum_setDefaultSolverOptions(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_lcp_avi_caoferris(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LinearComplementarityProblem *arg1 = (LinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:lcp_avi_caoferris",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lcp_avi_caoferris" "', argument " "1"" of type '" "LinearComplementarityProblem *""'"); 
  }
  arg1 = (LinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "lcp_avi_caoferris" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        lcp_avi_caoferris(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_lcp_pivot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LinearComplementarityProblem *arg1 = (LinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:lcp_pivot",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lcp_pivot" "', argument " "1"" of type '" "LinearComplementarityProblem *""'"); 
  }
  arg1 = (LinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "lcp_pivot" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        lcp_pivot(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_lcp_pivot_covering_vector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LinearComplementarityProblem *arg1 = (LinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  double *arg6 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:lcp_pivot_covering_vector",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lcp_pivot_covering_vector" "', argument " "1"" of type '" "LinearComplementarityProblem *""'"); 
  }
  arg1 = (LinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "lcp_pivot_covering_vector" "', argument " "3"" of type '" "double *""'"); 
  }
  arg3 = (double *)(argp3);
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "lcp_pivot_covering_vector" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  res6 = SWIG_ConvertPtr(obj4, &argp6,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "lcp_pivot_covering_vector" "', argument " "6"" of type '" "double *""'"); 
  }
  arg6 = (double *)(argp6);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        lcp_pivot_covering_vector(arg1,arg2,arg3,arg4,arg5,arg6);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_lcp_pivot_lumod(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LinearComplementarityProblem *arg1 = (LinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:lcp_pivot_lumod",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lcp_pivot_lumod" "', argument " "1"" of type '" "LinearComplementarityProblem *""'"); 
  }
  arg1 = (LinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "lcp_pivot_lumod" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        lcp_pivot_lumod(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_lcp_pivot_lumod_covering_vector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LinearComplementarityProblem *arg1 = (LinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  double *arg6 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:lcp_pivot_lumod_covering_vector",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lcp_pivot_lumod_covering_vector" "', argument " "1"" of type '" "LinearComplementarityProblem *""'"); 
  }
  arg1 = (LinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "lcp_pivot_lumod_covering_vector" "', argument " "3"" of type '" "double *""'"); 
  }
  arg3 = (double *)(argp3);
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "lcp_pivot_lumod_covering_vector" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  res6 = SWIG_ConvertPtr(obj4, &argp6,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "lcp_pivot_lumod_covering_vector" "', argument " "6"" of type '" "double *""'"); 
  }
  arg6 = (double *)(argp6);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        lcp_pivot_lumod_covering_vector(arg1,arg2,arg3,arg4,arg5,arg6);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_lcp_pathsearch(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LinearComplementarityProblem *arg1 = (LinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:lcp_pathsearch",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lcp_pathsearch" "', argument " "1"" of type '" "LinearComplementarityProblem *""'"); 
  }
  arg1 = (LinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "lcp_pathsearch" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        lcp_pathsearch(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_lcp_gams(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LinearComplementarityProblem *arg1 = (LinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:lcp_gams",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lcp_gams" "', argument " "1"" of type '" "LinearComplementarityProblem *""'"); 
  }
  arg1 = (LinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "lcp_gams" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        lcp_gams(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_lcp_nsgs_SBM(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LinearComplementarityProblem *arg1 = (LinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:lcp_nsgs_SBM",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lcp_nsgs_SBM" "', argument " "1"" of type '" "LinearComplementarityProblem *""'"); 
  }
  arg1 = (LinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "lcp_nsgs_SBM" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        lcp_nsgs_SBM(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_linearComplementarity_nsgs_SBM_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:linearComplementarity_nsgs_SBM_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "linearComplementarity_nsgs_SBM_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)linearComplementarity_nsgs_SBM_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_lcp_nsgs_SBM_buildLocalProblem(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  SparseBlockStructuredMatrix *arg2 = (SparseBlockStructuredMatrix *) (SparseBlockStructuredMatrix *)0 ;
  LinearComplementarityProblem *arg3 = (LinearComplementarityProblem *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyArrayObject *array4 = NULL ;
  int is_new_object4 = 0 ;
  PyArrayObject *array5 = NULL ;
  int is_new_object5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:lcp_nsgs_SBM_buildLocalProblem",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "lcp_nsgs_SBM_buildLocalProblem" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SparseBlockStructuredMatrix, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lcp_nsgs_SBM_buildLocalProblem" "', argument " "2"" of type '" "SparseBlockStructuredMatrix *const""'"); 
  }
  arg2 = (SparseBlockStructuredMatrix *)(argp2);
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "lcp_nsgs_SBM_buildLocalProblem" "', argument " "3"" of type '" "LinearComplementarityProblem *""'"); 
  }
  arg3 = (LinearComplementarityProblem *)(argp3);
  {
    array4 = obj_to_sn_vector(obj3, &is_new_object4);
    
    if (!array4)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array4))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg4 = (double *) array_data(array4);
    
  }
  {
    array5 = obj_to_sn_vector(obj4, &is_new_object5);
    
    if (!array5)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array5))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg5 = (double *) array_data(array5);
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        lcp_nsgs_SBM_buildLocalProblem(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  {
    
  }
  return resultobj;
fail:
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  {
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_lcp_compute_error(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LinearComplementarityProblem *arg1 = (LinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double arg4 ;
  double *arg5 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  double temp5 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  int result;
  
  {
    arg5 = &temp5;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:lcp_compute_error",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lcp_compute_error" "', argument " "1"" of type '" "LinearComplementarityProblem *""'"); 
  }
  arg1 = (LinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  ecode4 = SWIG_AsVal_double(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "lcp_compute_error" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)lcp_compute_error(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_double(*arg5);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_lcp_driver_DenseMatrix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LinearComplementarityProblem *arg1 = (LinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  SolverOptions *arg4 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:lcp_driver_DenseMatrix",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lcp_driver_DenseMatrix" "', argument " "1"" of type '" "LinearComplementarityProblem *""'"); 
  }
  arg1 = (LinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "lcp_driver_DenseMatrix" "', argument " "4"" of type '" "SolverOptions *""'"); 
  }
  arg4 = (SolverOptions *)(argp4);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)lcp_driver_DenseMatrix(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_lcp_ConvexQP_ProjectedGradient(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LinearComplementarityProblem *arg1 = (LinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:lcp_ConvexQP_ProjectedGradient",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lcp_ConvexQP_ProjectedGradient" "', argument " "1"" of type '" "LinearComplementarityProblem *""'"); 
  }
  arg1 = (LinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "lcp_ConvexQP_ProjectedGradient" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        lcp_ConvexQP_ProjectedGradient(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_linearComplementarity_ConvexQP_ProjectedGradient_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:linearComplementarity_ConvexQP_ProjectedGradient_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "linearComplementarity_ConvexQP_ProjectedGradient_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)linearComplementarity_ConvexQP_ProjectedGradient_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int Swig_var_SICONOS_LCP_LEMKE_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_LCP_LEMKE_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_LCP_LEMKE_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_LCP_LEMKE_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_LCP_NSGS_SBM_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_LCP_NSGS_SBM_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_LCP_NSGS_SBM_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_LCP_NSGS_SBM_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_LCP_PGS_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_LCP_PGS_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_LCP_PGS_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_LCP_PGS_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_LCP_CPG_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_LCP_CPG_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_LCP_CPG_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_LCP_CPG_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_LCP_LATIN_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_LCP_LATIN_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_LCP_LATIN_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_LCP_LATIN_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_LCP_LATIN_W_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_LCP_LATIN_W_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_LCP_LATIN_W_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_LCP_LATIN_W_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_LCP_QP_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_LCP_QP_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_LCP_QP_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_LCP_QP_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_LCP_NSQP_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_LCP_NSQP_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_LCP_NSQP_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_LCP_NSQP_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_LCP_NEWTONMIN_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_LCP_NEWTONMIN_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_LCP_NEWTONMIN_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_LCP_NEWTONMIN_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_LCP_NEWTON_FBLSA_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_LCP_NEWTON_FBLSA_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_LCP_NEWTON_FBLSA_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_LCP_NEWTON_FBLSA_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_LCP_NEWTON_MINFBLSA_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_LCP_NEWTON_MINFBLSA_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_LCP_NEWTON_MINFBLSA_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_LCP_NEWTON_MINFBLSA_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_LCP_PSOR_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_LCP_PSOR_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_LCP_PSOR_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_LCP_PSOR_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_LCP_RPGS_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_LCP_RPGS_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_LCP_RPGS_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_LCP_RPGS_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_LCP_PATH_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_LCP_PATH_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_LCP_PATH_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_LCP_PATH_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_LCP_ENUM_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_LCP_ENUM_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_LCP_ENUM_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_LCP_ENUM_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_LCP_AVI_CAOFERRIS_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_LCP_AVI_CAOFERRIS_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_LCP_AVI_CAOFERRIS_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_LCP_AVI_CAOFERRIS_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_LCP_PIVOT_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_LCP_PIVOT_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_LCP_PIVOT_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_LCP_PIVOT_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_LCP_BARD_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_LCP_BARD_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_LCP_BARD_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_LCP_BARD_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_LCP_MURTY_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_LCP_MURTY_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_LCP_MURTY_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_LCP_MURTY_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_LCP_PATHSEARCH_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_LCP_PATHSEARCH_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_LCP_PATHSEARCH_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_LCP_PATHSEARCH_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_LCP_PIVOT_LUMOD_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_LCP_PIVOT_LUMOD_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_LCP_PIVOT_LUMOD_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_LCP_PIVOT_LUMOD_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_LCP_GAMS_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_LCP_GAMS_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_LCP_GAMS_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_LCP_GAMS_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_LCP_CONVEXQP_PG_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_LCP_CONVEXQP_PG_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_LCP_CONVEXQP_PG_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_LCP_CONVEXQP_PG_STR);
  return pyobj;
}


SWIGINTERN PyObject *_wrap_AVI_size_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct AffineVariationalInequalities *arg1 = (struct AffineVariationalInequalities *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:AVI_size_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AffineVariationalInequalities, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AVI_size_set" "', argument " "1"" of type '" "struct AffineVariationalInequalities *""'"); 
  }
  arg1 = (struct AffineVariationalInequalities *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "AVI_size_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  if (arg1) (arg1)->size = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AVI_size_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct AffineVariationalInequalities *arg1 = (struct AffineVariationalInequalities *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AVI_size_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AffineVariationalInequalities, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AVI_size_get" "', argument " "1"" of type '" "struct AffineVariationalInequalities *""'"); 
  }
  arg1 = (struct AffineVariationalInequalities *)(argp1);
  result = (unsigned int) ((arg1)->size);
  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AVI_M_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct AffineVariationalInequalities *arg1 = (struct AffineVariationalInequalities *) 0 ;
  NumericsMatrix *arg2 = (NumericsMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array_2 = NULL ;
  int array_ctrl_2 = 0 ;
  PyArrayObject *array_i_2 = NULL ;
  int array_i_ctrl_2 = 0 ;
  PyArrayObject *array_p_2 = NULL ;
  int array_p_ctrl_2 = 0 ;
  int alloc_ctrl_2 = 0 ;
  NumericsMatrix *nummat2 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:AVI_M_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AffineVariationalInequalities, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AVI_M_set" "', argument " "1"" of type '" "struct AffineVariationalInequalities *""'"); 
  }
  arg1 = (struct AffineVariationalInequalities *)(argp1);
  {
    arg2 = NM_convert_from_python(obj1, &nummat2, &array_2, &array_ctrl_2, &array_i_2, &array_i_ctrl_2, &array_p_2, &array_p_ctrl_2, &alloc_ctrl_2);
    
    
    
    
    
    if (!arg2) {
      SWIG_fail; 
    }
  }
  {
    //  %typemap(memberin) (NumericsMatrix*)
    // perform a deep copy
    if (!arg1->M) {
      arg1->M = NM_create(arg2->storageType, arg2->size0, arg2->size1); 
    }
    NM_copy(arg2, arg1->M);
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_AVI_M_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct AffineVariationalInequalities *arg1 = (struct AffineVariationalInequalities *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  NumericsMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AVI_M_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AffineVariationalInequalities, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AVI_M_get" "', argument " "1"" of type '" "struct AffineVariationalInequalities *""'"); 
  }
  arg1 = (struct AffineVariationalInequalities *)(argp1);
  result = (NumericsMatrix *) ((arg1)->M);
  {
    if (strcmp("AVI_M_get", "new_NumericsMatrix"))
    {
      resultobj = NM_to_python(result);
      
      
      
      if (!resultobj) SWIG_fail;
    }
    else
    {
      resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NumericsMatrix, SWIG_POINTER_NEW |  0 );
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AVI_q_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct AffineVariationalInequalities *arg1 = (struct AffineVariationalInequalities *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:AVI_q_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AffineVariationalInequalities, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AVI_q_set" "', argument " "1"" of type '" "struct AffineVariationalInequalities *""'"); 
  }
  arg1 = (struct AffineVariationalInequalities *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    // Still some dark magic :( --xhub
    char msg[1024];
    assert(arg1);
    if (!arg1->M)
    {
      SWIG_exception_fail(SWIG_RuntimeError, "M is not initialized, it sould be done first!");
    }
    
    int size = arg1->M->size0;
    if (size !=  array_size(array2, 0))
    {
      snprintf(msg, sizeof(msg), "Size of q is %ld, but the size of M is %d! Both should be equal!\n", array_size(array2, 0), size);
      SWIG_exception_fail(SWIG_RuntimeError, msg);
    }
    
    if (!arg1->q) {
      arg1->q = (double*)malloc(size * sizeof(double)); 
    }
    memcpy(arg1->q, arg2, size * sizeof(double));
    
  }
  resultobj = SWIG_Py_Void();
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_AVI_q_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct AffineVariationalInequalities *arg1 = (struct AffineVariationalInequalities *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AVI_q_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AffineVariationalInequalities, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AVI_q_get" "', argument " "1"" of type '" "struct AffineVariationalInequalities *""'"); 
  }
  arg1 = (struct AffineVariationalInequalities *)(argp1);
  result = (double *) ((arg1)->q);
  {
    if (!arg1->M) {
      SWIG_exception_fail(SWIG_RuntimeError, "M is not present, don't known the size"); 
    }
    
    if (result)
    {
      PyObject *obj;
      C_to_target_lang1(obj, arg1->M->size0, result, SWIG_fail);
      resultobj = obj;
    }
    else
    SWIG_fail;
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AVI_d_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct AffineVariationalInequalities *arg1 = (struct AffineVariationalInequalities *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:AVI_d_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AffineVariationalInequalities, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AVI_d_set" "', argument " "1"" of type '" "struct AffineVariationalInequalities *""'"); 
  }
  arg1 = (struct AffineVariationalInequalities *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_double, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AVI_d_set" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = (double *)(argp2);
  if (arg1) (arg1)->d = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AVI_d_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct AffineVariationalInequalities *arg1 = (struct AffineVariationalInequalities *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AVI_d_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AffineVariationalInequalities, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AVI_d_get" "', argument " "1"" of type '" "struct AffineVariationalInequalities *""'"); 
  }
  arg1 = (struct AffineVariationalInequalities *)(argp1);
  result = (double *) ((arg1)->d);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AVI_poly_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct AffineVariationalInequalities *arg1 = (struct AffineVariationalInequalities *) 0 ;
  polyhedron_set arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:AVI_poly_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AffineVariationalInequalities, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AVI_poly_set" "', argument " "1"" of type '" "struct AffineVariationalInequalities *""'"); 
  }
  arg1 = (struct AffineVariationalInequalities *)(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_polyhedron_set,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AVI_poly_set" "', argument " "2"" of type '" "polyhedron_set""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "AVI_poly_set" "', argument " "2"" of type '" "polyhedron_set""'");
    } else {
      arg2 = *((polyhedron_set *)(argp2));
    }
  }
  if (arg1) (arg1)->poly = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AVI_poly_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct AffineVariationalInequalities *arg1 = (struct AffineVariationalInequalities *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  polyhedron_set result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AVI_poly_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AffineVariationalInequalities, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AVI_poly_get" "', argument " "1"" of type '" "struct AffineVariationalInequalities *""'"); 
  }
  arg1 = (struct AffineVariationalInequalities *)(argp1);
  result =  ((arg1)->poly);
  resultobj = SWIG_NewPointerObj((polyhedron_set *)memcpy((polyhedron_set *)calloc(1,sizeof(polyhedron_set)),&result,sizeof(polyhedron_set)), SWIGTYPE_p_polyhedron_set, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AVI_lb_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct AffineVariationalInequalities *arg1 = (struct AffineVariationalInequalities *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:AVI_lb_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AffineVariationalInequalities, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AVI_lb_set" "', argument " "1"" of type '" "struct AffineVariationalInequalities *""'"); 
  }
  arg1 = (struct AffineVariationalInequalities *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_double, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AVI_lb_set" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = (double *)(argp2);
  if (arg1) (arg1)->lb = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AVI_lb_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct AffineVariationalInequalities *arg1 = (struct AffineVariationalInequalities *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AVI_lb_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AffineVariationalInequalities, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AVI_lb_get" "', argument " "1"" of type '" "struct AffineVariationalInequalities *""'"); 
  }
  arg1 = (struct AffineVariationalInequalities *)(argp1);
  result = (double *) ((arg1)->lb);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AVI_ub_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct AffineVariationalInequalities *arg1 = (struct AffineVariationalInequalities *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:AVI_ub_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AffineVariationalInequalities, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AVI_ub_set" "', argument " "1"" of type '" "struct AffineVariationalInequalities *""'"); 
  }
  arg1 = (struct AffineVariationalInequalities *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_double, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AVI_ub_set" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = (double *)(argp2);
  if (arg1) (arg1)->ub = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AVI_ub_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct AffineVariationalInequalities *arg1 = (struct AffineVariationalInequalities *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AVI_ub_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AffineVariationalInequalities, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AVI_ub_get" "', argument " "1"" of type '" "struct AffineVariationalInequalities *""'"); 
  }
  arg1 = (struct AffineVariationalInequalities *)(argp1);
  result = (double *) ((arg1)->ub);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AVI_cones_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct AffineVariationalInequalities *arg1 = (struct AffineVariationalInequalities *) 0 ;
  void *arg2 = (void *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:AVI_cones_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AffineVariationalInequalities, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AVI_cones_set" "', argument " "1"" of type '" "struct AffineVariationalInequalities *""'"); 
  }
  arg1 = (struct AffineVariationalInequalities *)(argp1);
  res2 = SWIG_ConvertPtr(obj1,SWIG_as_voidptrptr(&arg2), 0, SWIG_POINTER_DISOWN);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AVI_cones_set" "', argument " "2"" of type '" "void *""'"); 
  }
  if (arg1) (arg1)->cones = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AVI_cones_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct AffineVariationalInequalities *arg1 = (struct AffineVariationalInequalities *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  void *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AVI_cones_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AffineVariationalInequalities, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AVI_cones_get" "', argument " "1"" of type '" "struct AffineVariationalInequalities *""'"); 
  }
  arg1 = (struct AffineVariationalInequalities *)(argp1);
  result = (void *) ((arg1)->cones);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_AVI__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct AffineVariationalInequalities *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_AVI")) SWIG_fail;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct AffineVariationalInequalities *)new_AffineVariationalInequalities__SWIG_0();
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_AffineVariationalInequalities, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_AVI__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  struct AffineVariationalInequalities *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_AVI",&obj0,&obj1)) SWIG_fail;
  arg1 = obj0;
  arg2 = obj1;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct AffineVariationalInequalities *)new_AffineVariationalInequalities__SWIG_1(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_AffineVariationalInequalities, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_AVI(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  Py_ssize_t ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = args ? PyObject_Length(args) : 0;
  for (ii = 0; (ii < 2) && (ii < argc); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_AVI__SWIG_0(self, args);
  }
  if (argc == 2) {
    int _v;
    _v = (argv[0] != 0);
    if (_v) {
      _v = (argv[1] != 0);
      if (_v) {
        return _wrap_new_AVI__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_AVI'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    AffineVariationalInequalities::AffineVariationalInequalities()\n"
    "    AffineVariationalInequalities::AffineVariationalInequalities(PyObject *,PyObject *)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_AVI_set_polyhedron(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct AffineVariationalInequalities *arg1 = (struct AffineVariationalInequalities *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:AVI_set_polyhedron",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AffineVariationalInequalities, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AVI_set_polyhedron" "', argument " "1"" of type '" "struct AffineVariationalInequalities *""'"); 
  }
  arg1 = (struct AffineVariationalInequalities *)(argp1);
  arg2 = obj1;
  arg3 = obj2;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        AffineVariationalInequalities_set_polyhedron(arg1,arg2,arg3);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_AVI(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct AffineVariationalInequalities *arg1 = (struct AffineVariationalInequalities *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_AVI",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AffineVariationalInequalities, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_AVI" "', argument " "1"" of type '" "struct AffineVariationalInequalities *""'"); 
  }
  arg1 = (struct AffineVariationalInequalities *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        delete_AffineVariationalInequalities(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *AVI_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_AffineVariationalInequalities, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_AVI_display(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  AffineVariationalInequalities *arg1 = (AffineVariationalInequalities *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AVI_display",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AffineVariationalInequalities, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AVI_display" "', argument " "1"" of type '" "AffineVariationalInequalities *""'"); 
  }
  arg1 = (AffineVariationalInequalities *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        AVI_display(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AVI_printInFile(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  AffineVariationalInequalities *arg1 = (AffineVariationalInequalities *) 0 ;
  FILE *arg2 = (FILE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:AVI_printInFile",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AffineVariationalInequalities, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AVI_printInFile" "', argument " "1"" of type '" "AffineVariationalInequalities *""'"); 
  }
  arg1 = (AffineVariationalInequalities *)(argp1);
  {
    // %typemap(in) (FILE *file)
    int alloc = 1;
    char* cstr;
    int res = SWIG_AsCharPtrAndSize(obj1, &cstr, NULL, &alloc);
    if (!SWIG_IsOK(res)) {
      SWIG_Error(SWIG_ArgError(res), "in method unknown', argument " "1"" of type '" "char *""'");
    }
    arg2 = fopen(cstr, "r");
    if (!arg2)
    {
      SWIG_Error(SWIG_IOError, format_msg_concat("in method '" "AVI_printInFile" "' cannot fopen file", cstr));
      if (alloc == SWIG_NEWOBJ) free(cstr);
      SWIG_fail;
    }
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)AVI_printInFile(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_AVI_newFromFile(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  AffineVariationalInequalities *arg1 = (AffineVariationalInequalities *) 0 ;
  FILE *arg2 = (FILE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:AVI_newFromFile",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AffineVariationalInequalities, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AVI_newFromFile" "', argument " "1"" of type '" "AffineVariationalInequalities *""'"); 
  }
  arg1 = (AffineVariationalInequalities *)(argp1);
  {
    // %typemap(in) (FILE *file)
    int alloc = 1;
    char* cstr;
    int res = SWIG_AsCharPtrAndSize(obj1, &cstr, NULL, &alloc);
    if (!SWIG_IsOK(res)) {
      SWIG_Error(SWIG_ArgError(res), "in method unknown', argument " "1"" of type '" "char *""'");
    }
    arg2 = fopen(cstr, "r");
    if (!arg2)
    {
      SWIG_Error(SWIG_IOError, format_msg_concat("in method '" "AVI_newFromFile" "' cannot fopen file", cstr));
      if (alloc == SWIG_NEWOBJ) free(cstr);
      SWIG_fail;
    }
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)AVI_newFromFile(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_AVI_newFromFilename(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  AffineVariationalInequalities *arg1 = (AffineVariationalInequalities *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:AVI_newFromFilename",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AffineVariationalInequalities, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AVI_newFromFilename" "', argument " "1"" of type '" "AffineVariationalInequalities *""'"); 
  }
  arg1 = (AffineVariationalInequalities *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AVI_newFromFilename" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)AVI_newFromFilename(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_freeAVI(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  AffineVariationalInequalities *arg1 = (AffineVariationalInequalities *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:freeAVI",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AffineVariationalInequalities, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "freeAVI" "', argument " "1"" of type '" "AffineVariationalInequalities *""'"); 
  }
  arg1 = (AffineVariationalInequalities *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        freeAVI(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_newAVI(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  AffineVariationalInequalities *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":newAVI")) SWIG_fail;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (AffineVariationalInequalities *)newAVI();
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_AffineVariationalInequalities, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_avi_caoferris(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  AffineVariationalInequalities *arg1 = (AffineVariationalInequalities *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  SolverOptions *arg4 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:avi_caoferris",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AffineVariationalInequalities, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avi_caoferris" "', argument " "1"" of type '" "AffineVariationalInequalities *""'"); 
  }
  arg1 = (AffineVariationalInequalities *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "avi_caoferris" "', argument " "4"" of type '" "SolverOptions *""'"); 
  }
  arg4 = (SolverOptions *)(argp4);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)avi_caoferris(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_avi_pathavi(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  AffineVariationalInequalities *arg1 = (AffineVariationalInequalities *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  SolverOptions *arg4 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:avi_pathavi",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AffineVariationalInequalities, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "avi_pathavi" "', argument " "1"" of type '" "AffineVariationalInequalities *""'"); 
  }
  arg1 = (AffineVariationalInequalities *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "avi_pathavi" "', argument " "4"" of type '" "SolverOptions *""'"); 
  }
  arg4 = (SolverOptions *)(argp4);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)avi_pathavi(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN int Swig_var_SICONOS_AVI_CAOFERRIS_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_AVI_CAOFERRIS_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_AVI_CAOFERRIS_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_AVI_CAOFERRIS_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_AVI_PATHAVI_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_AVI_PATHAVI_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_AVI_PATHAVI_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_AVI_PATHAVI_STR);
  return pyobj;
}


SWIGINTERN PyObject *_wrap_mixedLinearComplementarityProblemFromFile(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  PyObject * obj0 = 0 ;
  MixedLinearComplementarityProblem *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:mixedLinearComplementarityProblemFromFile",&obj0)) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mixedLinearComplementarityProblemFromFile" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = (char *)(buf1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (MixedLinearComplementarityProblem *)mixedLinearComplementarityProblemFromFile((char const *)arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_MixedLinearComplementarityProblem, 0 |  0 );
  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
  return resultobj;
fail:
  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
  return NULL;
}


SWIGINTERN int Swig_var_SICONOS_RELAY_PGS_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_RELAY_PGS_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_RELAY_PGS_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_RELAY_PGS_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_RELAY_PATH_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_RELAY_PATH_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_RELAY_PATH_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_RELAY_PATH_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_RELAY_ENUM_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_RELAY_ENUM_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_RELAY_ENUM_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_RELAY_ENUM_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_RELAY_NLGS_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_RELAY_NLGS_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_RELAY_NLGS_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_RELAY_NLGS_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_RELAY_LEMKE_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_RELAY_LEMKE_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_RELAY_LEMKE_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_RELAY_LEMKE_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_RELAY_LATIN_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_RELAY_LATIN_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_RELAY_LATIN_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_RELAY_LATIN_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_RELAY_AVI_CAOFERRIS_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_RELAY_AVI_CAOFERRIS_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_RELAY_AVI_CAOFERRIS_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_RELAY_AVI_CAOFERRIS_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_RELAY_AVI_CAOFERRIS_TEST_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_RELAY_AVI_CAOFERRIS_TEST_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_RELAY_AVI_CAOFERRIS_TEST_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_RELAY_AVI_CAOFERRIS_TEST_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_2D_NSGS_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_2D_NSGS_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_2D_NSGS_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_2D_NSGS_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_2D_PGS_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_2D_PGS_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_2D_PGS_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_2D_PGS_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_2D_CPG_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_2D_CPG_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_2D_CPG_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_2D_CPG_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_2D_LATIN_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_2D_LATIN_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_2D_LATIN_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_2D_LATIN_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_2D_LEMKE_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_2D_LEMKE_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_2D_LEMKE_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_2D_LEMKE_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_2D_ENUM_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_2D_ENUM_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_2D_ENUM_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_2D_ENUM_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_3D_NSGS_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_3D_NSGS_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_3D_NSGS_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_3D_NSGS_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_3D_NSGSV_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_3D_NSGSV_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_3D_NSGSV_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_3D_NSGSV_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_3D_PROX_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_3D_PROX_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_3D_PROX_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_3D_PROX_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_3D_TFP_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_3D_TFP_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_3D_TFP_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_3D_TFP_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_3D_PFP_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_3D_PFP_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_3D_PFP_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_3D_PFP_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_3D_NSN_AC_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_3D_NSN_AC_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_3D_NSN_AC_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_3D_NSN_AC_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_3D_NSN_AC_TEST_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_3D_NSN_AC_TEST_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_3D_NSN_AC_TEST_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_3D_NSN_AC_TEST_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_3D_NSN_FB_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_3D_NSN_FB_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_3D_NSN_FB_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_3D_NSN_FB_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_3D_NSN_NM_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_3D_NSN_NM_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_3D_NSN_NM_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_3D_NSN_NM_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_3D_DSFP_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_3D_DSFP_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_3D_DSFP_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_3D_DSFP_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_3D_VI_EG_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_3D_VI_EG_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_3D_VI_EG_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_3D_VI_EG_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_3D_VI_FPP_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_3D_VI_FPP_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_3D_VI_FPP_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_3D_VI_FPP_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_3D_EG_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_3D_EG_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_3D_EG_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_3D_EG_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_3D_FPP_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_3D_FPP_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_3D_FPP_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_3D_FPP_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_3D_HP_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_3D_HP_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_3D_HP_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_3D_HP_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_3D_NCPGlockerFBFixedPoint_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_3D_NCPGlockerFBFixedPoint_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_3D_NCPGlockerFBFixedPoint_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_3D_NCPGlockerFBFixedPoint_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_3D_ONECONTACT_NSN_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_3D_ONECONTACT_NSN_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_3D_ONECONTACT_NSN_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_3D_ONECONTACT_NSN_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_3D_ONECONTACT_NSN_GP_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_3D_ONECONTACT_NSN_GP_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_3D_ONECONTACT_NSN_GP_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_3D_ONECONTACT_NSN_GP_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_3D_ONECONTACT_NSN_GP_HYBRID_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_3D_ONECONTACT_NSN_GP_HYBRID_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_3D_ONECONTACT_NSN_GP_HYBRID_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_3D_ONECONTACT_NSN_GP_HYBRID_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_3D_NCPGlockerFBNewton_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_3D_NCPGlockerFBNewton_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_3D_NCPGlockerFBNewton_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_3D_NCPGlockerFBNewton_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnConeWithDiagonalization_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnConeWithDiagonalization_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnConeWithDiagonalization_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnConeWithDiagonalization_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnCone_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnCone_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnCone_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnCone_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnConeWithLocalIteration_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnConeWithLocalIteration_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnConeWithLocalIteration_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnConeWithLocalIteration_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnConeWithRegularization_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnConeWithRegularization_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnConeWithRegularization_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnConeWithRegularization_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_3D_NCPGlockerFBPATH_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_3D_NCPGlockerFBPATH_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_3D_NCPGlockerFBPATH_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_3D_NCPGlockerFBPATH_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnCylinder_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnCylinder_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnCylinder_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnCylinder_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnCone_velocity_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnCone_velocity_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnCone_velocity_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnCone_velocity_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_3D_ConvexQP_PG_Cylinder_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_3D_ConvexQP_PG_Cylinder_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_3D_ConvexQP_PG_Cylinder_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_3D_ConvexQP_PG_Cylinder_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_3D_VI_FPP_Cylinder_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_3D_VI_FPP_Cylinder_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_3D_VI_FPP_Cylinder_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_3D_VI_FPP_Cylinder_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_3D_DeSaxceFixedPoint_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_3D_DeSaxceFixedPoint_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_3D_DeSaxceFixedPoint_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_3D_DeSaxceFixedPoint_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_3D_GAMS_PATH_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_3D_GAMS_PATH_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_3D_GAMS_PATH_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_3D_GAMS_PATH_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_3D_GAMS_PATHVI_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_3D_GAMS_PATHVI_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_3D_GAMS_PATHVI_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_3D_GAMS_PATHVI_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_3D_GAMS_LCP_PATH_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_3D_GAMS_LCP_PATH_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_3D_GAMS_LCP_PATH_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_3D_GAMS_LCP_PATH_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_3D_GAMS_LCP_PATHVI_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_3D_GAMS_LCP_PATHVI_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_3D_GAMS_LCP_PATHVI_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_3D_GAMS_LCP_PATHVI_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_3D_SOCLCP_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_3D_SOCLCP_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_3D_SOCLCP_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_3D_SOCLCP_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_3D_ACLMFP_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_3D_ACLMFP_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_3D_ACLMFP_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_3D_ACLMFP_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_3D_ADMM_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_3D_ADMM_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_3D_ADMM_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_3D_ADMM_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_GLOBAL_FRICTION_3D_NSGS_WR_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_GLOBAL_FRICTION_3D_NSGS_WR_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_GLOBAL_FRICTION_3D_NSGS_WR_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_GLOBAL_FRICTION_3D_NSGS_WR_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_GLOBAL_FRICTION_3D_NSGSV_WR_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_GLOBAL_FRICTION_3D_NSGSV_WR_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_GLOBAL_FRICTION_3D_NSGSV_WR_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_GLOBAL_FRICTION_3D_NSGSV_WR_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_GLOBAL_FRICTION_3D_PROX_WR_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_GLOBAL_FRICTION_3D_PROX_WR_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_GLOBAL_FRICTION_3D_PROX_WR_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_GLOBAL_FRICTION_3D_PROX_WR_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_GLOBAL_FRICTION_3D_DSFP_WR_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_GLOBAL_FRICTION_3D_DSFP_WR_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_GLOBAL_FRICTION_3D_DSFP_WR_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_GLOBAL_FRICTION_3D_DSFP_WR_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_GLOBAL_FRICTION_3D_TFP_WR_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_GLOBAL_FRICTION_3D_TFP_WR_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_GLOBAL_FRICTION_3D_TFP_WR_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_GLOBAL_FRICTION_3D_TFP_WR_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_GLOBAL_FRICTION_3D_NSGS_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_GLOBAL_FRICTION_3D_NSGS_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_GLOBAL_FRICTION_3D_NSGS_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_GLOBAL_FRICTION_3D_NSGS_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_GLOBAL_FRICTION_3D_NSN_AC_WR_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_GLOBAL_FRICTION_3D_NSN_AC_WR_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_GLOBAL_FRICTION_3D_NSN_AC_WR_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_GLOBAL_FRICTION_3D_NSN_AC_WR_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_GLOBAL_FRICTION_3D_NSN_AC_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_GLOBAL_FRICTION_3D_NSN_AC_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_GLOBAL_FRICTION_3D_NSN_AC_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_GLOBAL_FRICTION_3D_NSN_AC_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_GLOBAL_FRICTION_3D_GAMS_PATH_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_GLOBAL_FRICTION_3D_GAMS_PATH_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_GLOBAL_FRICTION_3D_GAMS_PATH_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_GLOBAL_FRICTION_3D_GAMS_PATH_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_GLOBAL_FRICTION_3D_GAMS_PATHVI_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_GLOBAL_FRICTION_3D_GAMS_PATHVI_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_GLOBAL_FRICTION_3D_GAMS_PATHVI_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_GLOBAL_FRICTION_3D_GAMS_PATHVI_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_GLOBAL_FRICTION_3D_VI_FPP_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_GLOBAL_FRICTION_3D_VI_FPP_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_GLOBAL_FRICTION_3D_VI_FPP_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_GLOBAL_FRICTION_3D_VI_FPP_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_GLOBAL_FRICTION_3D_VI_EG_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_GLOBAL_FRICTION_3D_VI_EG_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_GLOBAL_FRICTION_3D_VI_EG_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_GLOBAL_FRICTION_3D_VI_EG_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_GLOBAL_FRICTION_3D_ACLMFP_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_GLOBAL_FRICTION_3D_ACLMFP_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_GLOBAL_FRICTION_3D_ACLMFP_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_GLOBAL_FRICTION_3D_ACLMFP_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_GLOBAL_FRICTION_3D_ADMM_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_GLOBAL_FRICTION_3D_ADMM_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_GLOBAL_FRICTION_3D_ADMM_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_GLOBAL_FRICTION_3D_ADMM_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_GLOBAL_FRICTION_3D_ADMM_WR_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_GLOBAL_FRICTION_3D_ADMM_WR_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_GLOBAL_FRICTION_3D_ADMM_WR_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_GLOBAL_FRICTION_3D_ADMM_WR_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_3D_ONECONTACT_QUARTIC_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_3D_ONECONTACT_QUARTIC_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_3D_ONECONTACT_QUARTIC_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_3D_ONECONTACT_QUARTIC_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_FRICTION_3D_ONECONTACT_QUARTIC_NU_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_FRICTION_3D_ONECONTACT_QUARTIC_NU_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_FRICTION_3D_ONECONTACT_QUARTIC_NU_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_FRICTION_3D_ONECONTACT_QUARTIC_NU_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_MCP_FB_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_MCP_FB_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_MCP_FB_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_MCP_FB_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_MCP_NEWTON_FBLSA_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_MCP_NEWTON_FBLSA_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_MCP_NEWTON_FBLSA_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_MCP_NEWTON_FBLSA_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_MCP_NEWTON_MINFBLSA_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_MCP_NEWTON_MINFBLSA_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_MCP_NEWTON_MINFBLSA_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_MCP_NEWTON_MINFBLSA_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_NCP_NEWTON_FBLSA_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_NCP_NEWTON_FBLSA_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_NCP_NEWTON_FBLSA_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_NCP_NEWTON_FBLSA_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_NCP_NEWTON_MINFBLSA_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_NCP_NEWTON_MINFBLSA_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_NCP_NEWTON_MINFBLSA_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_NCP_NEWTON_MINFBLSA_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_NCP_PATHSEARCH_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_NCP_PATHSEARCH_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_NCP_PATHSEARCH_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_NCP_PATHSEARCH_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_NCP_PATH_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_NCP_PATH_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_NCP_PATH_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_NCP_PATH_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_VI_EG_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_VI_EG_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_VI_EG_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_VI_EG_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_VI_FPP_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_VI_FPP_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_VI_FPP_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_VI_FPP_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_VI_HP_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_VI_HP_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_VI_HP_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_VI_HP_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_VI_BOX_QI_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_VI_BOX_QI_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_VI_BOX_QI_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_VI_BOX_QI_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_VI_BOX_AVI_LSA_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_VI_BOX_AVI_LSA_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_VI_BOX_AVI_LSA_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_VI_BOX_AVI_LSA_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_VI_BOX_PATH_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_VI_BOX_PATH_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_VI_BOX_PATH_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_VI_BOX_PATH_STR);
  return pyobj;
}


SWIGINTERN PyObject *_wrap_MCP_sizeEqualities_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedComplementarityProblem *arg1 = (struct MixedComplementarityProblem *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:MCP_sizeEqualities_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MCP_sizeEqualities_set" "', argument " "1"" of type '" "struct MixedComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedComplementarityProblem *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "MCP_sizeEqualities_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->sizeEqualities = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MCP_sizeEqualities_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedComplementarityProblem *arg1 = (struct MixedComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:MCP_sizeEqualities_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MCP_sizeEqualities_get" "', argument " "1"" of type '" "struct MixedComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedComplementarityProblem *)(argp1);
  result = (int) ((arg1)->sizeEqualities);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MCP_sizeInequalities_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedComplementarityProblem *arg1 = (struct MixedComplementarityProblem *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:MCP_sizeInequalities_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MCP_sizeInequalities_set" "', argument " "1"" of type '" "struct MixedComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedComplementarityProblem *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "MCP_sizeInequalities_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->sizeInequalities = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MCP_sizeInequalities_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedComplementarityProblem *arg1 = (struct MixedComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:MCP_sizeInequalities_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MCP_sizeInequalities_get" "', argument " "1"" of type '" "struct MixedComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedComplementarityProblem *)(argp1);
  result = (int) ((arg1)->sizeInequalities);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MCP_computeFmcp_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedComplementarityProblem *arg1 = (struct MixedComplementarityProblem *) 0 ;
  ptrFunctionMCP arg2 = (ptrFunctionMCP) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:MCP_computeFmcp_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MCP_computeFmcp_set" "', argument " "1"" of type '" "struct MixedComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedComplementarityProblem *)(argp1);
  {
    int res = SWIG_ConvertFunctionPtr(obj1, (void**)(&arg2), SWIGTYPE_p_f_int_p_double_p_double__void);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "MCP_computeFmcp_set" "', argument " "2"" of type '" "ptrFunctionMCP""'"); 
    }
  }
  if (arg1) (arg1)->computeFmcp = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MCP_computeFmcp_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedComplementarityProblem *arg1 = (struct MixedComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ptrFunctionMCP result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:MCP_computeFmcp_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MCP_computeFmcp_get" "', argument " "1"" of type '" "struct MixedComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedComplementarityProblem *)(argp1);
  result = (ptrFunctionMCP) ((arg1)->computeFmcp);
  resultobj = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_int_p_double_p_double__void);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MCP_computeNablaFmcp_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedComplementarityProblem *arg1 = (struct MixedComplementarityProblem *) 0 ;
  ptrFunctionMCP arg2 = (ptrFunctionMCP) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:MCP_computeNablaFmcp_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MCP_computeNablaFmcp_set" "', argument " "1"" of type '" "struct MixedComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedComplementarityProblem *)(argp1);
  {
    int res = SWIG_ConvertFunctionPtr(obj1, (void**)(&arg2), SWIGTYPE_p_f_int_p_double_p_double__void);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "MCP_computeNablaFmcp_set" "', argument " "2"" of type '" "ptrFunctionMCP""'"); 
    }
  }
  if (arg1) (arg1)->computeNablaFmcp = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MCP_computeNablaFmcp_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedComplementarityProblem *arg1 = (struct MixedComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ptrFunctionMCP result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:MCP_computeNablaFmcp_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MCP_computeNablaFmcp_get" "', argument " "1"" of type '" "struct MixedComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedComplementarityProblem *)(argp1);
  result = (ptrFunctionMCP) ((arg1)->computeNablaFmcp);
  resultobj = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_int_p_double_p_double__void);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MCP_Fmcp_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedComplementarityProblem *arg1 = (struct MixedComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:MCP_Fmcp_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MCP_Fmcp_set" "', argument " "1"" of type '" "struct MixedComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  if (arg1) (arg1)->Fmcp = arg2;
  resultobj = SWIG_Py_Void();
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_MCP_Fmcp_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedComplementarityProblem *arg1 = (struct MixedComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:MCP_Fmcp_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MCP_Fmcp_get" "', argument " "1"" of type '" "struct MixedComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedComplementarityProblem *)(argp1);
  result = (double *) ((arg1)->Fmcp);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MCP_nablaFmcp_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedComplementarityProblem *arg1 = (struct MixedComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:MCP_nablaFmcp_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MCP_nablaFmcp_set" "', argument " "1"" of type '" "struct MixedComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_double, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MCP_nablaFmcp_set" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = (double *)(argp2);
  if (arg1) (arg1)->nablaFmcp = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MCP_nablaFmcp_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedComplementarityProblem *arg1 = (struct MixedComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:MCP_nablaFmcp_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MCP_nablaFmcp_get" "', argument " "1"" of type '" "struct MixedComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedComplementarityProblem *)(argp1);
  result = (double *) ((arg1)->nablaFmcp);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_MCP__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedComplementarityProblem *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_MCP")) SWIG_fail;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct MixedComplementarityProblem *)new_MixedComplementarityProblem__SWIG_0();
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_MixedComplementarityProblem, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MCP_set_computeFmcp(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedComplementarityProblem *arg1 = (struct MixedComplementarityProblem *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:MCP_set_computeFmcp",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MCP_set_computeFmcp" "', argument " "1"" of type '" "struct MixedComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedComplementarityProblem *)(argp1);
  arg2 = obj1;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        MixedComplementarityProblem_set_computeFmcp(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MCP_set_computeNablaFmcp(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedComplementarityProblem *arg1 = (struct MixedComplementarityProblem *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:MCP_set_computeNablaFmcp",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MCP_set_computeNablaFmcp" "', argument " "1"" of type '" "struct MixedComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedComplementarityProblem *)(argp1);
  arg2 = obj1;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        MixedComplementarityProblem_set_computeNablaFmcp(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MCP_test_call_to_callback(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedComplementarityProblem *arg1 = (struct MixedComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:MCP_test_call_to_callback",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MCP_test_call_to_callback" "', argument " "1"" of type '" "struct MixedComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedComplementarityProblem *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        MixedComplementarityProblem_test_call_to_callback(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_MCP__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  PyObject *arg4 = (PyObject *) 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  struct MixedComplementarityProblem *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:new_MCP",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  arg1 = obj0;
  arg2 = obj1;
  arg3 = obj2;
  arg4 = obj3;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct MixedComplementarityProblem *)new_MixedComplementarityProblem__SWIG_1(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_MixedComplementarityProblem, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_MCP(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  Py_ssize_t ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = args ? PyObject_Length(args) : 0;
  for (ii = 0; (ii < 4) && (ii < argc); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_MCP__SWIG_0(self, args);
  }
  if (argc == 4) {
    int _v;
    _v = (argv[0] != 0);
    if (_v) {
      _v = (argv[1] != 0);
      if (_v) {
        _v = (argv[2] != 0);
        if (_v) {
          _v = (argv[3] != 0);
          if (_v) {
            return _wrap_new_MCP__SWIG_1(self, args);
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_MCP'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    MixedComplementarityProblem::MixedComplementarityProblem()\n"
    "    MixedComplementarityProblem::MixedComplementarityProblem(PyObject *,PyObject *,PyObject *,PyObject *)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_MCP(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedComplementarityProblem *arg1 = (struct MixedComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_MCP",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_MCP" "', argument " "1"" of type '" "struct MixedComplementarityProblem *""'"); 
  }
  arg1 = (struct MixedComplementarityProblem *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        delete_MixedComplementarityProblem(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *MCP_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_MixedComplementarityProblem, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_MixedComplementarityProblem2_n1_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedComplementarityProblem2 *arg1 = (struct MixedComplementarityProblem2 *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:MixedComplementarityProblem2_n1_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem2, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MixedComplementarityProblem2_n1_set" "', argument " "1"" of type '" "struct MixedComplementarityProblem2 *""'"); 
  }
  arg1 = (struct MixedComplementarityProblem2 *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "MixedComplementarityProblem2_n1_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->n1 = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MixedComplementarityProblem2_n1_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedComplementarityProblem2 *arg1 = (struct MixedComplementarityProblem2 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:MixedComplementarityProblem2_n1_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem2, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MixedComplementarityProblem2_n1_get" "', argument " "1"" of type '" "struct MixedComplementarityProblem2 *""'"); 
  }
  arg1 = (struct MixedComplementarityProblem2 *)(argp1);
  result = (int) ((arg1)->n1);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MixedComplementarityProblem2_n2_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedComplementarityProblem2 *arg1 = (struct MixedComplementarityProblem2 *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:MixedComplementarityProblem2_n2_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem2, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MixedComplementarityProblem2_n2_set" "', argument " "1"" of type '" "struct MixedComplementarityProblem2 *""'"); 
  }
  arg1 = (struct MixedComplementarityProblem2 *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "MixedComplementarityProblem2_n2_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->n2 = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MixedComplementarityProblem2_n2_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedComplementarityProblem2 *arg1 = (struct MixedComplementarityProblem2 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:MixedComplementarityProblem2_n2_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem2, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MixedComplementarityProblem2_n2_get" "', argument " "1"" of type '" "struct MixedComplementarityProblem2 *""'"); 
  }
  arg1 = (struct MixedComplementarityProblem2 *)(argp1);
  result = (int) ((arg1)->n2);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MixedComplementarityProblem2_compute_Fmcp_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedComplementarityProblem2 *arg1 = (struct MixedComplementarityProblem2 *) 0 ;
  ptrFunctionMCP2 arg2 = (ptrFunctionMCP2) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:MixedComplementarityProblem2_compute_Fmcp_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem2, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MixedComplementarityProblem2_compute_Fmcp_set" "', argument " "1"" of type '" "struct MixedComplementarityProblem2 *""'"); 
  }
  arg1 = (struct MixedComplementarityProblem2 *)(argp1);
  {
    int res = SWIG_ConvertFunctionPtr(obj1, (void**)(&arg2), SWIGTYPE_p_f_p_void_int_p_double_p_double__void);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "MixedComplementarityProblem2_compute_Fmcp_set" "', argument " "2"" of type '" "ptrFunctionMCP2""'"); 
    }
  }
  if (arg1) (arg1)->compute_Fmcp = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MixedComplementarityProblem2_compute_Fmcp_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedComplementarityProblem2 *arg1 = (struct MixedComplementarityProblem2 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ptrFunctionMCP2 result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:MixedComplementarityProblem2_compute_Fmcp_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem2, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MixedComplementarityProblem2_compute_Fmcp_get" "', argument " "1"" of type '" "struct MixedComplementarityProblem2 *""'"); 
  }
  arg1 = (struct MixedComplementarityProblem2 *)(argp1);
  result = (ptrFunctionMCP2) ((arg1)->compute_Fmcp);
  resultobj = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_void_int_p_double_p_double__void);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MixedComplementarityProblem2_compute_nabla_Fmcp_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedComplementarityProblem2 *arg1 = (struct MixedComplementarityProblem2 *) 0 ;
  ptrFunctionMCP_nabla arg2 = (ptrFunctionMCP_nabla) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:MixedComplementarityProblem2_compute_nabla_Fmcp_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem2, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MixedComplementarityProblem2_compute_nabla_Fmcp_set" "', argument " "1"" of type '" "struct MixedComplementarityProblem2 *""'"); 
  }
  arg1 = (struct MixedComplementarityProblem2 *)(argp1);
  {
    int res = SWIG_ConvertFunctionPtr(obj1, (void**)(&arg2), SWIGTYPE_p_f_p_void_int_p_double_p_NumericsMatrix__void);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "MixedComplementarityProblem2_compute_nabla_Fmcp_set" "', argument " "2"" of type '" "ptrFunctionMCP_nabla""'"); 
    }
  }
  if (arg1) (arg1)->compute_nabla_Fmcp = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MixedComplementarityProblem2_compute_nabla_Fmcp_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedComplementarityProblem2 *arg1 = (struct MixedComplementarityProblem2 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ptrFunctionMCP_nabla result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:MixedComplementarityProblem2_compute_nabla_Fmcp_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem2, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MixedComplementarityProblem2_compute_nabla_Fmcp_get" "', argument " "1"" of type '" "struct MixedComplementarityProblem2 *""'"); 
  }
  arg1 = (struct MixedComplementarityProblem2 *)(argp1);
  result = (ptrFunctionMCP_nabla) ((arg1)->compute_nabla_Fmcp);
  resultobj = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_void_int_p_double_p_NumericsMatrix__void);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MixedComplementarityProblem2_nabla_Fmcp_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedComplementarityProblem2 *arg1 = (struct MixedComplementarityProblem2 *) 0 ;
  NumericsMatrix *arg2 = (NumericsMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array_2 = NULL ;
  int array_ctrl_2 = 0 ;
  PyArrayObject *array_i_2 = NULL ;
  int array_i_ctrl_2 = 0 ;
  PyArrayObject *array_p_2 = NULL ;
  int array_p_ctrl_2 = 0 ;
  int alloc_ctrl_2 = 0 ;
  NumericsMatrix *nummat2 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:MixedComplementarityProblem2_nabla_Fmcp_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem2, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MixedComplementarityProblem2_nabla_Fmcp_set" "', argument " "1"" of type '" "struct MixedComplementarityProblem2 *""'"); 
  }
  arg1 = (struct MixedComplementarityProblem2 *)(argp1);
  {
    arg2 = NM_convert_from_python(obj1, &nummat2, &array_2, &array_ctrl_2, &array_i_2, &array_i_ctrl_2, &array_p_2, &array_p_ctrl_2, &alloc_ctrl_2);
    
    
    
    
    
    if (!arg2) {
      SWIG_fail; 
    }
  }
  {
    //  %typemap(memberin) (NumericsMatrix*)
    // perform a deep copy
    if (!arg1->nabla_Fmcp) {
      arg1->nabla_Fmcp = NM_create(arg2->storageType, arg2->size0, arg2->size1); 
    }
    NM_copy(arg2, arg1->nabla_Fmcp);
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_MixedComplementarityProblem2_nabla_Fmcp_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedComplementarityProblem2 *arg1 = (struct MixedComplementarityProblem2 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  NumericsMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:MixedComplementarityProblem2_nabla_Fmcp_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem2, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MixedComplementarityProblem2_nabla_Fmcp_get" "', argument " "1"" of type '" "struct MixedComplementarityProblem2 *""'"); 
  }
  arg1 = (struct MixedComplementarityProblem2 *)(argp1);
  result = (NumericsMatrix *) ((arg1)->nabla_Fmcp);
  {
    if (strcmp("MixedComplementarityProblem2_nabla_Fmcp_get", "new_NumericsMatrix"))
    {
      resultobj = NM_to_python(result);
      
      
      
      if (!resultobj) SWIG_fail;
    }
    else
    {
      resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NumericsMatrix, SWIG_POINTER_NEW |  0 );
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MixedComplementarityProblem2_env_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedComplementarityProblem2 *arg1 = (struct MixedComplementarityProblem2 *) 0 ;
  void *arg2 = (void *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:MixedComplementarityProblem2_env_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem2, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MixedComplementarityProblem2_env_set" "', argument " "1"" of type '" "struct MixedComplementarityProblem2 *""'"); 
  }
  arg1 = (struct MixedComplementarityProblem2 *)(argp1);
  res2 = SWIG_ConvertPtr(obj1,SWIG_as_voidptrptr(&arg2), 0, SWIG_POINTER_DISOWN);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MixedComplementarityProblem2_env_set" "', argument " "2"" of type '" "void *""'"); 
  }
  if (arg1) (arg1)->env = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MixedComplementarityProblem2_env_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedComplementarityProblem2 *arg1 = (struct MixedComplementarityProblem2 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  void *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:MixedComplementarityProblem2_env_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem2, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MixedComplementarityProblem2_env_get" "', argument " "1"" of type '" "struct MixedComplementarityProblem2 *""'"); 
  }
  arg1 = (struct MixedComplementarityProblem2 *)(argp1);
  result = (void *) ((arg1)->env);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MixedComplementarityProblem2_call_compute_F(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  void *arg1 = (void *) 0 ;
  int arg2 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  int res1 ;
  int val2 ;
  int ecode2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  PyArrayObject *array4 = NULL ;
  int is_new_object4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:MixedComplementarityProblem2_call_compute_F",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0,SWIG_as_voidptrptr(&arg1), 0, 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MixedComplementarityProblem2_call_compute_F" "', argument " "1"" of type '" "void *""'"); 
  }
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "MixedComplementarityProblem2_call_compute_F" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  {
    array4 = obj_to_sn_vector(obj3, &is_new_object4);
    
    if (!array4)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array4))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg4 = (double *) array_data(array4);
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        MixedComplementarityProblem2_call_compute_F(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_MixedComplementarityProblem2_call_compute_nabla_F(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  void *arg1 = (void *) 0 ;
  int arg2 ;
  double *arg3 = (double *) 0 ;
  NumericsMatrix *arg4 = (NumericsMatrix *) 0 ;
  int res1 ;
  int val2 ;
  int ecode2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  PyArrayObject *array_4 = NULL ;
  int array_ctrl_4 = 0 ;
  PyArrayObject *array_i_4 = NULL ;
  int array_i_ctrl_4 = 0 ;
  PyArrayObject *array_p_4 = NULL ;
  int array_p_ctrl_4 = 0 ;
  int alloc_ctrl_4 = 0 ;
  NumericsMatrix *nummat4 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:MixedComplementarityProblem2_call_compute_nabla_F",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0,SWIG_as_voidptrptr(&arg1), 0, 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MixedComplementarityProblem2_call_compute_nabla_F" "', argument " "1"" of type '" "void *""'"); 
  }
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "MixedComplementarityProblem2_call_compute_nabla_F" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  {
    arg4 = NM_convert_from_python(obj3, &nummat4, &array_4, &array_ctrl_4, &array_i_4, &array_i_ctrl_4, &array_p_4, &array_p_ctrl_4, &alloc_ctrl_4);
    
    
    
    
    
    if (!arg4) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        MixedComplementarityProblem2_call_compute_nabla_F(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    
  }
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_4 && array_4) {
      Py_DECREF(array_4); 
    };
    if(array_i_ctrl_4 && array_i_4) {
      Py_DECREF(array_i_4); 
    };
    if(array_p_ctrl_4 && array_p_4) {
      Py_DECREF(array_p_4); 
    };
    
    if (nummat4)
    {
      if (!NM_clean(nummat4, alloc_ctrl_4)) {
        return NULL; 
      }
      NM_free(nummat4);
      free(nummat4);
    }
    
  }
  return resultobj;
fail:
  {
    
  }
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_4 && array_4) {
      Py_DECREF(array_4); 
    };
    if(array_i_ctrl_4 && array_i_4) {
      Py_DECREF(array_i_4); 
    };
    if(array_p_ctrl_4 && array_p_4) {
      Py_DECREF(array_p_4); 
    };
    
    if (nummat4)
    {
      if (!NM_clean(nummat4, alloc_ctrl_4)) {
        return NULL; 
      }
      NM_free(nummat4);
      free(nummat4);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_MixedComplementarityProblem2__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedComplementarityProblem2 *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_MixedComplementarityProblem2")) SWIG_fail;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct MixedComplementarityProblem2 *)new_MixedComplementarityProblem2__SWIG_0();
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_MixedComplementarityProblem2, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_MixedComplementarityProblem2__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  struct MixedComplementarityProblem2 *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_MixedComplementarityProblem2",&obj0,&obj1)) SWIG_fail;
  arg1 = obj0;
  arg2 = obj1;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct MixedComplementarityProblem2 *)new_MixedComplementarityProblem2__SWIG_1(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_MixedComplementarityProblem2, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_MixedComplementarityProblem2__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  struct MixedComplementarityProblem2 *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:new_MixedComplementarityProblem2",&obj0,&obj1,&obj2)) SWIG_fail;
  arg1 = obj0;
  arg2 = obj1;
  arg3 = obj2;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct MixedComplementarityProblem2 *)new_MixedComplementarityProblem2__SWIG_2(arg1,arg2,arg3);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_MixedComplementarityProblem2, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_MixedComplementarityProblem2__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  PyObject *arg4 = (PyObject *) 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  struct MixedComplementarityProblem2 *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:new_MixedComplementarityProblem2",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  arg1 = obj0;
  arg2 = obj1;
  arg3 = obj2;
  arg4 = obj3;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct MixedComplementarityProblem2 *)new_MixedComplementarityProblem2__SWIG_3(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_MixedComplementarityProblem2, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_MixedComplementarityProblem2(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  Py_ssize_t ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = args ? PyObject_Length(args) : 0;
  for (ii = 0; (ii < 4) && (ii < argc); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_MixedComplementarityProblem2__SWIG_0(self, args);
  }
  if (argc == 2) {
    int _v;
    _v = (argv[0] != 0);
    if (_v) {
      _v = (argv[1] != 0);
      if (_v) {
        return _wrap_new_MixedComplementarityProblem2__SWIG_1(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = (argv[0] != 0);
    if (_v) {
      _v = (argv[1] != 0);
      if (_v) {
        _v = (argv[2] != 0);
        if (_v) {
          return _wrap_new_MixedComplementarityProblem2__SWIG_2(self, args);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    _v = (argv[0] != 0);
    if (_v) {
      _v = (argv[1] != 0);
      if (_v) {
        _v = (argv[2] != 0);
        if (_v) {
          _v = (argv[3] != 0);
          if (_v) {
            return _wrap_new_MixedComplementarityProblem2__SWIG_3(self, args);
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_MixedComplementarityProblem2'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    MixedComplementarityProblem2::MixedComplementarityProblem2()\n"
    "    MixedComplementarityProblem2::MixedComplementarityProblem2(PyObject *,PyObject *)\n"
    "    MixedComplementarityProblem2::MixedComplementarityProblem2(PyObject *,PyObject *,PyObject *)\n"
    "    MixedComplementarityProblem2::MixedComplementarityProblem2(PyObject *,PyObject *,PyObject *,PyObject *)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_MixedComplementarityProblem2_set_compute_F_and_nabla_F_as_C_functions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedComplementarityProblem2 *arg1 = (struct MixedComplementarityProblem2 *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  PyObject *arg4 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:MixedComplementarityProblem2_set_compute_F_and_nabla_F_as_C_functions",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem2, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MixedComplementarityProblem2_set_compute_F_and_nabla_F_as_C_functions" "', argument " "1"" of type '" "struct MixedComplementarityProblem2 *""'"); 
  }
  arg1 = (struct MixedComplementarityProblem2 *)(argp1);
  arg2 = obj1;
  arg3 = obj2;
  arg4 = obj3;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        MixedComplementarityProblem2_set_compute_F_and_nabla_F_as_C_functions(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MixedComplementarityProblem2_get_env_as_long(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedComplementarityProblem2 *arg1 = (struct MixedComplementarityProblem2 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:MixedComplementarityProblem2_get_env_as_long",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem2, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MixedComplementarityProblem2_get_env_as_long" "', argument " "1"" of type '" "struct MixedComplementarityProblem2 *""'"); 
  }
  arg1 = (struct MixedComplementarityProblem2 *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (PyObject *)MixedComplementarityProblem2_get_env_as_long(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_MixedComplementarityProblem2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct MixedComplementarityProblem2 *arg1 = (struct MixedComplementarityProblem2 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_MixedComplementarityProblem2",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem2, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_MixedComplementarityProblem2" "', argument " "1"" of type '" "struct MixedComplementarityProblem2 *""'"); 
  }
  arg1 = (struct MixedComplementarityProblem2 *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        delete_MixedComplementarityProblem2(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *MixedComplementarityProblem2_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_MixedComplementarityProblem2, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_freeMixedComplementarityProblem(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedComplementarityProblem *arg1 = (MixedComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:freeMixedComplementarityProblem",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "freeMixedComplementarityProblem" "', argument " "1"" of type '" "MixedComplementarityProblem *""'"); 
  }
  arg1 = (MixedComplementarityProblem *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        freeMixedComplementarityProblem(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_freeMCP(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedComplementarityProblem2 *arg1 = (MixedComplementarityProblem2 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:freeMCP",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem2, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "freeMCP" "', argument " "1"" of type '" "MixedComplementarityProblem2 *""'"); 
  }
  arg1 = (MixedComplementarityProblem2 *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        freeMCP(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_newMCP(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedComplementarityProblem2 *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":newMCP")) SWIG_fail;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (MixedComplementarityProblem2 *)newMCP();
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_MixedComplementarityProblem2, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mcp_driver_init(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedComplementarityProblem *arg1 = (MixedComplementarityProblem *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:mcp_driver_init",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mcp_driver_init" "', argument " "1"" of type '" "MixedComplementarityProblem *""'"); 
  }
  arg1 = (MixedComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "mcp_driver_init" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        mcp_driver_init(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mcp_driver_reset(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedComplementarityProblem *arg1 = (MixedComplementarityProblem *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:mcp_driver_reset",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mcp_driver_reset" "', argument " "1"" of type '" "MixedComplementarityProblem *""'"); 
  }
  arg1 = (MixedComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "mcp_driver_reset" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        mcp_driver_reset(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mixedComplementarity_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedComplementarityProblem *arg1 = (MixedComplementarityProblem *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:mixedComplementarity_setDefaultSolverOptions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mixedComplementarity_setDefaultSolverOptions" "', argument " "1"" of type '" "MixedComplementarityProblem *""'"); 
  }
  arg1 = (MixedComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "mixedComplementarity_setDefaultSolverOptions" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)mixedComplementarity_setDefaultSolverOptions(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mixedComplementarity_default_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedComplementarityProblem *arg1 = (MixedComplementarityProblem *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:mixedComplementarity_default_setDefaultSolverOptions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mixedComplementarity_default_setDefaultSolverOptions" "', argument " "1"" of type '" "MixedComplementarityProblem *""'"); 
  }
  arg1 = (MixedComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "mixedComplementarity_default_setDefaultSolverOptions" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        mixedComplementarity_default_setDefaultSolverOptions(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mcp_FischerBurmeister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedComplementarityProblem *arg1 = (MixedComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:mcp_FischerBurmeister",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mcp_FischerBurmeister" "', argument " "1"" of type '" "MixedComplementarityProblem *""'"); 
  }
  arg1 = (MixedComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "mcp_FischerBurmeister" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        mcp_FischerBurmeister(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_mcp_newton_FBLSA(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedComplementarityProblem2 *arg1 = (MixedComplementarityProblem2 *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:mcp_newton_FBLSA",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem2, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mcp_newton_FBLSA" "', argument " "1"" of type '" "MixedComplementarityProblem2 *""'"); 
  }
  arg1 = (MixedComplementarityProblem2 *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "mcp_newton_FBLSA" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        mcp_newton_FBLSA(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_mcp_newton_minFBLSA(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedComplementarityProblem2 *arg1 = (MixedComplementarityProblem2 *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:mcp_newton_minFBLSA",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem2, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mcp_newton_minFBLSA" "', argument " "1"" of type '" "MixedComplementarityProblem2 *""'"); 
  }
  arg1 = (MixedComplementarityProblem2 *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "mcp_newton_minFBLSA" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        mcp_newton_minFBLSA(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_mixedComplementarity_FB_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  MixedComplementarityProblem *arg1 = (MixedComplementarityProblem *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:mixedComplementarity_FB_setDefaultSolverOptions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_MixedComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mixedComplementarity_FB_setDefaultSolverOptions" "', argument " "1"" of type '" "MixedComplementarityProblem *""'"); 
  }
  arg1 = (MixedComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "mixedComplementarity_FB_setDefaultSolverOptions" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)mixedComplementarity_FB_setDefaultSolverOptions(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NCP_n_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NonlinearComplementarityProblem *arg1 = (struct NonlinearComplementarityProblem *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NCP_n_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NonlinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NCP_n_set" "', argument " "1"" of type '" "struct NonlinearComplementarityProblem *""'"); 
  }
  arg1 = (struct NonlinearComplementarityProblem *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NCP_n_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  if (arg1) (arg1)->n = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NCP_n_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NonlinearComplementarityProblem *arg1 = (struct NonlinearComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NCP_n_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NonlinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NCP_n_get" "', argument " "1"" of type '" "struct NonlinearComplementarityProblem *""'"); 
  }
  arg1 = (struct NonlinearComplementarityProblem *)(argp1);
  result = (unsigned int) ((arg1)->n);
  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NCP_compute_F_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NonlinearComplementarityProblem *arg1 = (struct NonlinearComplementarityProblem *) 0 ;
  ptrFunctionNCP arg2 = (ptrFunctionNCP) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NCP_compute_F_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NonlinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NCP_compute_F_set" "', argument " "1"" of type '" "struct NonlinearComplementarityProblem *""'"); 
  }
  arg1 = (struct NonlinearComplementarityProblem *)(argp1);
  {
    int res = SWIG_ConvertFunctionPtr(obj1, (void**)(&arg2), SWIGTYPE_p_f_p_void_int_p_double_p_double__void);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "NCP_compute_F_set" "', argument " "2"" of type '" "ptrFunctionNCP""'"); 
    }
  }
  if (arg1) (arg1)->compute_F = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NCP_compute_F_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NonlinearComplementarityProblem *arg1 = (struct NonlinearComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ptrFunctionNCP result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NCP_compute_F_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NonlinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NCP_compute_F_get" "', argument " "1"" of type '" "struct NonlinearComplementarityProblem *""'"); 
  }
  arg1 = (struct NonlinearComplementarityProblem *)(argp1);
  result = (ptrFunctionNCP) ((arg1)->compute_F);
  resultobj = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_void_int_p_double_p_double__void);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NCP_compute_nabla_F_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NonlinearComplementarityProblem *arg1 = (struct NonlinearComplementarityProblem *) 0 ;
  ptrFunctionJacNCP arg2 = (ptrFunctionJacNCP) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NCP_compute_nabla_F_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NonlinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NCP_compute_nabla_F_set" "', argument " "1"" of type '" "struct NonlinearComplementarityProblem *""'"); 
  }
  arg1 = (struct NonlinearComplementarityProblem *)(argp1);
  {
    int res = SWIG_ConvertFunctionPtr(obj1, (void**)(&arg2), SWIGTYPE_p_f_p_void_int_p_double_p_NumericsMatrix__void);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "NCP_compute_nabla_F_set" "', argument " "2"" of type '" "ptrFunctionJacNCP""'"); 
    }
  }
  if (arg1) (arg1)->compute_nabla_F = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NCP_compute_nabla_F_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NonlinearComplementarityProblem *arg1 = (struct NonlinearComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ptrFunctionJacNCP result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NCP_compute_nabla_F_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NonlinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NCP_compute_nabla_F_get" "', argument " "1"" of type '" "struct NonlinearComplementarityProblem *""'"); 
  }
  arg1 = (struct NonlinearComplementarityProblem *)(argp1);
  result = (ptrFunctionJacNCP) ((arg1)->compute_nabla_F);
  resultobj = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_void_int_p_double_p_NumericsMatrix__void);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NCP_nabla_F_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NonlinearComplementarityProblem *arg1 = (struct NonlinearComplementarityProblem *) 0 ;
  NumericsMatrix *arg2 = (NumericsMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array_2 = NULL ;
  int array_ctrl_2 = 0 ;
  PyArrayObject *array_i_2 = NULL ;
  int array_i_ctrl_2 = 0 ;
  PyArrayObject *array_p_2 = NULL ;
  int array_p_ctrl_2 = 0 ;
  int alloc_ctrl_2 = 0 ;
  NumericsMatrix *nummat2 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NCP_nabla_F_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NonlinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NCP_nabla_F_set" "', argument " "1"" of type '" "struct NonlinearComplementarityProblem *""'"); 
  }
  arg1 = (struct NonlinearComplementarityProblem *)(argp1);
  {
    arg2 = NM_convert_from_python(obj1, &nummat2, &array_2, &array_ctrl_2, &array_i_2, &array_i_ctrl_2, &array_p_2, &array_p_ctrl_2, &alloc_ctrl_2);
    
    
    
    
    
    if (!arg2) {
      SWIG_fail; 
    }
  }
  {
    //  %typemap(memberin) (NumericsMatrix*)
    // perform a deep copy
    if (!arg1->nabla_F) {
      arg1->nabla_F = NM_create(arg2->storageType, arg2->size0, arg2->size1); 
    }
    NM_copy(arg2, arg1->nabla_F);
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NCP_nabla_F_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NonlinearComplementarityProblem *arg1 = (struct NonlinearComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  NumericsMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NCP_nabla_F_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NonlinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NCP_nabla_F_get" "', argument " "1"" of type '" "struct NonlinearComplementarityProblem *""'"); 
  }
  arg1 = (struct NonlinearComplementarityProblem *)(argp1);
  result = (NumericsMatrix *) ((arg1)->nabla_F);
  {
    if (strcmp("NCP_nabla_F_get", "new_NumericsMatrix"))
    {
      resultobj = NM_to_python(result);
      
      
      
      if (!resultobj) SWIG_fail;
    }
    else
    {
      resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NumericsMatrix, SWIG_POINTER_NEW |  0 );
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NCP_env_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NonlinearComplementarityProblem *arg1 = (struct NonlinearComplementarityProblem *) 0 ;
  void *arg2 = (void *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:NCP_env_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NonlinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NCP_env_set" "', argument " "1"" of type '" "struct NonlinearComplementarityProblem *""'"); 
  }
  arg1 = (struct NonlinearComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1,SWIG_as_voidptrptr(&arg2), 0, SWIG_POINTER_DISOWN);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NCP_env_set" "', argument " "2"" of type '" "void *""'"); 
  }
  if (arg1) (arg1)->env = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NCP_env_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NonlinearComplementarityProblem *arg1 = (struct NonlinearComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  void *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NCP_env_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NonlinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NCP_env_get" "', argument " "1"" of type '" "struct NonlinearComplementarityProblem *""'"); 
  }
  arg1 = (struct NonlinearComplementarityProblem *)(argp1);
  result = (void *) ((arg1)->env);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NCP_call_compute_F(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  void *arg1 = (void *) 0 ;
  int arg2 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  int res1 ;
  int val2 ;
  int ecode2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  PyArrayObject *array4 = NULL ;
  int is_new_object4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:NCP_call_compute_F",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0,SWIG_as_voidptrptr(&arg1), 0, 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NCP_call_compute_F" "', argument " "1"" of type '" "void *""'"); 
  }
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NCP_call_compute_F" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  {
    array4 = obj_to_sn_vector(obj3, &is_new_object4);
    
    if (!array4)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array4))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg4 = (double *) array_data(array4);
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NonlinearComplementarityProblem_call_compute_F(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_NCP_call_compute_nabla_F(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  void *arg1 = (void *) 0 ;
  int arg2 ;
  double *arg3 = (double *) 0 ;
  NumericsMatrix *arg4 = (NumericsMatrix *) 0 ;
  int res1 ;
  int val2 ;
  int ecode2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  PyArrayObject *array_4 = NULL ;
  int array_ctrl_4 = 0 ;
  PyArrayObject *array_i_4 = NULL ;
  int array_i_ctrl_4 = 0 ;
  PyArrayObject *array_p_4 = NULL ;
  int array_p_ctrl_4 = 0 ;
  int alloc_ctrl_4 = 0 ;
  NumericsMatrix *nummat4 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:NCP_call_compute_nabla_F",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0,SWIG_as_voidptrptr(&arg1), 0, 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NCP_call_compute_nabla_F" "', argument " "1"" of type '" "void *""'"); 
  }
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "NCP_call_compute_nabla_F" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  {
    arg4 = NM_convert_from_python(obj3, &nummat4, &array_4, &array_ctrl_4, &array_i_4, &array_i_ctrl_4, &array_p_4, &array_p_ctrl_4, &alloc_ctrl_4);
    
    
    
    
    
    if (!arg4) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NonlinearComplementarityProblem_call_compute_nabla_F(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    
  }
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_4 && array_4) {
      Py_DECREF(array_4); 
    };
    if(array_i_ctrl_4 && array_i_4) {
      Py_DECREF(array_i_4); 
    };
    if(array_p_ctrl_4 && array_p_4) {
      Py_DECREF(array_p_4); 
    };
    
    if (nummat4)
    {
      if (!NM_clean(nummat4, alloc_ctrl_4)) {
        return NULL; 
      }
      NM_free(nummat4);
      free(nummat4);
    }
    
  }
  return resultobj;
fail:
  {
    
  }
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_4 && array_4) {
      Py_DECREF(array_4); 
    };
    if(array_i_ctrl_4 && array_i_4) {
      Py_DECREF(array_i_4); 
    };
    if(array_p_ctrl_4 && array_p_4) {
      Py_DECREF(array_p_4); 
    };
    
    if (nummat4)
    {
      if (!NM_clean(nummat4, alloc_ctrl_4)) {
        return NULL; 
      }
      NM_free(nummat4);
      free(nummat4);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_NCP__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NonlinearComplementarityProblem *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_NCP")) SWIG_fail;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct NonlinearComplementarityProblem *)new_NonlinearComplementarityProblem__SWIG_0();
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NonlinearComplementarityProblem, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_NCP__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  PyObject * obj0 = 0 ;
  struct NonlinearComplementarityProblem *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_NCP",&obj0)) SWIG_fail;
  arg1 = obj0;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct NonlinearComplementarityProblem *)new_NonlinearComplementarityProblem__SWIG_1(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NonlinearComplementarityProblem, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_NCP__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  struct NonlinearComplementarityProblem *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_NCP",&obj0,&obj1)) SWIG_fail;
  arg1 = obj0;
  arg2 = obj1;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct NonlinearComplementarityProblem *)new_NonlinearComplementarityProblem__SWIG_2(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NonlinearComplementarityProblem, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_NCP__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  struct NonlinearComplementarityProblem *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:new_NCP",&obj0,&obj1,&obj2)) SWIG_fail;
  arg1 = obj0;
  arg2 = obj1;
  arg3 = obj2;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct NonlinearComplementarityProblem *)new_NonlinearComplementarityProblem__SWIG_3(arg1,arg2,arg3);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NonlinearComplementarityProblem, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_NCP(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  Py_ssize_t ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = args ? PyObject_Length(args) : 0;
  for (ii = 0; (ii < 3) && (ii < argc); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_NCP__SWIG_0(self, args);
  }
  if (argc == 1) {
    int _v;
    _v = (argv[0] != 0);
    if (_v) {
      return _wrap_new_NCP__SWIG_1(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    _v = (argv[0] != 0);
    if (_v) {
      _v = (argv[1] != 0);
      if (_v) {
        return _wrap_new_NCP__SWIG_2(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = (argv[0] != 0);
    if (_v) {
      _v = (argv[1] != 0);
      if (_v) {
        _v = (argv[2] != 0);
        if (_v) {
          return _wrap_new_NCP__SWIG_3(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_NCP'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    NonlinearComplementarityProblem::NonlinearComplementarityProblem()\n"
    "    NonlinearComplementarityProblem::NonlinearComplementarityProblem(PyObject *)\n"
    "    NonlinearComplementarityProblem::NonlinearComplementarityProblem(PyObject *,PyObject *)\n"
    "    NonlinearComplementarityProblem::NonlinearComplementarityProblem(PyObject *,PyObject *,PyObject *)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_NCP_set_compute_F_and_nabla_F_as_C_functions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NonlinearComplementarityProblem *arg1 = (struct NonlinearComplementarityProblem *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  PyObject *arg4 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:NCP_set_compute_F_and_nabla_F_as_C_functions",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NonlinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NCP_set_compute_F_and_nabla_F_as_C_functions" "', argument " "1"" of type '" "struct NonlinearComplementarityProblem *""'"); 
  }
  arg1 = (struct NonlinearComplementarityProblem *)(argp1);
  arg2 = obj1;
  arg3 = obj2;
  arg4 = obj3;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        NonlinearComplementarityProblem_set_compute_F_and_nabla_F_as_C_functions(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NCP_get_env_as_long(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NonlinearComplementarityProblem *arg1 = (struct NonlinearComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:NCP_get_env_as_long",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NonlinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NCP_get_env_as_long" "', argument " "1"" of type '" "struct NonlinearComplementarityProblem *""'"); 
  }
  arg1 = (struct NonlinearComplementarityProblem *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (PyObject *)NonlinearComplementarityProblem_get_env_as_long(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_NCP(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct NonlinearComplementarityProblem *arg1 = (struct NonlinearComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_NCP",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NonlinearComplementarityProblem, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_NCP" "', argument " "1"" of type '" "struct NonlinearComplementarityProblem *""'"); 
  }
  arg1 = (struct NonlinearComplementarityProblem *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        delete_NonlinearComplementarityProblem(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *NCP_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_NonlinearComplementarityProblem, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_freeNCP(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NonlinearComplementarityProblem *arg1 = (NonlinearComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:freeNCP",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NonlinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "freeNCP" "', argument " "1"" of type '" "NonlinearComplementarityProblem *""'"); 
  }
  arg1 = (NonlinearComplementarityProblem *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        freeNCP(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_newNCP(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NonlinearComplementarityProblem *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":newNCP")) SWIG_fail;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (NonlinearComplementarityProblem *)newNCP();
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NonlinearComplementarityProblem, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ncp_compute_error(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double arg4 ;
  double *arg5 = (double *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:ncp_compute_error",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "ncp_compute_error" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  ecode4 = SWIG_AsVal_double(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "ncp_compute_error" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  res5 = SWIG_ConvertPtr(obj4, &argp5,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "ncp_compute_error" "', argument " "5"" of type '" "double *""'"); 
  }
  arg5 = (double *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)ncp_compute_error(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_ncp_newton_FBLSA(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NonlinearComplementarityProblem *arg1 = (NonlinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:ncp_newton_FBLSA",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NonlinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ncp_newton_FBLSA" "', argument " "1"" of type '" "NonlinearComplementarityProblem *""'"); 
  }
  arg1 = (NonlinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "ncp_newton_FBLSA" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        ncp_newton_FBLSA(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_ncp_newton_minFBLSA(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NonlinearComplementarityProblem *arg1 = (NonlinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:ncp_newton_minFBLSA",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NonlinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ncp_newton_minFBLSA" "', argument " "1"" of type '" "NonlinearComplementarityProblem *""'"); 
  }
  arg1 = (NonlinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "ncp_newton_minFBLSA" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        ncp_newton_minFBLSA(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_ncp_pathsearch(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NonlinearComplementarityProblem *arg1 = (NonlinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:ncp_pathsearch",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NonlinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ncp_pathsearch" "', argument " "1"" of type '" "NonlinearComplementarityProblem *""'"); 
  }
  arg1 = (NonlinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "ncp_pathsearch" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        ncp_pathsearch(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_ncp_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  NonlinearComplementarityProblem *arg1 = (NonlinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:ncp_path",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_NonlinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ncp_path" "', argument " "1"" of type '" "NonlinearComplementarityProblem *""'"); 
  }
  arg1 = (NonlinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "ncp_path" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        ncp_path(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_VI_size_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct VariationalInequality *arg1 = (struct VariationalInequality *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:VI_size_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_VariationalInequality, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VI_size_set" "', argument " "1"" of type '" "struct VariationalInequality *""'"); 
  }
  arg1 = (struct VariationalInequality *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VI_size_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->size = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VI_size_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct VariationalInequality *arg1 = (struct VariationalInequality *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:VI_size_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_VariationalInequality, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VI_size_get" "', argument " "1"" of type '" "struct VariationalInequality *""'"); 
  }
  arg1 = (struct VariationalInequality *)(argp1);
  result = (int) ((arg1)->size);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VI_env_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct VariationalInequality *arg1 = (struct VariationalInequality *) 0 ;
  void *arg2 = (void *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:VI_env_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_VariationalInequality, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VI_env_set" "', argument " "1"" of type '" "struct VariationalInequality *""'"); 
  }
  arg1 = (struct VariationalInequality *)(argp1);
  res2 = SWIG_ConvertPtr(obj1,SWIG_as_voidptrptr(&arg2), 0, SWIG_POINTER_DISOWN);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VI_env_set" "', argument " "2"" of type '" "void *""'"); 
  }
  if (arg1) (arg1)->env = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VI_env_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct VariationalInequality *arg1 = (struct VariationalInequality *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  void *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:VI_env_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_VariationalInequality, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VI_env_get" "', argument " "1"" of type '" "struct VariationalInequality *""'"); 
  }
  arg1 = (struct VariationalInequality *)(argp1);
  result = (void *) ((arg1)->env);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VI_F_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct VariationalInequality *arg1 = (struct VariationalInequality *) 0 ;
  ptrFunctionVI arg2 = (ptrFunctionVI) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:VI_F_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_VariationalInequality, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VI_F_set" "', argument " "1"" of type '" "struct VariationalInequality *""'"); 
  }
  arg1 = (struct VariationalInequality *)(argp1);
  {
    int res = SWIG_ConvertFunctionPtr(obj1, (void**)(&arg2), SWIGTYPE_p_f_p_void_int_p_double_p_double__void);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "VI_F_set" "', argument " "2"" of type '" "ptrFunctionVI""'"); 
    }
  }
  if (arg1) (arg1)->F = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VI_F_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct VariationalInequality *arg1 = (struct VariationalInequality *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ptrFunctionVI result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:VI_F_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_VariationalInequality, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VI_F_get" "', argument " "1"" of type '" "struct VariationalInequality *""'"); 
  }
  arg1 = (struct VariationalInequality *)(argp1);
  result = (ptrFunctionVI) ((arg1)->F);
  resultobj = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_void_int_p_double_p_double__void);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VI_compute_nabla_F_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct VariationalInequality *arg1 = (struct VariationalInequality *) 0 ;
  ptrFunctionVI_nabla arg2 = (ptrFunctionVI_nabla) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:VI_compute_nabla_F_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_VariationalInequality, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VI_compute_nabla_F_set" "', argument " "1"" of type '" "struct VariationalInequality *""'"); 
  }
  arg1 = (struct VariationalInequality *)(argp1);
  {
    int res = SWIG_ConvertFunctionPtr(obj1, (void**)(&arg2), SWIGTYPE_p_f_p_void_int_p_double_p_NumericsMatrix__void);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "VI_compute_nabla_F_set" "', argument " "2"" of type '" "ptrFunctionVI_nabla""'"); 
    }
  }
  if (arg1) (arg1)->compute_nabla_F = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VI_compute_nabla_F_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct VariationalInequality *arg1 = (struct VariationalInequality *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ptrFunctionVI_nabla result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:VI_compute_nabla_F_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_VariationalInequality, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VI_compute_nabla_F_get" "', argument " "1"" of type '" "struct VariationalInequality *""'"); 
  }
  arg1 = (struct VariationalInequality *)(argp1);
  result = (ptrFunctionVI_nabla) ((arg1)->compute_nabla_F);
  resultobj = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_void_int_p_double_p_NumericsMatrix__void);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VI_ProjectionOnX_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct VariationalInequality *arg1 = (struct VariationalInequality *) 0 ;
  void (*arg2)(void *,double *,double *) = (void (*)(void *,double *,double *)) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:VI_ProjectionOnX_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_VariationalInequality, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VI_ProjectionOnX_set" "', argument " "1"" of type '" "struct VariationalInequality *""'"); 
  }
  arg1 = (struct VariationalInequality *)(argp1);
  {
    int res = SWIG_ConvertFunctionPtr(obj1, (void**)(&arg2), SWIGTYPE_p_f_p_void_p_double_p_double__void);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "VI_ProjectionOnX_set" "', argument " "2"" of type '" "void (*)(void *,double *,double *)""'"); 
    }
  }
  if (arg1) (arg1)->ProjectionOnX = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VI_ProjectionOnX_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct VariationalInequality *arg1 = (struct VariationalInequality *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  void (*result)(void *,double *,double *) = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:VI_ProjectionOnX_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_VariationalInequality, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VI_ProjectionOnX_get" "', argument " "1"" of type '" "struct VariationalInequality *""'"); 
  }
  arg1 = (struct VariationalInequality *)(argp1);
  result = (void (*)(void *,double *,double *)) ((arg1)->ProjectionOnX);
  resultobj = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_void_p_double_p_double__void);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VI_normVI_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct VariationalInequality *arg1 = (struct VariationalInequality *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:VI_normVI_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_VariationalInequality, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VI_normVI_set" "', argument " "1"" of type '" "struct VariationalInequality *""'"); 
  }
  arg1 = (struct VariationalInequality *)(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VI_normVI_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->normVI = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VI_normVI_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct VariationalInequality *arg1 = (struct VariationalInequality *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:VI_normVI_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_VariationalInequality, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VI_normVI_get" "', argument " "1"" of type '" "struct VariationalInequality *""'"); 
  }
  arg1 = (struct VariationalInequality *)(argp1);
  result = (double) ((arg1)->normVI);
  resultobj = SWIG_From_double((double)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VI_istheNormVIset_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct VariationalInequality *arg1 = (struct VariationalInequality *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:VI_istheNormVIset_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_VariationalInequality, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VI_istheNormVIset_set" "', argument " "1"" of type '" "struct VariationalInequality *""'"); 
  }
  arg1 = (struct VariationalInequality *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VI_istheNormVIset_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->istheNormVIset = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VI_istheNormVIset_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct VariationalInequality *arg1 = (struct VariationalInequality *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:VI_istheNormVIset_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_VariationalInequality, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VI_istheNormVIset_get" "', argument " "1"" of type '" "struct VariationalInequality *""'"); 
  }
  arg1 = (struct VariationalInequality *)(argp1);
  result = (int) ((arg1)->istheNormVIset);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VI_set_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct VariationalInequality *arg1 = (struct VariationalInequality *) 0 ;
  void *arg2 = (void *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:VI_set_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_VariationalInequality, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VI_set_set" "', argument " "1"" of type '" "struct VariationalInequality *""'"); 
  }
  arg1 = (struct VariationalInequality *)(argp1);
  res2 = SWIG_ConvertPtr(obj1,SWIG_as_voidptrptr(&arg2), 0, SWIG_POINTER_DISOWN);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VI_set_set" "', argument " "2"" of type '" "void *""'"); 
  }
  if (arg1) (arg1)->set = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VI_set_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct VariationalInequality *arg1 = (struct VariationalInequality *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  void *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:VI_set_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_VariationalInequality, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VI_set_get" "', argument " "1"" of type '" "struct VariationalInequality *""'"); 
  }
  arg1 = (struct VariationalInequality *)(argp1);
  result = (void *) ((arg1)->set);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VI_nabla_F_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct VariationalInequality *arg1 = (struct VariationalInequality *) 0 ;
  NumericsMatrix *arg2 = (NumericsMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array_2 = NULL ;
  int array_ctrl_2 = 0 ;
  PyArrayObject *array_i_2 = NULL ;
  int array_i_ctrl_2 = 0 ;
  PyArrayObject *array_p_2 = NULL ;
  int array_p_ctrl_2 = 0 ;
  int alloc_ctrl_2 = 0 ;
  NumericsMatrix *nummat2 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:VI_nabla_F_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_VariationalInequality, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VI_nabla_F_set" "', argument " "1"" of type '" "struct VariationalInequality *""'"); 
  }
  arg1 = (struct VariationalInequality *)(argp1);
  {
    arg2 = NM_convert_from_python(obj1, &nummat2, &array_2, &array_ctrl_2, &array_i_2, &array_i_ctrl_2, &array_p_2, &array_p_ctrl_2, &alloc_ctrl_2);
    
    
    
    
    
    if (!arg2) {
      SWIG_fail; 
    }
  }
  {
    //  %typemap(memberin) (NumericsMatrix*)
    // perform a deep copy
    if (!arg1->nabla_F) {
      arg1->nabla_F = NM_create(arg2->storageType, arg2->size0, arg2->size1); 
    }
    NM_copy(arg2, arg1->nabla_F);
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_VI_nabla_F_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct VariationalInequality *arg1 = (struct VariationalInequality *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  NumericsMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:VI_nabla_F_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_VariationalInequality, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VI_nabla_F_get" "', argument " "1"" of type '" "struct VariationalInequality *""'"); 
  }
  arg1 = (struct VariationalInequality *)(argp1);
  result = (NumericsMatrix *) ((arg1)->nabla_F);
  {
    if (strcmp("VI_nabla_F_get", "new_NumericsMatrix"))
    {
      resultobj = NM_to_python(result);
      
      
      
      if (!resultobj) SWIG_fail;
    }
    else
    {
      resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NumericsMatrix, SWIG_POINTER_NEW |  0 );
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VI_call_compute_F(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  void *arg1 = (void *) 0 ;
  int arg2 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  int res1 ;
  int val2 ;
  int ecode2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  PyArrayObject *array4 = NULL ;
  int is_new_object4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:VI_call_compute_F",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0,SWIG_as_voidptrptr(&arg1), 0, 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VI_call_compute_F" "', argument " "1"" of type '" "void *""'"); 
  }
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VI_call_compute_F" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  {
    array4 = obj_to_sn_vector(obj3, &is_new_object4);
    
    if (!array4)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array4))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg4 = (double *) array_data(array4);
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        VariationalInequality_call_compute_F(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_VI_call_compute_nabla_F(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  void *arg1 = (void *) 0 ;
  int arg2 ;
  double *arg3 = (double *) 0 ;
  NumericsMatrix *arg4 = (NumericsMatrix *) 0 ;
  int res1 ;
  int val2 ;
  int ecode2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  PyArrayObject *array_4 = NULL ;
  int array_ctrl_4 = 0 ;
  PyArrayObject *array_i_4 = NULL ;
  int array_i_ctrl_4 = 0 ;
  PyArrayObject *array_p_4 = NULL ;
  int array_p_ctrl_4 = 0 ;
  int alloc_ctrl_4 = 0 ;
  NumericsMatrix *nummat4 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:VI_call_compute_nabla_F",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0,SWIG_as_voidptrptr(&arg1), 0, 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VI_call_compute_nabla_F" "', argument " "1"" of type '" "void *""'"); 
  }
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VI_call_compute_nabla_F" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  {
    arg4 = NM_convert_from_python(obj3, &nummat4, &array_4, &array_ctrl_4, &array_i_4, &array_i_ctrl_4, &array_p_4, &array_p_ctrl_4, &alloc_ctrl_4);
    
    
    
    
    
    if (!arg4) {
      SWIG_fail; 
    }
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        VariationalInequality_call_compute_nabla_F(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    
  }
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_4 && array_4) {
      Py_DECREF(array_4); 
    };
    if(array_i_ctrl_4 && array_i_4) {
      Py_DECREF(array_i_4); 
    };
    if(array_p_ctrl_4 && array_p_4) {
      Py_DECREF(array_p_4); 
    };
    
    if (nummat4)
    {
      if (!NM_clean(nummat4, alloc_ctrl_4)) {
        return NULL; 
      }
      NM_free(nummat4);
      free(nummat4);
    }
    
  }
  return resultobj;
fail:
  {
    
  }
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_4 && array_4) {
      Py_DECREF(array_4); 
    };
    if(array_i_ctrl_4 && array_i_4) {
      Py_DECREF(array_i_4); 
    };
    if(array_p_ctrl_4 && array_p_4) {
      Py_DECREF(array_p_4); 
    };
    
    if (nummat4)
    {
      if (!NM_clean(nummat4, alloc_ctrl_4)) {
        return NULL; 
      }
      NM_free(nummat4);
      free(nummat4);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_VI__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  PyObject * obj0 = 0 ;
  struct VariationalInequality *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_VI",&obj0)) SWIG_fail;
  arg1 = obj0;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct VariationalInequality *)new_VariationalInequality__SWIG_0(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_VariationalInequality, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_VI__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  struct VariationalInequality *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_VI",&obj0,&obj1)) SWIG_fail;
  arg1 = obj0;
  arg2 = obj1;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct VariationalInequality *)new_VariationalInequality__SWIG_1(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_VariationalInequality, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_VI(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  Py_ssize_t ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = args ? PyObject_Length(args) : 0;
  for (ii = 0; (ii < 2) && (ii < argc); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    _v = (argv[0] != 0);
    if (_v) {
      return _wrap_new_VI__SWIG_0(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    _v = (argv[0] != 0);
    if (_v) {
      _v = (argv[1] != 0);
      if (_v) {
        return _wrap_new_VI__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_VI'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    VariationalInequality::VariationalInequality(PyObject *)\n"
    "    VariationalInequality::VariationalInequality(PyObject *,PyObject *)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_VI_set_compute_nabla_F(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct VariationalInequality *arg1 = (struct VariationalInequality *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:VI_set_compute_nabla_F",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_VariationalInequality, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VI_set_compute_nabla_F" "', argument " "1"" of type '" "struct VariationalInequality *""'"); 
  }
  arg1 = (struct VariationalInequality *)(argp1);
  arg2 = obj1;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        VariationalInequality_set_compute_nabla_F(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VI_set_box_constraints(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct VariationalInequality *arg1 = (struct VariationalInequality *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:VI_set_box_constraints",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_VariationalInequality, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VI_set_box_constraints" "', argument " "1"" of type '" "struct VariationalInequality *""'"); 
  }
  arg1 = (struct VariationalInequality *)(argp1);
  arg2 = obj1;
  arg3 = obj2;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        VariationalInequality_set_box_constraints(arg1,arg2,arg3);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VI_set_compute_F_and_nabla_F_as_C_functions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct VariationalInequality *arg1 = (struct VariationalInequality *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  PyObject *arg4 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:VI_set_compute_F_and_nabla_F_as_C_functions",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_VariationalInequality, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VI_set_compute_F_and_nabla_F_as_C_functions" "', argument " "1"" of type '" "struct VariationalInequality *""'"); 
  }
  arg1 = (struct VariationalInequality *)(argp1);
  arg2 = obj1;
  arg3 = obj2;
  arg4 = obj3;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        VariationalInequality_set_compute_F_and_nabla_F_as_C_functions(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VI_get_env_as_long(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct VariationalInequality *arg1 = (struct VariationalInequality *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:VI_get_env_as_long",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_VariationalInequality, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VI_get_env_as_long" "', argument " "1"" of type '" "struct VariationalInequality *""'"); 
  }
  arg1 = (struct VariationalInequality *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (PyObject *)VariationalInequality_get_env_as_long(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_VI(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct VariationalInequality *arg1 = (struct VariationalInequality *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_VI",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_VariationalInequality, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_VI" "', argument " "1"" of type '" "struct VariationalInequality *""'"); 
  }
  arg1 = (struct VariationalInequality *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        delete_VariationalInequality(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *VI_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_VariationalInequality, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_variationalInequality_display(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  VariationalInequality *arg1 = (VariationalInequality *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:variationalInequality_display",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_VariationalInequality, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "variationalInequality_display" "', argument " "1"" of type '" "VariationalInequality *""'"); 
  }
  arg1 = (VariationalInequality *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        variationalInequality_display(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_variationalInequality_printInFile(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  VariationalInequality *arg1 = (VariationalInequality *) 0 ;
  FILE *arg2 = (FILE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:variationalInequality_printInFile",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_VariationalInequality, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "variationalInequality_printInFile" "', argument " "1"" of type '" "VariationalInequality *""'"); 
  }
  arg1 = (VariationalInequality *)(argp1);
  {
    // %typemap(in) (FILE *file)
    int alloc = 1;
    char* cstr;
    int res = SWIG_AsCharPtrAndSize(obj1, &cstr, NULL, &alloc);
    if (!SWIG_IsOK(res)) {
      SWIG_Error(SWIG_ArgError(res), "in method unknown', argument " "1"" of type '" "char *""'");
    }
    arg2 = fopen(cstr, "r");
    if (!arg2)
    {
      SWIG_Error(SWIG_IOError, format_msg_concat("in method '" "variationalInequality_printInFile" "' cannot fopen file", cstr));
      if (alloc == SWIG_NEWOBJ) free(cstr);
      SWIG_fail;
    }
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)variationalInequality_printInFile(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_variationalInequality_newFromFile(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  VariationalInequality *arg1 = (VariationalInequality *) 0 ;
  FILE *arg2 = (FILE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:variationalInequality_newFromFile",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_VariationalInequality, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "variationalInequality_newFromFile" "', argument " "1"" of type '" "VariationalInequality *""'"); 
  }
  arg1 = (VariationalInequality *)(argp1);
  {
    // %typemap(in) (FILE *file)
    int alloc = 1;
    char* cstr;
    int res = SWIG_AsCharPtrAndSize(obj1, &cstr, NULL, &alloc);
    if (!SWIG_IsOK(res)) {
      SWIG_Error(SWIG_ArgError(res), "in method unknown', argument " "1"" of type '" "char *""'");
    }
    arg2 = fopen(cstr, "r");
    if (!arg2)
    {
      SWIG_Error(SWIG_IOError, format_msg_concat("in method '" "variationalInequality_newFromFile" "' cannot fopen file", cstr));
      if (alloc == SWIG_NEWOBJ) free(cstr);
      SWIG_fail;
    }
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)variationalInequality_newFromFile(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_freeVariationalInequalityProblem(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  VariationalInequality *arg1 = (VariationalInequality *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:freeVariationalInequalityProblem",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_VariationalInequality, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "freeVariationalInequalityProblem" "', argument " "1"" of type '" "VariationalInequality *""'"); 
  }
  arg1 = (VariationalInequality *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        freeVariationalInequalityProblem(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_variationalInequality_clear(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  VariationalInequality *arg1 = (VariationalInequality *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:variationalInequality_clear",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_VariationalInequality, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "variationalInequality_clear" "', argument " "1"" of type '" "VariationalInequality *""'"); 
  }
  arg1 = (VariationalInequality *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        variationalInequality_clear(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_variationalInequality_new(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  VariationalInequality *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:variationalInequality_new",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "variationalInequality_new" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (VariationalInequality *)variationalInequality_new(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_VariationalInequality, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_newVI(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  VariationalInequality *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":newVI")) SWIG_fail;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (VariationalInequality *)newVI();
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_VariationalInequality, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VI_get_env(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  void *arg1 = (void *) 0 ;
  int res1 ;
  PyObject * obj0 = 0 ;
  void *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:VI_get_env",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0,SWIG_as_voidptrptr(&arg1), 0, 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VI_get_env" "', argument " "1"" of type '" "void *""'"); 
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (void *)VI_get_env(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_variationalInequality_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:variationalInequality_setDefaultSolverOptions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "variationalInequality_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "variationalInequality_setDefaultSolverOptions" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)variationalInequality_setDefaultSolverOptions(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_variationalInequality_ExtraGradient(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  VariationalInequality *arg1 = (VariationalInequality *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:variationalInequality_ExtraGradient",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_VariationalInequality, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "variationalInequality_ExtraGradient" "', argument " "1"" of type '" "VariationalInequality *""'"); 
  }
  arg1 = (VariationalInequality *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "variationalInequality_ExtraGradient" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        variationalInequality_ExtraGradient(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_variationalInequality_ExtraGradient_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:variationalInequality_ExtraGradient_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "variationalInequality_ExtraGradient_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)variationalInequality_ExtraGradient_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_variationalInequality_FixedPointProjection(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  VariationalInequality *arg1 = (VariationalInequality *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:variationalInequality_FixedPointProjection",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_VariationalInequality, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "variationalInequality_FixedPointProjection" "', argument " "1"" of type '" "VariationalInequality *""'"); 
  }
  arg1 = (VariationalInequality *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "variationalInequality_FixedPointProjection" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        variationalInequality_FixedPointProjection(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_variationalInequality_FixedPointProjection_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:variationalInequality_FixedPointProjection_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "variationalInequality_FixedPointProjection_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)variationalInequality_FixedPointProjection_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_variationalInequality_HyperplaneProjection(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  VariationalInequality *arg1 = (VariationalInequality *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:variationalInequality_HyperplaneProjection",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_VariationalInequality, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "variationalInequality_HyperplaneProjection" "', argument " "1"" of type '" "VariationalInequality *""'"); 
  }
  arg1 = (VariationalInequality *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "variationalInequality_HyperplaneProjection" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        variationalInequality_HyperplaneProjection(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_variationalInequality_HyperplaneProjection_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:variationalInequality_HyperplaneProjection_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "variationalInequality_HyperplaneProjection_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)variationalInequality_HyperplaneProjection_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_variationalInequality_box_newton_QiLSA(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  VariationalInequality *arg1 = (VariationalInequality *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:variationalInequality_box_newton_QiLSA",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_VariationalInequality, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "variationalInequality_box_newton_QiLSA" "', argument " "1"" of type '" "VariationalInequality *""'"); 
  }
  arg1 = (VariationalInequality *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "variationalInequality_box_newton_QiLSA" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        variationalInequality_box_newton_QiLSA(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_vi_box_AVI_LSA(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  VariationalInequality *arg1 = (VariationalInequality *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:vi_box_AVI_LSA",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_VariationalInequality, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vi_box_AVI_LSA" "', argument " "1"" of type '" "VariationalInequality *""'"); 
  }
  arg1 = (VariationalInequality *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "vi_box_AVI_LSA" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        vi_box_AVI_LSA(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_vi_box_AVI_extra_SolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:vi_box_AVI_extra_SolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vi_box_AVI_extra_SolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        vi_box_AVI_extra_SolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_vi_box_AVI_free_solverData(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:vi_box_AVI_free_solverData",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vi_box_AVI_free_solverData" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        vi_box_AVI_free_solverData(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_vi_get_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  void *arg1 = (void *) 0 ;
  int res1 ;
  PyObject * obj0 = 0 ;
  void *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:vi_get_set",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0,SWIG_as_voidptrptr(&arg1), 0, 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vi_get_set" "', argument " "1"" of type '" "void *""'"); 
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (void *)vi_get_set(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_vi_box_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  VariationalInequality *arg1 = (VariationalInequality *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:vi_box_path",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_VariationalInequality, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vi_box_path" "', argument " "1"" of type '" "VariationalInequality *""'"); 
  }
  arg1 = (VariationalInequality *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "vi_box_path" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        vi_box_path(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_variationalInequality_common_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:variationalInequality_common_setDefaultSolverOptions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "variationalInequality_common_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "variationalInequality_common_setDefaultSolverOptions" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)variationalInequality_common_setDefaultSolverOptions(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_checkTrivialCase_vi(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  VariationalInequality *arg1 = (VariationalInequality *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  SolverOptions *arg4 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:checkTrivialCase_vi",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_VariationalInequality, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "checkTrivialCase_vi" "', argument " "1"" of type '" "VariationalInequality *""'"); 
  }
  arg1 = (VariationalInequality *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "checkTrivialCase_vi" "', argument " "3"" of type '" "double *""'"); 
  }
  arg3 = (double *)(argp3);
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "checkTrivialCase_vi" "', argument " "4"" of type '" "SolverOptions *""'"); 
  }
  arg4 = (SolverOptions *)(argp4);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)checkTrivialCase_vi(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConvexQP_size_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct ConvexQP *arg1 = (struct ConvexQP *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ConvexQP_size_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ConvexQP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConvexQP_size_set" "', argument " "1"" of type '" "struct ConvexQP *""'"); 
  }
  arg1 = (struct ConvexQP *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ConvexQP_size_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->size = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConvexQP_size_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct ConvexQP *arg1 = (struct ConvexQP *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ConvexQP_size_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ConvexQP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConvexQP_size_get" "', argument " "1"" of type '" "struct ConvexQP *""'"); 
  }
  arg1 = (struct ConvexQP *)(argp1);
  result = (int) ((arg1)->size);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConvexQP_m_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct ConvexQP *arg1 = (struct ConvexQP *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ConvexQP_m_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ConvexQP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConvexQP_m_set" "', argument " "1"" of type '" "struct ConvexQP *""'"); 
  }
  arg1 = (struct ConvexQP *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ConvexQP_m_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->m = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConvexQP_m_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct ConvexQP *arg1 = (struct ConvexQP *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ConvexQP_m_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ConvexQP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConvexQP_m_get" "', argument " "1"" of type '" "struct ConvexQP *""'"); 
  }
  arg1 = (struct ConvexQP *)(argp1);
  result = (int) ((arg1)->m);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConvexQP_env_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct ConvexQP *arg1 = (struct ConvexQP *) 0 ;
  void *arg2 = (void *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ConvexQP_env_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ConvexQP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConvexQP_env_set" "', argument " "1"" of type '" "struct ConvexQP *""'"); 
  }
  arg1 = (struct ConvexQP *)(argp1);
  res2 = SWIG_ConvertPtr(obj1,SWIG_as_voidptrptr(&arg2), 0, SWIG_POINTER_DISOWN);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ConvexQP_env_set" "', argument " "2"" of type '" "void *""'"); 
  }
  if (arg1) (arg1)->env = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConvexQP_env_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct ConvexQP *arg1 = (struct ConvexQP *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  void *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ConvexQP_env_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ConvexQP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConvexQP_env_get" "', argument " "1"" of type '" "struct ConvexQP *""'"); 
  }
  arg1 = (struct ConvexQP *)(argp1);
  result = (void *) ((arg1)->env);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConvexQP_M_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct ConvexQP *arg1 = (struct ConvexQP *) 0 ;
  NumericsMatrix *arg2 = (NumericsMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array_2 = NULL ;
  int array_ctrl_2 = 0 ;
  PyArrayObject *array_i_2 = NULL ;
  int array_i_ctrl_2 = 0 ;
  PyArrayObject *array_p_2 = NULL ;
  int array_p_ctrl_2 = 0 ;
  int alloc_ctrl_2 = 0 ;
  NumericsMatrix *nummat2 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ConvexQP_M_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ConvexQP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConvexQP_M_set" "', argument " "1"" of type '" "struct ConvexQP *""'"); 
  }
  arg1 = (struct ConvexQP *)(argp1);
  {
    arg2 = NM_convert_from_python(obj1, &nummat2, &array_2, &array_ctrl_2, &array_i_2, &array_i_ctrl_2, &array_p_2, &array_p_ctrl_2, &alloc_ctrl_2);
    
    
    
    
    
    if (!arg2) {
      SWIG_fail; 
    }
  }
  {
    //  %typemap(memberin) (NumericsMatrix*)
    // perform a deep copy
    if (!arg1->M) {
      arg1->M = NM_create(arg2->storageType, arg2->size0, arg2->size1); 
    }
    NM_copy(arg2, arg1->M);
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConvexQP_M_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct ConvexQP *arg1 = (struct ConvexQP *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  NumericsMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ConvexQP_M_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ConvexQP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConvexQP_M_get" "', argument " "1"" of type '" "struct ConvexQP *""'"); 
  }
  arg1 = (struct ConvexQP *)(argp1);
  result = (NumericsMatrix *) ((arg1)->M);
  {
    if (strcmp("ConvexQP_M_get", "new_NumericsMatrix"))
    {
      resultobj = NM_to_python(result);
      
      
      
      if (!resultobj) SWIG_fail;
    }
    else
    {
      resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NumericsMatrix, SWIG_POINTER_NEW |  0 );
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConvexQP_q_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct ConvexQP *arg1 = (struct ConvexQP *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ConvexQP_q_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ConvexQP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConvexQP_q_set" "', argument " "1"" of type '" "struct ConvexQP *""'"); 
  }
  arg1 = (struct ConvexQP *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    // Still some dark magic :( --xhub
    char msg[1024];
    assert(arg1);
    if (!arg1->M)
    {
      SWIG_exception_fail(SWIG_RuntimeError, "M is not initialized, it sould be done first!");
    }
    
    int size = arg1->M->size0;
    if (size !=  array_size(array2, 0))
    {
      snprintf(msg, sizeof(msg), "Size of q is %ld, but the size of M is %d! Both should be equal!\n", array_size(array2, 0), size);
      SWIG_exception_fail(SWIG_RuntimeError, msg);
    }
    
    if (!arg1->q) {
      arg1->q = (double*)malloc(size * sizeof(double)); 
    }
    memcpy(arg1->q, arg2, size * sizeof(double));
    
  }
  resultobj = SWIG_Py_Void();
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConvexQP_q_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct ConvexQP *arg1 = (struct ConvexQP *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ConvexQP_q_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ConvexQP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConvexQP_q_get" "', argument " "1"" of type '" "struct ConvexQP *""'"); 
  }
  arg1 = (struct ConvexQP *)(argp1);
  result = (double *) ((arg1)->q);
  {
    if (!arg1->M) {
      SWIG_exception_fail(SWIG_RuntimeError, "M is not present, don't known the size"); 
    }
    
    if (result)
    {
      PyObject *obj;
      C_to_target_lang1(obj, arg1->M->size0, result, SWIG_fail);
      resultobj = obj;
    }
    else
    SWIG_fail;
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConvexQP_A_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct ConvexQP *arg1 = (struct ConvexQP *) 0 ;
  NumericsMatrix *arg2 = (NumericsMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array_2 = NULL ;
  int array_ctrl_2 = 0 ;
  PyArrayObject *array_i_2 = NULL ;
  int array_i_ctrl_2 = 0 ;
  PyArrayObject *array_p_2 = NULL ;
  int array_p_ctrl_2 = 0 ;
  int alloc_ctrl_2 = 0 ;
  NumericsMatrix *nummat2 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ConvexQP_A_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ConvexQP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConvexQP_A_set" "', argument " "1"" of type '" "struct ConvexQP *""'"); 
  }
  arg1 = (struct ConvexQP *)(argp1);
  {
    arg2 = NM_convert_from_python(obj1, &nummat2, &array_2, &array_ctrl_2, &array_i_2, &array_i_ctrl_2, &array_p_2, &array_p_ctrl_2, &alloc_ctrl_2);
    
    
    
    
    
    if (!arg2) {
      SWIG_fail; 
    }
  }
  {
    //  %typemap(memberin) (NumericsMatrix*)
    // perform a deep copy
    if (!arg1->A) {
      arg1->A = NM_create(arg2->storageType, arg2->size0, arg2->size1); 
    }
    NM_copy(arg2, arg1->A);
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConvexQP_A_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct ConvexQP *arg1 = (struct ConvexQP *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  NumericsMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ConvexQP_A_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ConvexQP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConvexQP_A_get" "', argument " "1"" of type '" "struct ConvexQP *""'"); 
  }
  arg1 = (struct ConvexQP *)(argp1);
  result = (NumericsMatrix *) ((arg1)->A);
  {
    if (strcmp("ConvexQP_A_get", "new_NumericsMatrix"))
    {
      resultobj = NM_to_python(result);
      
      
      
      if (!resultobj) SWIG_fail;
    }
    else
    {
      resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NumericsMatrix, SWIG_POINTER_NEW |  0 );
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConvexQP_b_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct ConvexQP *arg1 = (struct ConvexQP *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ConvexQP_b_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ConvexQP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConvexQP_b_set" "', argument " "1"" of type '" "struct ConvexQP *""'"); 
  }
  arg1 = (struct ConvexQP *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  if (arg1) (arg1)->b = arg2;
  resultobj = SWIG_Py_Void();
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConvexQP_b_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct ConvexQP *arg1 = (struct ConvexQP *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ConvexQP_b_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ConvexQP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConvexQP_b_get" "', argument " "1"" of type '" "struct ConvexQP *""'"); 
  }
  arg1 = (struct ConvexQP *)(argp1);
  result = (double *) ((arg1)->b);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConvexQP_ProjectionOnC_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct ConvexQP *arg1 = (struct ConvexQP *) 0 ;
  void (*arg2)(void *,double *,double *) = (void (*)(void *,double *,double *)) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ConvexQP_ProjectionOnC_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ConvexQP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConvexQP_ProjectionOnC_set" "', argument " "1"" of type '" "struct ConvexQP *""'"); 
  }
  arg1 = (struct ConvexQP *)(argp1);
  {
    int res = SWIG_ConvertFunctionPtr(obj1, (void**)(&arg2), SWIGTYPE_p_f_p_void_p_double_p_double__void);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "ConvexQP_ProjectionOnC_set" "', argument " "2"" of type '" "void (*)(void *,double *,double *)""'"); 
    }
  }
  if (arg1) (arg1)->ProjectionOnC = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConvexQP_ProjectionOnC_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct ConvexQP *arg1 = (struct ConvexQP *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  void (*result)(void *,double *,double *) = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ConvexQP_ProjectionOnC_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ConvexQP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConvexQP_ProjectionOnC_get" "', argument " "1"" of type '" "struct ConvexQP *""'"); 
  }
  arg1 = (struct ConvexQP *)(argp1);
  result = (void (*)(void *,double *,double *)) ((arg1)->ProjectionOnC);
  resultobj = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_void_p_double_p_double__void);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConvexQP_normConvexQP_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct ConvexQP *arg1 = (struct ConvexQP *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ConvexQP_normConvexQP_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ConvexQP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConvexQP_normConvexQP_set" "', argument " "1"" of type '" "struct ConvexQP *""'"); 
  }
  arg1 = (struct ConvexQP *)(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ConvexQP_normConvexQP_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->normConvexQP = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConvexQP_normConvexQP_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct ConvexQP *arg1 = (struct ConvexQP *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ConvexQP_normConvexQP_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ConvexQP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConvexQP_normConvexQP_get" "', argument " "1"" of type '" "struct ConvexQP *""'"); 
  }
  arg1 = (struct ConvexQP *)(argp1);
  result = (double) ((arg1)->normConvexQP);
  resultobj = SWIG_From_double((double)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConvexQP_istheNormConvexQPset_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct ConvexQP *arg1 = (struct ConvexQP *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ConvexQP_istheNormConvexQPset_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ConvexQP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConvexQP_istheNormConvexQPset_set" "', argument " "1"" of type '" "struct ConvexQP *""'"); 
  }
  arg1 = (struct ConvexQP *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ConvexQP_istheNormConvexQPset_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->istheNormConvexQPset = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConvexQP_istheNormConvexQPset_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct ConvexQP *arg1 = (struct ConvexQP *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ConvexQP_istheNormConvexQPset_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ConvexQP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConvexQP_istheNormConvexQPset_get" "', argument " "1"" of type '" "struct ConvexQP *""'"); 
  }
  arg1 = (struct ConvexQP *)(argp1);
  result = (int) ((arg1)->istheNormConvexQPset);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConvexQP_set_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct ConvexQP *arg1 = (struct ConvexQP *) 0 ;
  void *arg2 = (void *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ConvexQP_set_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ConvexQP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConvexQP_set_set" "', argument " "1"" of type '" "struct ConvexQP *""'"); 
  }
  arg1 = (struct ConvexQP *)(argp1);
  res2 = SWIG_ConvertPtr(obj1,SWIG_as_voidptrptr(&arg2), 0, SWIG_POINTER_DISOWN);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ConvexQP_set_set" "', argument " "2"" of type '" "void *""'"); 
  }
  if (arg1) (arg1)->set = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConvexQP_set_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct ConvexQP *arg1 = (struct ConvexQP *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  void *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ConvexQP_set_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ConvexQP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConvexQP_set_get" "', argument " "1"" of type '" "struct ConvexQP *""'"); 
  }
  arg1 = (struct ConvexQP *)(argp1);
  result = (void *) ((arg1)->set);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ConvexQP(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct ConvexQP *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ConvexQP")) SWIG_fail;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct ConvexQP *)calloc(1, sizeof(struct ConvexQP));
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ConvexQP, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ConvexQP(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct ConvexQP *arg1 = (struct ConvexQP *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ConvexQP",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ConvexQP, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ConvexQP" "', argument " "1"" of type '" "struct ConvexQP *""'"); 
  }
  arg1 = (struct ConvexQP *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        free((char *) arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ConvexQP_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ConvexQP, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_convexQP_display(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ConvexQP *arg1 = (ConvexQP *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:convexQP_display",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ConvexQP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "convexQP_display" "', argument " "1"" of type '" "ConvexQP *""'"); 
  }
  arg1 = (ConvexQP *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        convexQP_display(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_convexQP_printInFile(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ConvexQP *arg1 = (ConvexQP *) 0 ;
  FILE *arg2 = (FILE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:convexQP_printInFile",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ConvexQP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "convexQP_printInFile" "', argument " "1"" of type '" "ConvexQP *""'"); 
  }
  arg1 = (ConvexQP *)(argp1);
  {
    // %typemap(in) (FILE *file)
    int alloc = 1;
    char* cstr;
    int res = SWIG_AsCharPtrAndSize(obj1, &cstr, NULL, &alloc);
    if (!SWIG_IsOK(res)) {
      SWIG_Error(SWIG_ArgError(res), "in method unknown', argument " "1"" of type '" "char *""'");
    }
    arg2 = fopen(cstr, "r");
    if (!arg2)
    {
      SWIG_Error(SWIG_IOError, format_msg_concat("in method '" "convexQP_printInFile" "' cannot fopen file", cstr));
      if (alloc == SWIG_NEWOBJ) free(cstr);
      SWIG_fail;
    }
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)convexQP_printInFile(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_convexQP_newFromFile(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ConvexQP *arg1 = (ConvexQP *) 0 ;
  FILE *arg2 = (FILE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:convexQP_newFromFile",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ConvexQP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "convexQP_newFromFile" "', argument " "1"" of type '" "ConvexQP *""'"); 
  }
  arg1 = (ConvexQP *)(argp1);
  {
    // %typemap(in) (FILE *file)
    int alloc = 1;
    char* cstr;
    int res = SWIG_AsCharPtrAndSize(obj1, &cstr, NULL, &alloc);
    if (!SWIG_IsOK(res)) {
      SWIG_Error(SWIG_ArgError(res), "in method unknown', argument " "1"" of type '" "char *""'");
    }
    arg2 = fopen(cstr, "r");
    if (!arg2)
    {
      SWIG_Error(SWIG_IOError, format_msg_concat("in method '" "convexQP_newFromFile" "' cannot fopen file", cstr));
      if (alloc == SWIG_NEWOBJ) free(cstr);
      SWIG_fail;
    }
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)convexQP_newFromFile(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_convexQP_free(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ConvexQP *arg1 = (ConvexQP *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:convexQP_free",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ConvexQP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "convexQP_free" "', argument " "1"" of type '" "ConvexQP *""'"); 
  }
  arg1 = (ConvexQP *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        convexQP_free(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_convexQP_clear(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ConvexQP *arg1 = (ConvexQP *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:convexQP_clear",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ConvexQP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "convexQP_clear" "', argument " "1"" of type '" "ConvexQP *""'"); 
  }
  arg1 = (ConvexQP *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        convexQP_clear(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_convexQP_new(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  ConvexQP *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:convexQP_new",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "convexQP_new" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (ConvexQP *)convexQP_new(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ConvexQP, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_convexQP_get_env(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  void *arg1 = (void *) 0 ;
  int res1 ;
  PyObject * obj0 = 0 ;
  void *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:convexQP_get_env",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0,SWIG_as_voidptrptr(&arg1), 0, 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "convexQP_get_env" "', argument " "1"" of type '" "void *""'"); 
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (void *)convexQP_get_env(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_convexQP_ProjectedGradient(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ConvexQP *arg1 = (ConvexQP *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:convexQP_ProjectedGradient",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ConvexQP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "convexQP_ProjectedGradient" "', argument " "1"" of type '" "ConvexQP *""'"); 
  }
  arg1 = (ConvexQP *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "convexQP_ProjectedGradient" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        convexQP_ProjectedGradient(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_convexQP_ProjectedGradient_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:convexQP_ProjectedGradient_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "convexQP_ProjectedGradient_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)convexQP_ProjectedGradient_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_convexQP_VI_solver(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ConvexQP *arg1 = (ConvexQP *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:convexQP_VI_solver",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ConvexQP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "convexQP_VI_solver" "', argument " "1"" of type '" "ConvexQP *""'"); 
  }
  arg1 = (ConvexQP *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "convexQP_VI_solver" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        convexQP_VI_solver(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_convexQP_VI_solver_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:convexQP_VI_solver_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "convexQP_VI_solver_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)convexQP_VI_solver_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_convexQP_ADMM(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ConvexQP *arg1 = (ConvexQP *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  int *arg6 = (int *) 0 ;
  SolverOptions *arg7 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  PyArrayObject *array5 = NULL ;
  int is_new_object5 = 0 ;
  int temp_info6 = -1 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg6 = &temp_info6;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOOOO:convexQP_ADMM",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ConvexQP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "convexQP_ADMM" "', argument " "1"" of type '" "ConvexQP *""'"); 
  }
  arg1 = (ConvexQP *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "convexQP_ADMM" "', argument " "4"" of type '" "double *""'"); 
  }
  arg4 = (double *)(argp4);
  {
    array5 = obj_to_sn_vector(obj4, &is_new_object5);
    
    if (!array5)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array5))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg5 = (double *) array_data(array5);
    
  }
  res7 = SWIG_ConvertPtr(obj5, &argp7,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res7)) {
    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "convexQP_ADMM" "', argument " "7"" of type '" "SolverOptions *""'"); 
  }
  arg7 = (SolverOptions *)(argp7);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        convexQP_ADMM(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg6);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object5 && array5) {
      Py_DECREF(array5); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object5 && array5) {
      Py_DECREF(array5); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_convexQP_ADMM_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:convexQP_ADMM_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "convexQP_ADMM_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)convexQP_ADMM_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_convexQP_ADMM_init(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ConvexQP *arg1 = (ConvexQP *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:convexQP_ADMM_init",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ConvexQP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "convexQP_ADMM_init" "', argument " "1"" of type '" "ConvexQP *""'"); 
  }
  arg1 = (ConvexQP *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "convexQP_ADMM_init" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        convexQP_ADMM_init(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_convexQP_ADMM_free(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ConvexQP *arg1 = (ConvexQP *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:convexQP_ADMM_free",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ConvexQP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "convexQP_ADMM_free" "', argument " "1"" of type '" "ConvexQP *""'"); 
  }
  arg1 = (ConvexQP *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "convexQP_ADMM_free" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        convexQP_ADMM_free(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int Swig_var_SICONOS_CONVEXQP_PG_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_CONVEXQP_PG_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_CONVEXQP_PG_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_CONVEXQP_PG_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_CONVEXQP_VI_FPP_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_CONVEXQP_VI_FPP_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_CONVEXQP_VI_FPP_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_CONVEXQP_VI_FPP_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_CONVEXQP_VI_EG_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_CONVEXQP_VI_EG_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_CONVEXQP_VI_EG_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_CONVEXQP_VI_EG_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_CONVEXQP_ADMM_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_CONVEXQP_ADMM_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_CONVEXQP_ADMM_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_CONVEXQP_ADMM_STR);
  return pyobj;
}


SWIGINTERN PyObject *_wrap_SecondOrderConeLinearComplementarityProblem_n_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SecondOrderConeLinearComplementarityProblem *arg1 = (struct SecondOrderConeLinearComplementarityProblem *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SecondOrderConeLinearComplementarityProblem_n_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SecondOrderConeLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecondOrderConeLinearComplementarityProblem_n_set" "', argument " "1"" of type '" "struct SecondOrderConeLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct SecondOrderConeLinearComplementarityProblem *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SecondOrderConeLinearComplementarityProblem_n_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->n = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecondOrderConeLinearComplementarityProblem_n_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SecondOrderConeLinearComplementarityProblem *arg1 = (struct SecondOrderConeLinearComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SecondOrderConeLinearComplementarityProblem_n_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SecondOrderConeLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecondOrderConeLinearComplementarityProblem_n_get" "', argument " "1"" of type '" "struct SecondOrderConeLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct SecondOrderConeLinearComplementarityProblem *)(argp1);
  result = (int) ((arg1)->n);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecondOrderConeLinearComplementarityProblem_nc_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SecondOrderConeLinearComplementarityProblem *arg1 = (struct SecondOrderConeLinearComplementarityProblem *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SecondOrderConeLinearComplementarityProblem_nc_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SecondOrderConeLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecondOrderConeLinearComplementarityProblem_nc_set" "', argument " "1"" of type '" "struct SecondOrderConeLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct SecondOrderConeLinearComplementarityProblem *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SecondOrderConeLinearComplementarityProblem_nc_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->nc = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecondOrderConeLinearComplementarityProblem_nc_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SecondOrderConeLinearComplementarityProblem *arg1 = (struct SecondOrderConeLinearComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SecondOrderConeLinearComplementarityProblem_nc_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SecondOrderConeLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecondOrderConeLinearComplementarityProblem_nc_get" "', argument " "1"" of type '" "struct SecondOrderConeLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct SecondOrderConeLinearComplementarityProblem *)(argp1);
  result = (int) ((arg1)->nc);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecondOrderConeLinearComplementarityProblem_M_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SecondOrderConeLinearComplementarityProblem *arg1 = (struct SecondOrderConeLinearComplementarityProblem *) 0 ;
  NumericsMatrix *arg2 = (NumericsMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array_2 = NULL ;
  int array_ctrl_2 = 0 ;
  PyArrayObject *array_i_2 = NULL ;
  int array_i_ctrl_2 = 0 ;
  PyArrayObject *array_p_2 = NULL ;
  int array_p_ctrl_2 = 0 ;
  int alloc_ctrl_2 = 0 ;
  NumericsMatrix *nummat2 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SecondOrderConeLinearComplementarityProblem_M_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SecondOrderConeLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecondOrderConeLinearComplementarityProblem_M_set" "', argument " "1"" of type '" "struct SecondOrderConeLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct SecondOrderConeLinearComplementarityProblem *)(argp1);
  {
    arg2 = NM_convert_from_python(obj1, &nummat2, &array_2, &array_ctrl_2, &array_i_2, &array_i_ctrl_2, &array_p_2, &array_p_ctrl_2, &alloc_ctrl_2);
    
    
    
    
    
    if (!arg2) {
      SWIG_fail; 
    }
  }
  {
    //  %typemap(memberin) (NumericsMatrix*)
    // perform a deep copy
    if (!arg1->M) {
      arg1->M = NM_create(arg2->storageType, arg2->size0, arg2->size1); 
    }
    NM_copy(arg2, arg1->M);
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecondOrderConeLinearComplementarityProblem_M_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SecondOrderConeLinearComplementarityProblem *arg1 = (struct SecondOrderConeLinearComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  NumericsMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SecondOrderConeLinearComplementarityProblem_M_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SecondOrderConeLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecondOrderConeLinearComplementarityProblem_M_get" "', argument " "1"" of type '" "struct SecondOrderConeLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct SecondOrderConeLinearComplementarityProblem *)(argp1);
  result = (NumericsMatrix *) ((arg1)->M);
  {
    if (strcmp("SecondOrderConeLinearComplementarityProblem_M_get", "new_NumericsMatrix"))
    {
      resultobj = NM_to_python(result);
      
      
      
      if (!resultobj) SWIG_fail;
    }
    else
    {
      resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NumericsMatrix, SWIG_POINTER_NEW |  0 );
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecondOrderConeLinearComplementarityProblem_q_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SecondOrderConeLinearComplementarityProblem *arg1 = (struct SecondOrderConeLinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SecondOrderConeLinearComplementarityProblem_q_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SecondOrderConeLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecondOrderConeLinearComplementarityProblem_q_set" "', argument " "1"" of type '" "struct SecondOrderConeLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct SecondOrderConeLinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    // Still some dark magic :( --xhub
    char msg[1024];
    assert(arg1);
    if (!arg1->M)
    {
      SWIG_exception_fail(SWIG_RuntimeError, "M is not initialized, it sould be done first!");
    }
    
    int size = arg1->M->size0;
    if (size !=  array_size(array2, 0))
    {
      snprintf(msg, sizeof(msg), "Size of q is %ld, but the size of M is %d! Both should be equal!\n", array_size(array2, 0), size);
      SWIG_exception_fail(SWIG_RuntimeError, msg);
    }
    
    if (!arg1->q) {
      arg1->q = (double*)malloc(size * sizeof(double)); 
    }
    memcpy(arg1->q, arg2, size * sizeof(double));
    
  }
  resultobj = SWIG_Py_Void();
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecondOrderConeLinearComplementarityProblem_q_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SecondOrderConeLinearComplementarityProblem *arg1 = (struct SecondOrderConeLinearComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SecondOrderConeLinearComplementarityProblem_q_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SecondOrderConeLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecondOrderConeLinearComplementarityProblem_q_get" "', argument " "1"" of type '" "struct SecondOrderConeLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct SecondOrderConeLinearComplementarityProblem *)(argp1);
  result = (double *) ((arg1)->q);
  {
    if (!arg1->M) {
      SWIG_exception_fail(SWIG_RuntimeError, "M is not present, don't known the size"); 
    }
    
    if (result)
    {
      PyObject *obj;
      C_to_target_lang1(obj, arg1->M->size0, result, SWIG_fail);
      resultobj = obj;
    }
    else
    SWIG_fail;
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecondOrderConeLinearComplementarityProblem_coneIndex_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SecondOrderConeLinearComplementarityProblem *arg1 = (struct SecondOrderConeLinearComplementarityProblem *) 0 ;
  unsigned int *arg2 = (unsigned int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SecondOrderConeLinearComplementarityProblem_coneIndex_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SecondOrderConeLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecondOrderConeLinearComplementarityProblem_coneIndex_set" "', argument " "1"" of type '" "struct SecondOrderConeLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct SecondOrderConeLinearComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_unsigned_int, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecondOrderConeLinearComplementarityProblem_coneIndex_set" "', argument " "2"" of type '" "unsigned int *""'"); 
  }
  arg2 = (unsigned int *)(argp2);
  if (arg1) (arg1)->coneIndex = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecondOrderConeLinearComplementarityProblem_coneIndex_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SecondOrderConeLinearComplementarityProblem *arg1 = (struct SecondOrderConeLinearComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SecondOrderConeLinearComplementarityProblem_coneIndex_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SecondOrderConeLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecondOrderConeLinearComplementarityProblem_coneIndex_get" "', argument " "1"" of type '" "struct SecondOrderConeLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct SecondOrderConeLinearComplementarityProblem *)(argp1);
  result = (unsigned int *) ((arg1)->coneIndex);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_int, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecondOrderConeLinearComplementarityProblem_tau_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SecondOrderConeLinearComplementarityProblem *arg1 = (struct SecondOrderConeLinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SecondOrderConeLinearComplementarityProblem_tau_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SecondOrderConeLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecondOrderConeLinearComplementarityProblem_tau_set" "', argument " "1"" of type '" "struct SecondOrderConeLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct SecondOrderConeLinearComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_double, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecondOrderConeLinearComplementarityProblem_tau_set" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = (double *)(argp2);
  if (arg1) (arg1)->tau = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecondOrderConeLinearComplementarityProblem_tau_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SecondOrderConeLinearComplementarityProblem *arg1 = (struct SecondOrderConeLinearComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SecondOrderConeLinearComplementarityProblem_tau_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SecondOrderConeLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecondOrderConeLinearComplementarityProblem_tau_get" "', argument " "1"" of type '" "struct SecondOrderConeLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct SecondOrderConeLinearComplementarityProblem *)(argp1);
  result = (double *) ((arg1)->tau);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SecondOrderConeLinearComplementarityProblem(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SecondOrderConeLinearComplementarityProblem *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_SecondOrderConeLinearComplementarityProblem")) SWIG_fail;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct SecondOrderConeLinearComplementarityProblem *)calloc(1, sizeof(struct SecondOrderConeLinearComplementarityProblem));
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SecondOrderConeLinearComplementarityProblem, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SecondOrderConeLinearComplementarityProblem(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SecondOrderConeLinearComplementarityProblem *arg1 = (struct SecondOrderConeLinearComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_SecondOrderConeLinearComplementarityProblem",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SecondOrderConeLinearComplementarityProblem, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SecondOrderConeLinearComplementarityProblem" "', argument " "1"" of type '" "struct SecondOrderConeLinearComplementarityProblem *""'"); 
  }
  arg1 = (struct SecondOrderConeLinearComplementarityProblem *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        free((char *) arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SecondOrderConeLinearComplementarityProblem_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_SecondOrderConeLinearComplementarityProblem, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_secondOrderConeLinearComplementarityProblem_display(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SecondOrderConeLinearComplementarityProblem *arg1 = (SecondOrderConeLinearComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:secondOrderConeLinearComplementarityProblem_display",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SecondOrderConeLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "secondOrderConeLinearComplementarityProblem_display" "', argument " "1"" of type '" "SecondOrderConeLinearComplementarityProblem *""'"); 
  }
  arg1 = (SecondOrderConeLinearComplementarityProblem *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        secondOrderConeLinearComplementarityProblem_display(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_secondOrderConeLinearComplementarityProblem_printInFile(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SecondOrderConeLinearComplementarityProblem *arg1 = (SecondOrderConeLinearComplementarityProblem *) 0 ;
  FILE *arg2 = (FILE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:secondOrderConeLinearComplementarityProblem_printInFile",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SecondOrderConeLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "secondOrderConeLinearComplementarityProblem_printInFile" "', argument " "1"" of type '" "SecondOrderConeLinearComplementarityProblem *""'"); 
  }
  arg1 = (SecondOrderConeLinearComplementarityProblem *)(argp1);
  {
    // %typemap(in) (FILE *file)
    int alloc = 1;
    char* cstr;
    int res = SWIG_AsCharPtrAndSize(obj1, &cstr, NULL, &alloc);
    if (!SWIG_IsOK(res)) {
      SWIG_Error(SWIG_ArgError(res), "in method unknown', argument " "1"" of type '" "char *""'");
    }
    arg2 = fopen(cstr, "r");
    if (!arg2)
    {
      SWIG_Error(SWIG_IOError, format_msg_concat("in method '" "secondOrderConeLinearComplementarityProblem_printInFile" "' cannot fopen file", cstr));
      if (alloc == SWIG_NEWOBJ) free(cstr);
      SWIG_fail;
    }
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)secondOrderConeLinearComplementarityProblem_printInFile(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_secondOrderConeLinearComplementarityProblem_printInFilename(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SecondOrderConeLinearComplementarityProblem *arg1 = (SecondOrderConeLinearComplementarityProblem *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:secondOrderConeLinearComplementarityProblem_printInFilename",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SecondOrderConeLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "secondOrderConeLinearComplementarityProblem_printInFilename" "', argument " "1"" of type '" "SecondOrderConeLinearComplementarityProblem *""'"); 
  }
  arg1 = (SecondOrderConeLinearComplementarityProblem *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "secondOrderConeLinearComplementarityProblem_printInFilename" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)secondOrderConeLinearComplementarityProblem_printInFilename(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_secondOrderConeLinearComplementarityProblem_newFromFile(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SecondOrderConeLinearComplementarityProblem *arg1 = (SecondOrderConeLinearComplementarityProblem *) 0 ;
  FILE *arg2 = (FILE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:secondOrderConeLinearComplementarityProblem_newFromFile",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SecondOrderConeLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "secondOrderConeLinearComplementarityProblem_newFromFile" "', argument " "1"" of type '" "SecondOrderConeLinearComplementarityProblem *""'"); 
  }
  arg1 = (SecondOrderConeLinearComplementarityProblem *)(argp1);
  {
    // %typemap(in) (FILE *file)
    int alloc = 1;
    char* cstr;
    int res = SWIG_AsCharPtrAndSize(obj1, &cstr, NULL, &alloc);
    if (!SWIG_IsOK(res)) {
      SWIG_Error(SWIG_ArgError(res), "in method unknown', argument " "1"" of type '" "char *""'");
    }
    arg2 = fopen(cstr, "r");
    if (!arg2)
    {
      SWIG_Error(SWIG_IOError, format_msg_concat("in method '" "secondOrderConeLinearComplementarityProblem_newFromFile" "' cannot fopen file", cstr));
      if (alloc == SWIG_NEWOBJ) free(cstr);
      SWIG_fail;
    }
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)secondOrderConeLinearComplementarityProblem_newFromFile(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_secondOrderConeLinearComplementarityProblem_newFromFilename(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SecondOrderConeLinearComplementarityProblem *arg1 = (SecondOrderConeLinearComplementarityProblem *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:secondOrderConeLinearComplementarityProblem_newFromFilename",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SecondOrderConeLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "secondOrderConeLinearComplementarityProblem_newFromFilename" "', argument " "1"" of type '" "SecondOrderConeLinearComplementarityProblem *""'"); 
  }
  arg1 = (SecondOrderConeLinearComplementarityProblem *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "secondOrderConeLinearComplementarityProblem_newFromFilename" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)secondOrderConeLinearComplementarityProblem_newFromFilename(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_freeSecondOrderConeLinearComplementarityProblem(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SecondOrderConeLinearComplementarityProblem *arg1 = (SecondOrderConeLinearComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:freeSecondOrderConeLinearComplementarityProblem",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SecondOrderConeLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "freeSecondOrderConeLinearComplementarityProblem" "', argument " "1"" of type '" "SecondOrderConeLinearComplementarityProblem *""'"); 
  }
  arg1 = (SecondOrderConeLinearComplementarityProblem *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        freeSecondOrderConeLinearComplementarityProblem(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_secondOrderConeLinearComplementarityProblem_new(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  int arg2 ;
  NumericsMatrix *arg3 = (NumericsMatrix *) 0 ;
  double *arg4 = (double *) 0 ;
  unsigned int *arg5 = (unsigned int *) 0 ;
  double *arg6 = (double *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyArrayObject *array_3 = NULL ;
  int array_ctrl_3 = 0 ;
  PyArrayObject *array_i_3 = NULL ;
  int array_i_ctrl_3 = 0 ;
  PyArrayObject *array_p_3 = NULL ;
  int array_p_ctrl_3 = 0 ;
  int alloc_ctrl_3 = 0 ;
  NumericsMatrix *nummat3 = NULL ;
  PyArrayObject *array4 = NULL ;
  int is_new_object4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyArrayObject *array6 = NULL ;
  int is_new_object6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  SecondOrderConeLinearComplementarityProblem *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOO:secondOrderConeLinearComplementarityProblem_new",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "secondOrderConeLinearComplementarityProblem_new" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "secondOrderConeLinearComplementarityProblem_new" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    arg3 = NM_convert_from_python(obj2, &nummat3, &array_3, &array_ctrl_3, &array_i_3, &array_i_ctrl_3, &array_p_3, &array_p_ctrl_3, &alloc_ctrl_3);
    
    
    
    
    
    if (!arg3) {
      SWIG_fail; 
    }
  }
  {
    array4 = obj_to_sn_vector(obj3, &is_new_object4);
    
    if (!array4)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array4))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg4 = (double *) array_data(array4);
    
  }
  res5 = SWIG_ConvertPtr(obj4, &argp5,SWIGTYPE_p_unsigned_int, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "secondOrderConeLinearComplementarityProblem_new" "', argument " "5"" of type '" "unsigned int *""'"); 
  }
  arg5 = (unsigned int *)(argp5);
  {
    array6 = obj_to_sn_vector(obj5, &is_new_object6);
    
    if (!array6)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array6))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg6 = (double *) array_data(array6);
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (SecondOrderConeLinearComplementarityProblem *)secondOrderConeLinearComplementarityProblem_new(arg1,arg2,arg3,arg4,arg5,arg6);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SecondOrderConeLinearComplementarityProblem, 0 |  0 );
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_3 && array_3) {
      Py_DECREF(array_3); 
    };
    if(array_i_ctrl_3 && array_i_3) {
      Py_DECREF(array_i_3); 
    };
    if(array_p_ctrl_3 && array_p_3) {
      Py_DECREF(array_p_3); 
    };
    
    if (nummat3)
    {
      if (!NM_clean(nummat3, alloc_ctrl_3)) {
        return NULL; 
      }
      NM_free(nummat3);
      free(nummat3);
    }
    
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  {
    if(is_new_object6 && array6) {
      Py_DECREF(array6); 
    };
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_3 && array_3) {
      Py_DECREF(array_3); 
    };
    if(array_i_ctrl_3 && array_i_3) {
      Py_DECREF(array_i_3); 
    };
    if(array_p_ctrl_3 && array_p_3) {
      Py_DECREF(array_p_3); 
    };
    
    if (nummat3)
    {
      if (!NM_clean(nummat3, alloc_ctrl_3)) {
        return NULL; 
      }
      NM_free(nummat3);
      free(nummat3);
    }
    
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  {
    if(is_new_object6 && array6) {
      Py_DECREF(array6); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_soclcp_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:soclcp_setDefaultSolverOptions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "soclcp_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "soclcp_setDefaultSolverOptions" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)soclcp_setDefaultSolverOptions(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_soclcp_nsgs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SecondOrderConeLinearComplementarityProblem *arg1 = (SecondOrderConeLinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:soclcp_nsgs",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SecondOrderConeLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "soclcp_nsgs" "', argument " "1"" of type '" "SecondOrderConeLinearComplementarityProblem *""'"); 
  }
  arg1 = (SecondOrderConeLinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "soclcp_nsgs" "', argument " "3"" of type '" "double *""'"); 
  }
  arg3 = (double *)(argp3);
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "soclcp_nsgs" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        soclcp_nsgs(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_soclcp_nsgs_fillMLocal(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SecondOrderConeLinearComplementarityProblem *arg1 = (SecondOrderConeLinearComplementarityProblem *) 0 ;
  SecondOrderConeLinearComplementarityProblem *arg2 = (SecondOrderConeLinearComplementarityProblem *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:soclcp_nsgs_fillMLocal",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SecondOrderConeLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "soclcp_nsgs_fillMLocal" "', argument " "1"" of type '" "SecondOrderConeLinearComplementarityProblem *""'"); 
  }
  arg1 = (SecondOrderConeLinearComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SecondOrderConeLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "soclcp_nsgs_fillMLocal" "', argument " "2"" of type '" "SecondOrderConeLinearComplementarityProblem *""'"); 
  }
  arg2 = (SecondOrderConeLinearComplementarityProblem *)(argp2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "soclcp_nsgs_fillMLocal" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        soclcp_nsgs_fillMLocal(arg1,arg2,arg3);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_soclcp_nsgs_computeqLocal(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SecondOrderConeLinearComplementarityProblem *arg1 = (SecondOrderConeLinearComplementarityProblem *) 0 ;
  SecondOrderConeLinearComplementarityProblem *arg2 = (SecondOrderConeLinearComplementarityProblem *) 0 ;
  double *arg3 = (double *) 0 ;
  int arg4 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:soclcp_nsgs_computeqLocal",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SecondOrderConeLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "soclcp_nsgs_computeqLocal" "', argument " "1"" of type '" "SecondOrderConeLinearComplementarityProblem *""'"); 
  }
  arg1 = (SecondOrderConeLinearComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SecondOrderConeLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "soclcp_nsgs_computeqLocal" "', argument " "2"" of type '" "SecondOrderConeLinearComplementarityProblem *""'"); 
  }
  arg2 = (SecondOrderConeLinearComplementarityProblem *)(argp2);
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  ecode4 = SWIG_AsVal_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "soclcp_nsgs_computeqLocal" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  res5 = SWIG_ConvertPtr(obj4, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "soclcp_nsgs_computeqLocal" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        soclcp_nsgs_computeqLocal(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_soclcp_nsgs_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:soclcp_nsgs_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "soclcp_nsgs_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)soclcp_nsgs_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_soclcp_VI_FixedPointProjection(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SecondOrderConeLinearComplementarityProblem *arg1 = (SecondOrderConeLinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:soclcp_VI_FixedPointProjection",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SecondOrderConeLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "soclcp_VI_FixedPointProjection" "', argument " "1"" of type '" "SecondOrderConeLinearComplementarityProblem *""'"); 
  }
  arg1 = (SecondOrderConeLinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "soclcp_VI_FixedPointProjection" "', argument " "3"" of type '" "double *""'"); 
  }
  arg3 = (double *)(argp3);
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "soclcp_VI_FixedPointProjection" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        soclcp_VI_FixedPointProjection(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_soclcp_VI_FixedPointProjection_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:soclcp_VI_FixedPointProjection_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "soclcp_VI_FixedPointProjection_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)soclcp_VI_FixedPointProjection_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_soclcp_VI_ExtraGradient(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SecondOrderConeLinearComplementarityProblem *arg1 = (SecondOrderConeLinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:soclcp_VI_ExtraGradient",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SecondOrderConeLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "soclcp_VI_ExtraGradient" "', argument " "1"" of type '" "SecondOrderConeLinearComplementarityProblem *""'"); 
  }
  arg1 = (SecondOrderConeLinearComplementarityProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "soclcp_VI_ExtraGradient" "', argument " "3"" of type '" "double *""'"); 
  }
  arg3 = (double *)(argp3);
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "soclcp_VI_ExtraGradient" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        soclcp_VI_ExtraGradient(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_soclcp_VI_ExtraGradient_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:soclcp_VI_ExtraGradient_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "soclcp_VI_ExtraGradient_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)soclcp_VI_ExtraGradient_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_soclcp_checkTrivialCase(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SecondOrderConeLinearComplementarityProblem *arg1 = (SecondOrderConeLinearComplementarityProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  SolverOptions *arg4 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:soclcp_checkTrivialCase",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SecondOrderConeLinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "soclcp_checkTrivialCase" "', argument " "1"" of type '" "SecondOrderConeLinearComplementarityProblem *""'"); 
  }
  arg1 = (SecondOrderConeLinearComplementarityProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "soclcp_checkTrivialCase" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = (double *)(argp2);
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "soclcp_checkTrivialCase" "', argument " "4"" of type '" "SolverOptions *""'"); 
  }
  arg4 = (SolverOptions *)(argp4);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)soclcp_checkTrivialCase(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN int Swig_var_SICONOS_SOCLCP_NSGS_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_SOCLCP_NSGS_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_SOCLCP_NSGS_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_SOCLCP_NSGS_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_SOCLCP_NSGSV_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_SOCLCP_NSGSV_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_SOCLCP_NSGSV_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_SOCLCP_NSGSV_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_SOCLCP_PROX_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_SOCLCP_PROX_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_SOCLCP_PROX_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_SOCLCP_PROX_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_SOCLCP_TFP_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_SOCLCP_TFP_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_SOCLCP_TFP_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_SOCLCP_TFP_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_SOCLCP_NSN_AC_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_SOCLCP_NSN_AC_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_SOCLCP_NSN_AC_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_SOCLCP_NSN_AC_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_SOCLCP_NSN_FB_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_SOCLCP_NSN_FB_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_SOCLCP_NSN_FB_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_SOCLCP_NSN_FB_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_SOCLCP_DSFP_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_SOCLCP_DSFP_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_SOCLCP_DSFP_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_SOCLCP_DSFP_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_SOCLCP_VI_EG_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_SOCLCP_VI_EG_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_SOCLCP_VI_EG_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_SOCLCP_VI_EG_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_SOCLCP_VI_FPP_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_SOCLCP_VI_FPP_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_SOCLCP_VI_FPP_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_SOCLCP_VI_FPP_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_SOCLCP_EG_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_SOCLCP_EG_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_SOCLCP_EG_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_SOCLCP_EG_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_SOCLCP_FPP_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_SOCLCP_FPP_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_SOCLCP_FPP_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_SOCLCP_FPP_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_SOCLCP_HP_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_SOCLCP_HP_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_SOCLCP_HP_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_SOCLCP_HP_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_SOCLCP_NCPGlockerFBFixedPoint_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_SOCLCP_NCPGlockerFBFixedPoint_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_SOCLCP_NCPGlockerFBFixedPoint_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_SOCLCP_NCPGlockerFBFixedPoint_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_SOCLCP_AlartCurnierNewton_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_SOCLCP_AlartCurnierNewton_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_SOCLCP_AlartCurnierNewton_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_SOCLCP_AlartCurnierNewton_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_SOCLCP_DampedAlartCurnierNewton_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_SOCLCP_DampedAlartCurnierNewton_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_SOCLCP_DampedAlartCurnierNewton_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_SOCLCP_DampedAlartCurnierNewton_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_SOCLCP_NCPGlockerFBNewton_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_SOCLCP_NCPGlockerFBNewton_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_SOCLCP_NCPGlockerFBNewton_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_SOCLCP_NCPGlockerFBNewton_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_SOCLCP_ProjectionOnConeWithDiagonalization_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_SOCLCP_ProjectionOnConeWithDiagonalization_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_SOCLCP_ProjectionOnConeWithDiagonalization_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_SOCLCP_ProjectionOnConeWithDiagonalization_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_SOCLCP_ProjectionOnCone_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_SOCLCP_ProjectionOnCone_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_SOCLCP_ProjectionOnCone_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_SOCLCP_ProjectionOnCone_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_SOCLCP_ProjectionOnConeWithLocalIteration_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_SOCLCP_ProjectionOnConeWithLocalIteration_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_SOCLCP_ProjectionOnConeWithLocalIteration_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_SOCLCP_ProjectionOnConeWithLocalIteration_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_SOCLCP_projectionOnConeWithRegularization_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_SOCLCP_projectionOnConeWithRegularization_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_SOCLCP_projectionOnConeWithRegularization_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_SOCLCP_projectionOnConeWithRegularization_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_SOCLCP_NCPGlockerFBPATH_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_SOCLCP_NCPGlockerFBPATH_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_SOCLCP_NCPGlockerFBPATH_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_SOCLCP_NCPGlockerFBPATH_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_SOCLCP_projectionOnCylinder_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_SOCLCP_projectionOnCylinder_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_SOCLCP_projectionOnCylinder_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_SOCLCP_projectionOnCylinder_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_SOCLCP_ProjectionOnCone_velocity_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_SOCLCP_ProjectionOnCone_velocity_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_SOCLCP_ProjectionOnCone_velocity_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_SOCLCP_ProjectionOnCone_velocity_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_SOCLCP_PGoC_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_SOCLCP_PGoC_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_SOCLCP_PGoC_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_SOCLCP_PGoC_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_SOCLCP_DeSaxceFixedPoint_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_SOCLCP_DeSaxceFixedPoint_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_SOCLCP_DeSaxceFixedPoint_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_SOCLCP_DeSaxceFixedPoint_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_SOCLCP_QUARTIC_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_SOCLCP_QUARTIC_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_SOCLCP_QUARTIC_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_SOCLCP_QUARTIC_STR);
  return pyobj;
}


SWIGINTERN int Swig_var_SICONOS_SOCLCP_QUARTIC_NU_STR_set(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable SICONOS_SOCLCP_QUARTIC_NU_STR is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_SICONOS_SOCLCP_QUARTIC_NU_STR_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_FromCharPtr(SICONOS_SOCLCP_QUARTIC_NU_STR);
  return pyobj;
}


SWIGINTERN PyObject *_wrap_FrictionContactProblem_dimension_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct FrictionContactProblem *arg1 = (struct FrictionContactProblem *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:FrictionContactProblem_dimension_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FrictionContactProblem_dimension_set" "', argument " "1"" of type '" "struct FrictionContactProblem *""'"); 
  }
  arg1 = (struct FrictionContactProblem *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "FrictionContactProblem_dimension_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->dimension = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FrictionContactProblem_dimension_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct FrictionContactProblem *arg1 = (struct FrictionContactProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:FrictionContactProblem_dimension_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FrictionContactProblem_dimension_get" "', argument " "1"" of type '" "struct FrictionContactProblem *""'"); 
  }
  arg1 = (struct FrictionContactProblem *)(argp1);
  result = (int) ((arg1)->dimension);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FrictionContactProblem_numberOfContacts_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct FrictionContactProblem *arg1 = (struct FrictionContactProblem *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:FrictionContactProblem_numberOfContacts_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FrictionContactProblem_numberOfContacts_set" "', argument " "1"" of type '" "struct FrictionContactProblem *""'"); 
  }
  arg1 = (struct FrictionContactProblem *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "FrictionContactProblem_numberOfContacts_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->numberOfContacts = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FrictionContactProblem_numberOfContacts_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct FrictionContactProblem *arg1 = (struct FrictionContactProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:FrictionContactProblem_numberOfContacts_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FrictionContactProblem_numberOfContacts_get" "', argument " "1"" of type '" "struct FrictionContactProblem *""'"); 
  }
  arg1 = (struct FrictionContactProblem *)(argp1);
  result = (int) ((arg1)->numberOfContacts);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FrictionContactProblem_M_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct FrictionContactProblem *arg1 = (struct FrictionContactProblem *) 0 ;
  NumericsMatrix *arg2 = (NumericsMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array_2 = NULL ;
  int array_ctrl_2 = 0 ;
  PyArrayObject *array_i_2 = NULL ;
  int array_i_ctrl_2 = 0 ;
  PyArrayObject *array_p_2 = NULL ;
  int array_p_ctrl_2 = 0 ;
  int alloc_ctrl_2 = 0 ;
  NumericsMatrix *nummat2 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:FrictionContactProblem_M_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FrictionContactProblem_M_set" "', argument " "1"" of type '" "struct FrictionContactProblem *""'"); 
  }
  arg1 = (struct FrictionContactProblem *)(argp1);
  {
    arg2 = NM_convert_from_python(obj1, &nummat2, &array_2, &array_ctrl_2, &array_i_2, &array_i_ctrl_2, &array_p_2, &array_p_ctrl_2, &alloc_ctrl_2);
    
    
    
    
    
    if (!arg2) {
      SWIG_fail; 
    }
  }
  {
    //  %typemap(memberin) (NumericsMatrix*)
    // perform a deep copy
    if (!arg1->M) {
      arg1->M = NM_create(arg2->storageType, arg2->size0, arg2->size1); 
    }
    NM_copy(arg2, arg1->M);
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_FrictionContactProblem_M_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct FrictionContactProblem *arg1 = (struct FrictionContactProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  NumericsMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:FrictionContactProblem_M_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FrictionContactProblem_M_get" "', argument " "1"" of type '" "struct FrictionContactProblem *""'"); 
  }
  arg1 = (struct FrictionContactProblem *)(argp1);
  result = (NumericsMatrix *) ((arg1)->M);
  {
    if (strcmp("FrictionContactProblem_M_get", "new_NumericsMatrix"))
    {
      resultobj = NM_to_python(result);
      
      
      
      if (!resultobj) SWIG_fail;
    }
    else
    {
      resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NumericsMatrix, SWIG_POINTER_NEW |  0 );
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FrictionContactProblem_q_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct FrictionContactProblem *arg1 = (struct FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:FrictionContactProblem_q_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FrictionContactProblem_q_set" "', argument " "1"" of type '" "struct FrictionContactProblem *""'"); 
  }
  arg1 = (struct FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    // Still some dark magic :( --xhub
    char msg[1024];
    assert(arg1);
    if (!arg1->M)
    {
      SWIG_exception_fail(SWIG_RuntimeError, "M is not initialized, it sould be done first!");
    }
    
    int size = arg1->M->size0;
    if (size !=  array_size(array2, 0))
    {
      snprintf(msg, sizeof(msg), "Size of q is %ld, but the size of M is %d! Both should be equal!\n", array_size(array2, 0), size);
      SWIG_exception_fail(SWIG_RuntimeError, msg);
    }
    
    if (!arg1->q) {
      arg1->q = (double*)malloc(size * sizeof(double)); 
    }
    memcpy(arg1->q, arg2, size * sizeof(double));
    
  }
  resultobj = SWIG_Py_Void();
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_FrictionContactProblem_q_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct FrictionContactProblem *arg1 = (struct FrictionContactProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:FrictionContactProblem_q_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FrictionContactProblem_q_get" "', argument " "1"" of type '" "struct FrictionContactProblem *""'"); 
  }
  arg1 = (struct FrictionContactProblem *)(argp1);
  result = (double *) ((arg1)->q);
  {
    if (!arg1->M) {
      SWIG_exception_fail(SWIG_RuntimeError, "M is not present, don't known the size"); 
    }
    
    if (result)
    {
      PyObject *obj;
      C_to_target_lang1(obj, arg1->M->size0, result, SWIG_fail);
      resultobj = obj;
    }
    else
    SWIG_fail;
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FrictionContactProblem_mu_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct FrictionContactProblem *arg1 = (struct FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:FrictionContactProblem_mu_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FrictionContactProblem_mu_set" "', argument " "1"" of type '" "struct FrictionContactProblem *""'"); 
  }
  arg1 = (struct FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    // Still some dark magic :( --xhub
    if (arg1->numberOfContacts <= 0)
    {
      SWIG_exception(SWIG_RuntimeError, "numberOfContacts is not set, it sould be done first!");
      SWIG_fail;
    }
    
    if (arg1->numberOfContacts !=  array_size(array2, 0))
    {
      char msg[1024];
      snprintf(msg, sizeof(msg), "Size of mu is %ld, but the number of contacts is %d! Both should be equal!\n", array_size(array2, 0), arg1->numberOfContacts);
      SWIG_exception_fail(SWIG_ValueError, msg);
    }
    
    if (!arg1->mu) {
      arg1->mu = (double*)malloc(arg1->numberOfContacts * sizeof(double)); 
    }
    memcpy(arg1->mu, arg2, arg1->numberOfContacts * sizeof(double));
    
  }
  resultobj = SWIG_Py_Void();
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_FrictionContactProblem_mu_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct FrictionContactProblem *arg1 = (struct FrictionContactProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:FrictionContactProblem_mu_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FrictionContactProblem_mu_get" "', argument " "1"" of type '" "struct FrictionContactProblem *""'"); 
  }
  arg1 = (struct FrictionContactProblem *)(argp1);
  result = (double *) ((arg1)->mu);
  {
    if (arg1->numberOfContacts <= 0) {
      SWIG_exception_fail(SWIG_RuntimeError, "numberOfContacts is not set"); 
    }
    
    if (result)
    {
      PyObject *obj;
      C_to_target_lang1(obj, arg1->numberOfContacts, result, SWIG_fail);
      resultobj = obj;
    }
    else
    SWIG_fail;
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_FrictionContactProblem__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct FrictionContactProblem *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_FrictionContactProblem")) SWIG_fail;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct FrictionContactProblem *)new_FrictionContactProblem__SWIG_0();
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FrictionContactProblem, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_FrictionContactProblem__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  PyObject * obj0 = 0 ;
  struct FrictionContactProblem *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_FrictionContactProblem",&obj0)) SWIG_fail;
  arg1 = obj0;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct FrictionContactProblem *)new_FrictionContactProblem__SWIG_1(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FrictionContactProblem, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_FrictionContactProblem__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  PyObject *arg4 = (PyObject *) 0 ;
  PyObject *arg5 = (PyObject *) 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  struct FrictionContactProblem *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:new_FrictionContactProblem",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  arg1 = obj0;
  arg2 = obj1;
  arg3 = obj2;
  arg4 = obj3;
  arg5 = obj4;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct FrictionContactProblem *)new_FrictionContactProblem__SWIG_2(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FrictionContactProblem, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_FrictionContactProblem__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  PyObject *arg4 = (PyObject *) 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  struct FrictionContactProblem *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:new_FrictionContactProblem",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  arg1 = obj0;
  arg2 = obj1;
  arg3 = obj2;
  arg4 = obj3;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct FrictionContactProblem *)new_FrictionContactProblem__SWIG_3(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FrictionContactProblem, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_FrictionContactProblem(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[6] = {
    0
  };
  Py_ssize_t ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = args ? PyObject_Length(args) : 0;
  for (ii = 0; (ii < 5) && (ii < argc); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_FrictionContactProblem__SWIG_0(self, args);
  }
  if (argc == 1) {
    int _v;
    _v = (argv[0] != 0);
    if (_v) {
      return _wrap_new_FrictionContactProblem__SWIG_1(self, args);
    }
  }
  if (argc == 4) {
    int _v;
    _v = (argv[0] != 0);
    if (_v) {
      _v = (argv[1] != 0);
      if (_v) {
        _v = (argv[2] != 0);
        if (_v) {
          _v = (argv[3] != 0);
          if (_v) {
            return _wrap_new_FrictionContactProblem__SWIG_3(self, args);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    _v = (argv[0] != 0);
    if (_v) {
      _v = (argv[1] != 0);
      if (_v) {
        _v = (argv[2] != 0);
        if (_v) {
          _v = (argv[3] != 0);
          if (_v) {
            _v = (argv[4] != 0);
            if (_v) {
              return _wrap_new_FrictionContactProblem__SWIG_2(self, args);
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_FrictionContactProblem'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    FrictionContactProblem::FrictionContactProblem()\n"
    "    FrictionContactProblem::FrictionContactProblem(PyObject *)\n"
    "    FrictionContactProblem::FrictionContactProblem(PyObject *,PyObject *,PyObject *,PyObject *,PyObject *)\n"
    "    FrictionContactProblem::FrictionContactProblem(PyObject *,PyObject *,PyObject *,PyObject *)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_FrictionContactProblem(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct FrictionContactProblem *arg1 = (struct FrictionContactProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_FrictionContactProblem",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_FrictionContactProblem" "', argument " "1"" of type '" "struct FrictionContactProblem *""'"); 
  }
  arg1 = (struct FrictionContactProblem *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        delete_FrictionContactProblem(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *FrictionContactProblem_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_FrictionContactProblem, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_SplittedFrictionContactProblem_fc3d_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SplittedFrictionContactProblem *arg1 = (struct SplittedFrictionContactProblem *) 0 ;
  FrictionContactProblem *arg2 = (FrictionContactProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SplittedFrictionContactProblem_fc3d_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SplittedFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SplittedFrictionContactProblem_fc3d_set" "', argument " "1"" of type '" "struct SplittedFrictionContactProblem *""'"); 
  }
  arg1 = (struct SplittedFrictionContactProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_FrictionContactProblem, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SplittedFrictionContactProblem_fc3d_set" "', argument " "2"" of type '" "FrictionContactProblem *""'"); 
  }
  arg2 = (FrictionContactProblem *)(argp2);
  if (arg1) (arg1)->fc3d = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SplittedFrictionContactProblem_fc3d_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SplittedFrictionContactProblem *arg1 = (struct SplittedFrictionContactProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  FrictionContactProblem *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SplittedFrictionContactProblem_fc3d_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SplittedFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SplittedFrictionContactProblem_fc3d_get" "', argument " "1"" of type '" "struct SplittedFrictionContactProblem *""'"); 
  }
  arg1 = (struct SplittedFrictionContactProblem *)(argp1);
  result = (FrictionContactProblem *) ((arg1)->fc3d);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SplittedFrictionContactProblem_M_nn_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SplittedFrictionContactProblem *arg1 = (struct SplittedFrictionContactProblem *) 0 ;
  NumericsMatrix *arg2 = (NumericsMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array_2 = NULL ;
  int array_ctrl_2 = 0 ;
  PyArrayObject *array_i_2 = NULL ;
  int array_i_ctrl_2 = 0 ;
  PyArrayObject *array_p_2 = NULL ;
  int array_p_ctrl_2 = 0 ;
  int alloc_ctrl_2 = 0 ;
  NumericsMatrix *nummat2 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SplittedFrictionContactProblem_M_nn_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SplittedFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SplittedFrictionContactProblem_M_nn_set" "', argument " "1"" of type '" "struct SplittedFrictionContactProblem *""'"); 
  }
  arg1 = (struct SplittedFrictionContactProblem *)(argp1);
  {
    arg2 = NM_convert_from_python(obj1, &nummat2, &array_2, &array_ctrl_2, &array_i_2, &array_i_ctrl_2, &array_p_2, &array_p_ctrl_2, &alloc_ctrl_2);
    
    
    
    
    
    if (!arg2) {
      SWIG_fail; 
    }
  }
  {
    //  %typemap(memberin) (NumericsMatrix*)
    // perform a deep copy
    if (!arg1->M_nn) {
      arg1->M_nn = NM_create(arg2->storageType, arg2->size0, arg2->size1); 
    }
    NM_copy(arg2, arg1->M_nn);
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_SplittedFrictionContactProblem_M_nn_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SplittedFrictionContactProblem *arg1 = (struct SplittedFrictionContactProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  NumericsMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SplittedFrictionContactProblem_M_nn_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SplittedFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SplittedFrictionContactProblem_M_nn_get" "', argument " "1"" of type '" "struct SplittedFrictionContactProblem *""'"); 
  }
  arg1 = (struct SplittedFrictionContactProblem *)(argp1);
  result = (NumericsMatrix *) ((arg1)->M_nn);
  {
    if (strcmp("SplittedFrictionContactProblem_M_nn_get", "new_NumericsMatrix"))
    {
      resultobj = NM_to_python(result);
      
      
      
      if (!resultobj) SWIG_fail;
    }
    else
    {
      resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NumericsMatrix, SWIG_POINTER_NEW |  0 );
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SplittedFrictionContactProblem_M_tn_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SplittedFrictionContactProblem *arg1 = (struct SplittedFrictionContactProblem *) 0 ;
  NumericsMatrix *arg2 = (NumericsMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array_2 = NULL ;
  int array_ctrl_2 = 0 ;
  PyArrayObject *array_i_2 = NULL ;
  int array_i_ctrl_2 = 0 ;
  PyArrayObject *array_p_2 = NULL ;
  int array_p_ctrl_2 = 0 ;
  int alloc_ctrl_2 = 0 ;
  NumericsMatrix *nummat2 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SplittedFrictionContactProblem_M_tn_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SplittedFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SplittedFrictionContactProblem_M_tn_set" "', argument " "1"" of type '" "struct SplittedFrictionContactProblem *""'"); 
  }
  arg1 = (struct SplittedFrictionContactProblem *)(argp1);
  {
    arg2 = NM_convert_from_python(obj1, &nummat2, &array_2, &array_ctrl_2, &array_i_2, &array_i_ctrl_2, &array_p_2, &array_p_ctrl_2, &alloc_ctrl_2);
    
    
    
    
    
    if (!arg2) {
      SWIG_fail; 
    }
  }
  {
    //  %typemap(memberin) (NumericsMatrix*)
    // perform a deep copy
    if (!arg1->M_tn) {
      arg1->M_tn = NM_create(arg2->storageType, arg2->size0, arg2->size1); 
    }
    NM_copy(arg2, arg1->M_tn);
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_SplittedFrictionContactProblem_M_tn_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SplittedFrictionContactProblem *arg1 = (struct SplittedFrictionContactProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  NumericsMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SplittedFrictionContactProblem_M_tn_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SplittedFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SplittedFrictionContactProblem_M_tn_get" "', argument " "1"" of type '" "struct SplittedFrictionContactProblem *""'"); 
  }
  arg1 = (struct SplittedFrictionContactProblem *)(argp1);
  result = (NumericsMatrix *) ((arg1)->M_tn);
  {
    if (strcmp("SplittedFrictionContactProblem_M_tn_get", "new_NumericsMatrix"))
    {
      resultobj = NM_to_python(result);
      
      
      
      if (!resultobj) SWIG_fail;
    }
    else
    {
      resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NumericsMatrix, SWIG_POINTER_NEW |  0 );
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SplittedFrictionContactProblem_M_nt_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SplittedFrictionContactProblem *arg1 = (struct SplittedFrictionContactProblem *) 0 ;
  NumericsMatrix *arg2 = (NumericsMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array_2 = NULL ;
  int array_ctrl_2 = 0 ;
  PyArrayObject *array_i_2 = NULL ;
  int array_i_ctrl_2 = 0 ;
  PyArrayObject *array_p_2 = NULL ;
  int array_p_ctrl_2 = 0 ;
  int alloc_ctrl_2 = 0 ;
  NumericsMatrix *nummat2 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SplittedFrictionContactProblem_M_nt_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SplittedFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SplittedFrictionContactProblem_M_nt_set" "', argument " "1"" of type '" "struct SplittedFrictionContactProblem *""'"); 
  }
  arg1 = (struct SplittedFrictionContactProblem *)(argp1);
  {
    arg2 = NM_convert_from_python(obj1, &nummat2, &array_2, &array_ctrl_2, &array_i_2, &array_i_ctrl_2, &array_p_2, &array_p_ctrl_2, &alloc_ctrl_2);
    
    
    
    
    
    if (!arg2) {
      SWIG_fail; 
    }
  }
  {
    //  %typemap(memberin) (NumericsMatrix*)
    // perform a deep copy
    if (!arg1->M_nt) {
      arg1->M_nt = NM_create(arg2->storageType, arg2->size0, arg2->size1); 
    }
    NM_copy(arg2, arg1->M_nt);
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_SplittedFrictionContactProblem_M_nt_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SplittedFrictionContactProblem *arg1 = (struct SplittedFrictionContactProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  NumericsMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SplittedFrictionContactProblem_M_nt_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SplittedFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SplittedFrictionContactProblem_M_nt_get" "', argument " "1"" of type '" "struct SplittedFrictionContactProblem *""'"); 
  }
  arg1 = (struct SplittedFrictionContactProblem *)(argp1);
  result = (NumericsMatrix *) ((arg1)->M_nt);
  {
    if (strcmp("SplittedFrictionContactProblem_M_nt_get", "new_NumericsMatrix"))
    {
      resultobj = NM_to_python(result);
      
      
      
      if (!resultobj) SWIG_fail;
    }
    else
    {
      resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NumericsMatrix, SWIG_POINTER_NEW |  0 );
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SplittedFrictionContactProblem_M_tt_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SplittedFrictionContactProblem *arg1 = (struct SplittedFrictionContactProblem *) 0 ;
  NumericsMatrix *arg2 = (NumericsMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array_2 = NULL ;
  int array_ctrl_2 = 0 ;
  PyArrayObject *array_i_2 = NULL ;
  int array_i_ctrl_2 = 0 ;
  PyArrayObject *array_p_2 = NULL ;
  int array_p_ctrl_2 = 0 ;
  int alloc_ctrl_2 = 0 ;
  NumericsMatrix *nummat2 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SplittedFrictionContactProblem_M_tt_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SplittedFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SplittedFrictionContactProblem_M_tt_set" "', argument " "1"" of type '" "struct SplittedFrictionContactProblem *""'"); 
  }
  arg1 = (struct SplittedFrictionContactProblem *)(argp1);
  {
    arg2 = NM_convert_from_python(obj1, &nummat2, &array_2, &array_ctrl_2, &array_i_2, &array_i_ctrl_2, &array_p_2, &array_p_ctrl_2, &alloc_ctrl_2);
    
    
    
    
    
    if (!arg2) {
      SWIG_fail; 
    }
  }
  {
    //  %typemap(memberin) (NumericsMatrix*)
    // perform a deep copy
    if (!arg1->M_tt) {
      arg1->M_tt = NM_create(arg2->storageType, arg2->size0, arg2->size1); 
    }
    NM_copy(arg2, arg1->M_tt);
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_SplittedFrictionContactProblem_M_tt_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SplittedFrictionContactProblem *arg1 = (struct SplittedFrictionContactProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  NumericsMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SplittedFrictionContactProblem_M_tt_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SplittedFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SplittedFrictionContactProblem_M_tt_get" "', argument " "1"" of type '" "struct SplittedFrictionContactProblem *""'"); 
  }
  arg1 = (struct SplittedFrictionContactProblem *)(argp1);
  result = (NumericsMatrix *) ((arg1)->M_tt);
  {
    if (strcmp("SplittedFrictionContactProblem_M_tt_get", "new_NumericsMatrix"))
    {
      resultobj = NM_to_python(result);
      
      
      
      if (!resultobj) SWIG_fail;
    }
    else
    {
      resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NumericsMatrix, SWIG_POINTER_NEW |  0 );
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SplittedFrictionContactProblem_q_n_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SplittedFrictionContactProblem *arg1 = (struct SplittedFrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SplittedFrictionContactProblem_q_n_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SplittedFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SplittedFrictionContactProblem_q_n_set" "', argument " "1"" of type '" "struct SplittedFrictionContactProblem *""'"); 
  }
  arg1 = (struct SplittedFrictionContactProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_double, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SplittedFrictionContactProblem_q_n_set" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = (double *)(argp2);
  if (arg1) (arg1)->q_n = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SplittedFrictionContactProblem_q_n_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SplittedFrictionContactProblem *arg1 = (struct SplittedFrictionContactProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SplittedFrictionContactProblem_q_n_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SplittedFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SplittedFrictionContactProblem_q_n_get" "', argument " "1"" of type '" "struct SplittedFrictionContactProblem *""'"); 
  }
  arg1 = (struct SplittedFrictionContactProblem *)(argp1);
  result = (double *) ((arg1)->q_n);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SplittedFrictionContactProblem_q_t_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SplittedFrictionContactProblem *arg1 = (struct SplittedFrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SplittedFrictionContactProblem_q_t_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SplittedFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SplittedFrictionContactProblem_q_t_set" "', argument " "1"" of type '" "struct SplittedFrictionContactProblem *""'"); 
  }
  arg1 = (struct SplittedFrictionContactProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_double, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SplittedFrictionContactProblem_q_t_set" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = (double *)(argp2);
  if (arg1) (arg1)->q_t = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SplittedFrictionContactProblem_q_t_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SplittedFrictionContactProblem *arg1 = (struct SplittedFrictionContactProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SplittedFrictionContactProblem_q_t_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SplittedFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SplittedFrictionContactProblem_q_t_get" "', argument " "1"" of type '" "struct SplittedFrictionContactProblem *""'"); 
  }
  arg1 = (struct SplittedFrictionContactProblem *)(argp1);
  result = (double *) ((arg1)->q_t);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SplittedFrictionContactProblem(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SplittedFrictionContactProblem *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_SplittedFrictionContactProblem")) SWIG_fail;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct SplittedFrictionContactProblem *)calloc(1, sizeof(struct SplittedFrictionContactProblem));
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SplittedFrictionContactProblem, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SplittedFrictionContactProblem(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SplittedFrictionContactProblem *arg1 = (struct SplittedFrictionContactProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_SplittedFrictionContactProblem",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SplittedFrictionContactProblem, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SplittedFrictionContactProblem" "', argument " "1"" of type '" "struct SplittedFrictionContactProblem *""'"); 
  }
  arg1 = (struct SplittedFrictionContactProblem *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        free((char *) arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SplittedFrictionContactProblem_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_SplittedFrictionContactProblem, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_frictionContactProblem_new_with_data(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  int arg2 ;
  NumericsMatrix *arg3 = (NumericsMatrix *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyArrayObject *array_3 = NULL ;
  int array_ctrl_3 = 0 ;
  PyArrayObject *array_i_3 = NULL ;
  int array_i_ctrl_3 = 0 ;
  PyArrayObject *array_p_3 = NULL ;
  int array_p_ctrl_3 = 0 ;
  int alloc_ctrl_3 = 0 ;
  NumericsMatrix *nummat3 = NULL ;
  PyArrayObject *array4 = NULL ;
  int is_new_object4 = 0 ;
  PyArrayObject *array5 = NULL ;
  int is_new_object5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  FrictionContactProblem *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:frictionContactProblem_new_with_data",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "frictionContactProblem_new_with_data" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "frictionContactProblem_new_with_data" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    arg3 = NM_convert_from_python(obj2, &nummat3, &array_3, &array_ctrl_3, &array_i_3, &array_i_ctrl_3, &array_p_3, &array_p_ctrl_3, &alloc_ctrl_3);
    
    
    
    
    
    if (!arg3) {
      SWIG_fail; 
    }
  }
  {
    array4 = obj_to_sn_vector(obj3, &is_new_object4);
    
    if (!array4)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array4))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg4 = (double *) array_data(array4);
    
  }
  {
    array5 = obj_to_sn_vector(obj4, &is_new_object5);
    
    if (!array5)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array5))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg5 = (double *) array_data(array5);
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (FrictionContactProblem *)frictionContactProblem_new_with_data(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_3 && array_3) {
      Py_DECREF(array_3); 
    };
    if(array_i_ctrl_3 && array_i_3) {
      Py_DECREF(array_i_3); 
    };
    if(array_p_ctrl_3 && array_p_3) {
      Py_DECREF(array_p_3); 
    };
    
    if (nummat3)
    {
      if (!NM_clean(nummat3, alloc_ctrl_3)) {
        return NULL; 
      }
      NM_free(nummat3);
      free(nummat3);
    }
    
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  {
    if(is_new_object5 && array5) {
      Py_DECREF(array5); 
    };
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_3 && array_3) {
      Py_DECREF(array_3); 
    };
    if(array_i_ctrl_3 && array_i_3) {
      Py_DECREF(array_i_3); 
    };
    if(array_p_ctrl_3 && array_p_3) {
      Py_DECREF(array_p_3); 
    };
    
    if (nummat3)
    {
      if (!NM_clean(nummat3, alloc_ctrl_3)) {
        return NULL; 
      }
      NM_free(nummat3);
      free(nummat3);
    }
    
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  {
    if(is_new_object5 && array5) {
      Py_DECREF(array5); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_frictionContactProblem_free(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:frictionContactProblem_free",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "frictionContactProblem_free" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        frictionContactProblem_free(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_frictionContact_display(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:frictionContact_display",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "frictionContact_display" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        frictionContact_display(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_frictionContact_printInFile(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  FILE *arg2 = (FILE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:frictionContact_printInFile",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "frictionContact_printInFile" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    // %typemap(in) (FILE *file)
    int alloc = 1;
    char* cstr;
    int res = SWIG_AsCharPtrAndSize(obj1, &cstr, NULL, &alloc);
    if (!SWIG_IsOK(res)) {
      SWIG_Error(SWIG_ArgError(res), "in method unknown', argument " "1"" of type '" "char *""'");
    }
    arg2 = fopen(cstr, "r");
    if (!arg2)
    {
      SWIG_Error(SWIG_IOError, format_msg_concat("in method '" "frictionContact_printInFile" "' cannot fopen file", cstr));
      if (alloc == SWIG_NEWOBJ) free(cstr);
      SWIG_fail;
    }
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)frictionContact_printInFile(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_frictionContact_printInFilename(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:frictionContact_printInFilename",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "frictionContact_printInFilename" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "frictionContact_printInFilename" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)frictionContact_printInFilename(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_frictionContact_newFromFile(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  FILE *arg2 = (FILE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:frictionContact_newFromFile",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "frictionContact_newFromFile" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    // %typemap(in) (FILE *file)
    int alloc = 1;
    char* cstr;
    int res = SWIG_AsCharPtrAndSize(obj1, &cstr, NULL, &alloc);
    if (!SWIG_IsOK(res)) {
      SWIG_Error(SWIG_ArgError(res), "in method unknown', argument " "1"" of type '" "char *""'");
    }
    arg2 = fopen(cstr, "r");
    if (!arg2)
    {
      SWIG_Error(SWIG_IOError, format_msg_concat("in method '" "frictionContact_newFromFile" "' cannot fopen file", cstr));
      if (alloc == SWIG_NEWOBJ) free(cstr);
      SWIG_fail;
    }
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)frictionContact_newFromFile(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_frictionContact_newFromFilename(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:frictionContact_newFromFilename",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "frictionContact_newFromFilename" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "frictionContact_newFromFilename" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)frictionContact_newFromFilename(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_createSplittedFrictionContactProblem(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  SplittedFrictionContactProblem *arg2 = (SplittedFrictionContactProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:createSplittedFrictionContactProblem",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "createSplittedFrictionContactProblem" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SplittedFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "createSplittedFrictionContactProblem" "', argument " "2"" of type '" "SplittedFrictionContactProblem *""'"); 
  }
  arg2 = (SplittedFrictionContactProblem *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        createSplittedFrictionContactProblem(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_frictionContactProblem_compute_statistics(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double arg4 ;
  int arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:frictionContactProblem_compute_statistics",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "frictionContactProblem_compute_statistics" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  ecode4 = SWIG_AsVal_double(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "frictionContactProblem_compute_statistics" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  ecode5 = SWIG_AsVal_int(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "frictionContactProblem_compute_statistics" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        frictionContactProblem_compute_statistics(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_compute_rho_split_spectral_norm_cond(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:compute_rho_split_spectral_norm_cond",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "compute_rho_split_spectral_norm_cond" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "compute_rho_split_spectral_norm_cond" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = (double *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        compute_rho_split_spectral_norm_cond(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_compute_rho_split_spectral_norm(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:compute_rho_split_spectral_norm",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "compute_rho_split_spectral_norm" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "compute_rho_split_spectral_norm" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = (double *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        compute_rho_split_spectral_norm(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_compute_rho_spectral_norm(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:compute_rho_spectral_norm",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "compute_rho_spectral_norm" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "compute_rho_spectral_norm" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = (double *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        compute_rho_spectral_norm(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_computeAlartCurnierSTD(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  double *arg1 ;
  double *arg2 ;
  double arg3 ;
  double *arg4 ;
  double *arg5 ;
  double *arg6 ;
  double *arg7 ;
  PyArrayObject *array1 = NULL ;
  int is_new_object1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  PyArrayObject *array4 = NULL ;
  int is_new_object4 = 0 ;
  PyObject *array5 = NULL ;
  PyObject *array6 = NULL ;
  PyObject *array7 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    npy_intp dims[1] = {
      3 
    };
    array5 = PyArray_SimpleNew(1, dims, NPY_DOUBLE);
    if (!array5) SWIG_fail;
    arg5 = (double *) array_data(array5);
  }
  {
    npy_intp dims[1] = {
      9 
    };
    array6 = PyArray_SimpleNew(1, dims, NPY_DOUBLE);
    if (!array6) SWIG_fail;
    arg6 = (double *) array_data(array6);
  }
  {
    npy_intp dims[1] = {
      9 
    };
    array7 = PyArray_SimpleNew(1, dims, NPY_DOUBLE);
    if (!array7) SWIG_fail;
    arg7 = (double *) array_data(array7);
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:computeAlartCurnierSTD",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  {
    npy_intp size[1] = {
      3 
    };
    array1 = obj_to_array_contiguous_allow_conversion(obj0,
      NPY_DOUBLE,
      &is_new_object1);
    if (!array1 || !require_dimensions(array1, 1) ||
      !require_size(array1, size, 1)) SWIG_fail;
    arg1 = (double *) array_data(array1);
  }
  {
    npy_intp size[1] = {
      3 
    };
    array2 = obj_to_array_contiguous_allow_conversion(obj1,
      NPY_DOUBLE,
      &is_new_object2);
    if (!array2 || !require_dimensions(array2, 1) ||
      !require_size(array2, size, 1)) SWIG_fail;
    arg2 = (double *) array_data(array2);
  }
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "computeAlartCurnierSTD" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    npy_intp size[1] = {
      3 
    };
    array4 = obj_to_array_contiguous_allow_conversion(obj3,
      NPY_DOUBLE,
      &is_new_object4);
    if (!array4 || !require_dimensions(array4, 1) ||
      !require_size(array4, size, 1)) SWIG_fail;
    arg4 = (double *) array_data(array4);
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        computeAlartCurnierSTD(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    resultobj = SWIG_Python_AppendOutput(resultobj,(PyObject*)array5);
  }
  {
    resultobj = SWIG_Python_AppendOutput(resultobj,(PyObject*)array6);
  }
  {
    resultobj = SWIG_Python_AppendOutput(resultobj,(PyObject*)array7);
  }
  {
    if (is_new_object1 && array1)
    {
      Py_DECREF(array1); 
    }
  }
  {
    if (is_new_object2 && array2)
    {
      Py_DECREF(array2); 
    }
  }
  {
    if (is_new_object4 && array4)
    {
      Py_DECREF(array4); 
    }
  }
  return resultobj;
fail:
  {
    if (is_new_object1 && array1)
    {
      Py_DECREF(array1); 
    }
  }
  {
    if (is_new_object2 && array2)
    {
      Py_DECREF(array2); 
    }
  }
  {
    if (is_new_object4 && array4)
    {
      Py_DECREF(array4); 
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_computeAlartCurnierJeanMoreau(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  double *arg1 ;
  double *arg2 ;
  double arg3 ;
  double *arg4 ;
  double *arg5 ;
  double *arg6 ;
  double *arg7 ;
  PyArrayObject *array1 = NULL ;
  int is_new_object1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  PyArrayObject *array4 = NULL ;
  int is_new_object4 = 0 ;
  PyObject *array5 = NULL ;
  PyObject *array6 = NULL ;
  PyObject *array7 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    npy_intp dims[1] = {
      3 
    };
    array5 = PyArray_SimpleNew(1, dims, NPY_DOUBLE);
    if (!array5) SWIG_fail;
    arg5 = (double *) array_data(array5);
  }
  {
    npy_intp dims[1] = {
      9 
    };
    array6 = PyArray_SimpleNew(1, dims, NPY_DOUBLE);
    if (!array6) SWIG_fail;
    arg6 = (double *) array_data(array6);
  }
  {
    npy_intp dims[1] = {
      9 
    };
    array7 = PyArray_SimpleNew(1, dims, NPY_DOUBLE);
    if (!array7) SWIG_fail;
    arg7 = (double *) array_data(array7);
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:computeAlartCurnierJeanMoreau",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  {
    npy_intp size[1] = {
      3 
    };
    array1 = obj_to_array_contiguous_allow_conversion(obj0,
      NPY_DOUBLE,
      &is_new_object1);
    if (!array1 || !require_dimensions(array1, 1) ||
      !require_size(array1, size, 1)) SWIG_fail;
    arg1 = (double *) array_data(array1);
  }
  {
    npy_intp size[1] = {
      3 
    };
    array2 = obj_to_array_contiguous_allow_conversion(obj1,
      NPY_DOUBLE,
      &is_new_object2);
    if (!array2 || !require_dimensions(array2, 1) ||
      !require_size(array2, size, 1)) SWIG_fail;
    arg2 = (double *) array_data(array2);
  }
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "computeAlartCurnierJeanMoreau" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    npy_intp size[1] = {
      3 
    };
    array4 = obj_to_array_contiguous_allow_conversion(obj3,
      NPY_DOUBLE,
      &is_new_object4);
    if (!array4 || !require_dimensions(array4, 1) ||
      !require_size(array4, size, 1)) SWIG_fail;
    arg4 = (double *) array_data(array4);
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        computeAlartCurnierJeanMoreau(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    resultobj = SWIG_Python_AppendOutput(resultobj,(PyObject*)array5);
  }
  {
    resultobj = SWIG_Python_AppendOutput(resultobj,(PyObject*)array6);
  }
  {
    resultobj = SWIG_Python_AppendOutput(resultobj,(PyObject*)array7);
  }
  {
    if (is_new_object1 && array1)
    {
      Py_DECREF(array1); 
    }
  }
  {
    if (is_new_object2 && array2)
    {
      Py_DECREF(array2); 
    }
  }
  {
    if (is_new_object4 && array4)
    {
      Py_DECREF(array4); 
    }
  }
  return resultobj;
fail:
  {
    if (is_new_object1 && array1)
    {
      Py_DECREF(array1); 
    }
  }
  {
    if (is_new_object2 && array2)
    {
      Py_DECREF(array2); 
    }
  }
  {
    if (is_new_object4 && array4)
    {
      Py_DECREF(array4); 
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_AlartCurnierParams_computeACFun3x3_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  AlartCurnierParams *arg1 = (AlartCurnierParams *) 0 ;
  AlartCurnierFun3x3Ptr arg2 = (AlartCurnierFun3x3Ptr) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  {
    // Callback (see SolverOptions.i) needed here
    arg2 = &fc3d_AlartCurnierFunctionGenerated;
  }
  if (!PyArg_ParseTuple(args,(char *)"O:AlartCurnierParams_computeACFun3x3_set",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AlartCurnierParams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AlartCurnierParams_computeACFun3x3_set" "', argument " "1"" of type '" "AlartCurnierParams *""'"); 
  }
  arg1 = (AlartCurnierParams *)(argp1);
  if (arg1) (arg1)->computeACFun3x3 = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AlartCurnierParams_computeACFun3x3_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  AlartCurnierParams *arg1 = (AlartCurnierParams *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  AlartCurnierFun3x3Ptr result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AlartCurnierParams_computeACFun3x3_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AlartCurnierParams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AlartCurnierParams_computeACFun3x3_get" "', argument " "1"" of type '" "AlartCurnierParams *""'"); 
  }
  arg1 = (AlartCurnierParams *)(argp1);
  result = (AlartCurnierFun3x3Ptr) ((arg1)->computeACFun3x3);
  resultobj = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_double_p_double_double_p_double_p_double_p_double_p_double__void);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_AlartCurnierParams(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  AlartCurnierParams *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_AlartCurnierParams")) SWIG_fail;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (AlartCurnierParams *)calloc(1, sizeof(AlartCurnierParams));
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_AlartCurnierParams, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_AlartCurnierParams(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  AlartCurnierParams *arg1 = (AlartCurnierParams *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_AlartCurnierParams",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AlartCurnierParams, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_AlartCurnierParams" "', argument " "1"" of type '" "AlartCurnierParams *""'"); 
  }
  arg1 = (AlartCurnierParams *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        free((char *) arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *AlartCurnierParams_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_AlartCurnierParams, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_nonsmoothEqnAlartCurnierFun(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  void *arg1 = (void *) 0 ;
  unsigned int arg2 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  double *arg7 = (double *) 0 ;
  double *arg8 = (double *) 0 ;
  double *arg9 = (double *) 0 ;
  int res1 ;
  unsigned int *p_problem_size2 ;
  npy_intp number_of_contacts2 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  PyArrayObject *array4 = NULL ;
  int is_new_object4 = 0 ;
  PyArrayObject *array5 = NULL ;
  int is_new_object5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  double temp7 ;
  int res7 = SWIG_TMPOBJ ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  
  {
    // the first array length sets problemSize
    p_problem_size2 = &arg2;
    *p_problem_size2 = 0;
    number_of_contacts2 = 0;  
  }
  arg7 = &temp7;
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:nonsmoothEqnAlartCurnierFun",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0,SWIG_as_voidptrptr(&arg1), 0, 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "nonsmoothEqnAlartCurnierFun" "', argument " "1"" of type '" "void *""'"); 
  }
  {
    array3 = obj_to_sn_vector(obj1, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  {
    array4 = obj_to_sn_vector(obj2, &is_new_object4);
    
    if (!array4)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array4))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg4 = (double *) array_data(array4);
    
  }
  {
    array5 = obj_to_sn_vector(obj3, &is_new_object5);
    
    if (!array5)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array5))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg5 = (double *) array_data(array5);
    
  }
  res6 = SWIG_ConvertPtr(obj4, &argp6,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "nonsmoothEqnAlartCurnierFun" "', argument " "6"" of type '" "double *""'"); 
  }
  arg6 = (double *)(argp6);
  res8 = SWIG_ConvertPtr(obj5, &argp8,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res8)) {
    SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "nonsmoothEqnAlartCurnierFun" "', argument " "8"" of type '" "double *""'"); 
  }
  arg8 = (double *)(argp8);
  res9 = SWIG_ConvertPtr(obj6, &argp9,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res9)) {
    SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "nonsmoothEqnAlartCurnierFun" "', argument " "9"" of type '" "double *""'"); 
  }
  arg9 = (double *)(argp9);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        nonsmoothEqnAlartCurnierFun(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res7)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg7)));
  } else {
    int new_flags = SWIG_IsNewObj(res7) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg7), SWIGTYPE_p_double, new_flags));
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  {
    if(is_new_object5 && array5) {
      Py_DECREF(array5); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  {
    if(is_new_object5 && array5) {
      Py_DECREF(array5); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_nonsmooth_Newton_AlartCurnier(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:fc3d_nonsmooth_Newton_AlartCurnier",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_nonsmooth_Newton_AlartCurnier" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc3d_nonsmooth_Newton_AlartCurnier" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_nonsmooth_Newton_AlartCurnier(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_nonsmooth_Newton_AlartCurnier_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:fc3d_nonsmooth_Newton_AlartCurnier_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_nonsmooth_Newton_AlartCurnier_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc3d_nonsmooth_Newton_AlartCurnier_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_AlartCurnierFunction(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  AlartCurnierFun3x3Ptr arg2 = (AlartCurnierFun3x3Ptr) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  double *arg7 = (double *) 0 ;
  double *arg8 = (double *) 0 ;
  double *arg9 = (double *) 0 ;
  unsigned int *p_problem_size1 ;
  npy_intp number_of_contacts1 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  PyArrayObject *array4 = NULL ;
  int is_new_object4 = 0 ;
  PyArrayObject *array5 = NULL ;
  int is_new_object5 = 0 ;
  PyArrayObject *array6 = NULL ;
  int is_new_object6 = 0 ;
  PyObject *array7 = NULL ;
  PyObject *array8 = NULL ;
  PyObject *array9 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // the first array length sets problemSize
    p_problem_size1 = &arg1;
    *p_problem_size1 = 0;
    number_of_contacts1 = 0;  
  }
  {
    // Callback (see SolverOptions.i) needed here
    arg2 = &fc3d_AlartCurnierFunctionGenerated;
  }
  {
    // %typemap(in, numinputs=0)
    // we cannot get problem_size here as numinputs=0 => before
    // numinputs=1, how can we change this ??
  }
  {
    // %typemap(in, numinputs=0)
    // we cannot get problem_size here as numinputs=0 => before
    // numinputs=1, how can we change this ??
  }
  {
    // %typemap(in, numinputs=0)
    // we cannot get problem_size here as numinputs=0 => before
    // numinputs=1, how can we change this ??
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:fc3d_AlartCurnierFunction",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  {
    array3 = obj_to_sn_vector(obj0, &is_new_object3);
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    
    npy_intp array_len[2] = {
      0,0
    };
    
    if (! *p_problem_size1)
    {
      if (array_numdims(array3) == 1)
      {
        *p_problem_size1 = array_size(array3,0);
      }
      else if (array_numdims(array3) > 1)
      {
        *p_problem_size1 = fmax(array_size(array3,0), array_size(array3,1));
      }
      
      if (*p_problem_size1 % 3 != 0) SWIG_fail;
      
      if (*p_problem_size1 / 3 == 0) SWIG_fail;
      
      
      /* number_of_contacts1 = *p_problem_size1 / 3; */
      
    }
    
    assert (*p_problem_size1);
    
    if (array_numdims(array3) == 1)
    {
      array_len[0] = *p_problem_size1;
    }
    else
    {
      array_len[0] = *p_problem_size1;
      array_len[1] = 1;
    }
    
    if (CHECK_ARRAY_VECTOR(array3) || !CHECK_ARRAY_SIZE(array_len[0], array3, 0) || !(array_numdims(array3) > 1 && CHECK_ARRAY_SIZE(array_len[1], array3, 1))) SWIG_fail;
    
    arg3 = (double *) array_data(array3);
    
  }
  {
    array4 = obj_to_sn_vector(obj1, &is_new_object4);
    if (!array4)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY(array4))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    
    npy_intp array_len[2] = {
      0,0
    };
    
    if (! *p_problem_size1)
    {
      if (array_numdims(array4) == 1)
      {
        *p_problem_size1 = array_size(array4,0);
      }
      else if (array_numdims(array4) > 1)
      {
        *p_problem_size1 = fmax(array_size(array4,0), array_size(array4,1));
      }
      
      if (*p_problem_size1 % 3 != 0) SWIG_fail;
      
      if (*p_problem_size1 / 3 == 0) SWIG_fail;
      
      
      /* number_of_contacts1 = *p_problem_size1 / 3; */
      
    }
    
    assert (*p_problem_size1);
    
    if (array_numdims(array4) == 1)
    {
      array_len[0] = *p_problem_size1;
    }
    else
    {
      array_len[0] = *p_problem_size1;
      array_len[1] = 1;
    }
    
    if (CHECK_ARRAY_VECTOR(array4) || !CHECK_ARRAY_SIZE(array_len[0], array4, 0) || !(array_numdims(array4) > 1 && CHECK_ARRAY_SIZE(array_len[1], array4, 1))) SWIG_fail;
    
    arg4 = (double *) array_data(array4);
    
  }
  {
    array5 = obj_to_sn_vector(obj2, &is_new_object5);
    
    if (!array5)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array5))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg5 = (double *) array_data(array5);
    
  }
  {
    array6 = obj_to_sn_vector(obj3, &is_new_object6);
    if (!array6)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY(array6))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    
    npy_intp array_len[2] = {
      0,0
    };
    
    if (! *p_problem_size1)
    {
      if (array_numdims(array6) == 1)
      {
        *p_problem_size1 = array_size(array6,0);
      }
      else if (array_numdims(array6) > 1)
      {
        *p_problem_size1 = fmax(array_size(array6,0), array_size(array6,1));
      }
      
      if (*p_problem_size1 % 3 != 0) SWIG_fail;
      
      if (*p_problem_size1 / 3 == 0) SWIG_fail;
      
      
      /* number_of_contacts1 = *p_problem_size1 / 3; */
      
    }
    
    assert (*p_problem_size1);
    
    if (array_numdims(array6) == 1)
    {
      array_len[0] = *p_problem_size1;
    }
    else
    {
      array_len[0] = *p_problem_size1;
      array_len[1] = 1;
    }
    
    if (CHECK_ARRAY_VECTOR(array6) || !CHECK_ARRAY_SIZE(array_len[0], array6, 0) || !(array_numdims(array6) > 1 && CHECK_ARRAY_SIZE(array_len[1], array6, 1))) SWIG_fail;
    
    arg6 = (double *) array_data(array6);
    
  }
  {
    if (*p_problem_size1)
    {
      C_to_target_lang2_alloc(arg7, array7, *p_problem_size1, 1, SWIG_fail)
    }
    
  }
  {
    if (*p_problem_size1)
    {
      C_to_target_lang2_alloc(arg8, array8, (*p_problem_size1) * 3, 1, SWIG_fail)
    }
    
  }
  {
    if (*p_problem_size1)
    {
      C_to_target_lang2_alloc(arg9, array9, (*p_problem_size1) * 3, 1, SWIG_fail)
    }
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_AlartCurnierFunction(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    if (*p_problem_size1)
    {
      resultobj = SWIG_Python_AppendOutput(resultobj, (PyObject *)array7);
    }
    
  }
  {
    if (*p_problem_size1)
    {
      resultobj = SWIG_Python_AppendOutput(resultobj, (PyObject *)array8);
    }
    
  }
  {
    if (*p_problem_size1)
    {
      resultobj = SWIG_Python_AppendOutput(resultobj, (PyObject *)array9);
    }
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  {
    if(is_new_object5 && array5) {
      Py_DECREF(array5); 
    };
  }
  {
    if(is_new_object6 && array6) {
      Py_DECREF(array6); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  {
    if(is_new_object5 && array5) {
      Py_DECREF(array5); 
    };
  }
  {
    if(is_new_object6 && array6) {
      Py_DECREF(array6); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_nonsmooth_Newton_FischerBurmeister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:fc3d_nonsmooth_Newton_FischerBurmeister",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_nonsmooth_Newton_FischerBurmeister" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc3d_nonsmooth_Newton_FischerBurmeister" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_nonsmooth_Newton_FischerBurmeister(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_FischerBurmeisterFunction(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  FischerBurmeisterFun3x3Ptr arg2 = (FischerBurmeisterFun3x3Ptr) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  double *arg7 = (double *) 0 ;
  double *arg8 = (double *) 0 ;
  double *arg9 = (double *) 0 ;
  unsigned int *p_problem_size1 ;
  npy_intp number_of_contacts1 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  PyArrayObject *array4 = NULL ;
  int is_new_object4 = 0 ;
  PyArrayObject *array5 = NULL ;
  int is_new_object5 = 0 ;
  PyArrayObject *array6 = NULL ;
  int is_new_object6 = 0 ;
  PyObject *array7 = NULL ;
  PyObject *array8 = NULL ;
  PyObject *array9 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // the first array length sets problemSize
    p_problem_size1 = &arg1;
    *p_problem_size1 = 0;
    number_of_contacts1 = 0;  
  }
  {
    // Callback (see SolverOptions.i) needed here
    arg2 = &fc3d_FischerBurmeisterFunctionGenerated;
  }
  {
    // %typemap(in, numinputs=0)
    // we cannot get problem_size here as numinputs=0 => before
    // numinputs=1, how can we change this ??
  }
  {
    // %typemap(in, numinputs=0)
    // we cannot get problem_size here as numinputs=0 => before
    // numinputs=1, how can we change this ??
  }
  {
    // %typemap(in, numinputs=0)
    // we cannot get problem_size here as numinputs=0 => before
    // numinputs=1, how can we change this ??
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:fc3d_FischerBurmeisterFunction",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  {
    array3 = obj_to_sn_vector(obj0, &is_new_object3);
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    
    npy_intp array_len[2] = {
      0,0
    };
    
    if (! *p_problem_size1)
    {
      if (array_numdims(array3) == 1)
      {
        *p_problem_size1 = array_size(array3,0);
      }
      else if (array_numdims(array3) > 1)
      {
        *p_problem_size1 = fmax(array_size(array3,0), array_size(array3,1));
      }
      
      if (*p_problem_size1 % 3 != 0) SWIG_fail;
      
      if (*p_problem_size1 / 3 == 0) SWIG_fail;
      
      
      /* number_of_contacts1 = *p_problem_size1 / 3; */
      
    }
    
    assert (*p_problem_size1);
    
    if (array_numdims(array3) == 1)
    {
      array_len[0] = *p_problem_size1;
    }
    else
    {
      array_len[0] = *p_problem_size1;
      array_len[1] = 1;
    }
    
    if (CHECK_ARRAY_VECTOR(array3) || !CHECK_ARRAY_SIZE(array_len[0], array3, 0) || !(array_numdims(array3) > 1 && CHECK_ARRAY_SIZE(array_len[1], array3, 1))) SWIG_fail;
    
    arg3 = (double *) array_data(array3);
    
  }
  {
    array4 = obj_to_sn_vector(obj1, &is_new_object4);
    if (!array4)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY(array4))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    
    npy_intp array_len[2] = {
      0,0
    };
    
    if (! *p_problem_size1)
    {
      if (array_numdims(array4) == 1)
      {
        *p_problem_size1 = array_size(array4,0);
      }
      else if (array_numdims(array4) > 1)
      {
        *p_problem_size1 = fmax(array_size(array4,0), array_size(array4,1));
      }
      
      if (*p_problem_size1 % 3 != 0) SWIG_fail;
      
      if (*p_problem_size1 / 3 == 0) SWIG_fail;
      
      
      /* number_of_contacts1 = *p_problem_size1 / 3; */
      
    }
    
    assert (*p_problem_size1);
    
    if (array_numdims(array4) == 1)
    {
      array_len[0] = *p_problem_size1;
    }
    else
    {
      array_len[0] = *p_problem_size1;
      array_len[1] = 1;
    }
    
    if (CHECK_ARRAY_VECTOR(array4) || !CHECK_ARRAY_SIZE(array_len[0], array4, 0) || !(array_numdims(array4) > 1 && CHECK_ARRAY_SIZE(array_len[1], array4, 1))) SWIG_fail;
    
    arg4 = (double *) array_data(array4);
    
  }
  {
    array5 = obj_to_sn_vector(obj2, &is_new_object5);
    
    if (!array5)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array5))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg5 = (double *) array_data(array5);
    
  }
  {
    array6 = obj_to_sn_vector(obj3, &is_new_object6);
    if (!array6)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY(array6))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    
    npy_intp array_len[2] = {
      0,0
    };
    
    if (! *p_problem_size1)
    {
      if (array_numdims(array6) == 1)
      {
        *p_problem_size1 = array_size(array6,0);
      }
      else if (array_numdims(array6) > 1)
      {
        *p_problem_size1 = fmax(array_size(array6,0), array_size(array6,1));
      }
      
      if (*p_problem_size1 % 3 != 0) SWIG_fail;
      
      if (*p_problem_size1 / 3 == 0) SWIG_fail;
      
      
      /* number_of_contacts1 = *p_problem_size1 / 3; */
      
    }
    
    assert (*p_problem_size1);
    
    if (array_numdims(array6) == 1)
    {
      array_len[0] = *p_problem_size1;
    }
    else
    {
      array_len[0] = *p_problem_size1;
      array_len[1] = 1;
    }
    
    if (CHECK_ARRAY_VECTOR(array6) || !CHECK_ARRAY_SIZE(array_len[0], array6, 0) || !(array_numdims(array6) > 1 && CHECK_ARRAY_SIZE(array_len[1], array6, 1))) SWIG_fail;
    
    arg6 = (double *) array_data(array6);
    
  }
  {
    if (*p_problem_size1)
    {
      C_to_target_lang2_alloc(arg7, array7, *p_problem_size1, 1, SWIG_fail)
    }
    
  }
  {
    if (*p_problem_size1)
    {
      C_to_target_lang2_alloc(arg8, array8, (*p_problem_size1) * 3, 1, SWIG_fail)
    }
    
  }
  {
    if (*p_problem_size1)
    {
      C_to_target_lang2_alloc(arg9, array9, (*p_problem_size1) * 3, 1, SWIG_fail)
    }
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_FischerBurmeisterFunction(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    if (*p_problem_size1)
    {
      resultobj = SWIG_Python_AppendOutput(resultobj, (PyObject *)array7);
    }
    
  }
  {
    if (*p_problem_size1)
    {
      resultobj = SWIG_Python_AppendOutput(resultobj, (PyObject *)array8);
    }
    
  }
  {
    if (*p_problem_size1)
    {
      resultobj = SWIG_Python_AppendOutput(resultobj, (PyObject *)array9);
    }
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  {
    if(is_new_object5 && array5) {
      Py_DECREF(array5); 
    };
  }
  {
    if(is_new_object6 && array6) {
      Py_DECREF(array6); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  {
    if(is_new_object5 && array5) {
      Py_DECREF(array5); 
    };
  }
  {
    if(is_new_object6 && array6) {
      Py_DECREF(array6); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_nonsmooth_Newton_FischerBurmeister_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:fc3d_nonsmooth_Newton_FischerBurmeister_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_nonsmooth_Newton_FischerBurmeister_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc3d_nonsmooth_Newton_FischerBurmeister_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_nonsmooth_Newton_FischerBurmeister_compute_error(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double arg4 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  double *arg6 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  double temp6 ;
  int res6 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  int result;
  
  arg6 = &temp6;
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:fc3d_nonsmooth_Newton_FischerBurmeister_compute_error",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_nonsmooth_Newton_FischerBurmeister_compute_error" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  ecode4 = SWIG_AsVal_double(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "fc3d_nonsmooth_Newton_FischerBurmeister_compute_error" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  res5 = SWIG_ConvertPtr(obj4, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc3d_nonsmooth_Newton_FischerBurmeister_compute_error" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc3d_nonsmooth_Newton_FischerBurmeister_compute_error(arg1,arg2,arg3,arg4,arg5,arg6);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_double, new_flags));
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_nonsmooth_Newton_NaturalMap(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:fc3d_nonsmooth_Newton_NaturalMap",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_nonsmooth_Newton_NaturalMap" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc3d_nonsmooth_Newton_NaturalMap" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_nonsmooth_Newton_NaturalMap(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_NaturalMapFunction(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  NaturalMapFun3x3Ptr arg2 = (NaturalMapFun3x3Ptr) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  double *arg7 = (double *) 0 ;
  double *arg8 = (double *) 0 ;
  double *arg9 = (double *) 0 ;
  unsigned int *p_problem_size1 ;
  npy_intp number_of_contacts1 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  PyArrayObject *array4 = NULL ;
  int is_new_object4 = 0 ;
  PyArrayObject *array5 = NULL ;
  int is_new_object5 = 0 ;
  PyArrayObject *array6 = NULL ;
  int is_new_object6 = 0 ;
  PyObject *array7 = NULL ;
  PyObject *array8 = NULL ;
  PyObject *array9 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // the first array length sets problemSize
    p_problem_size1 = &arg1;
    *p_problem_size1 = 0;
    number_of_contacts1 = 0;  
  }
  {
    // Callback (see SolverOptions.i) needed here
    arg2 = &fc3d_NaturalMapFunctionGenerated;
  }
  {
    // %typemap(in, numinputs=0)
    // we cannot get problem_size here as numinputs=0 => before
    // numinputs=1, how can we change this ??
  }
  {
    // %typemap(in, numinputs=0)
    // we cannot get problem_size here as numinputs=0 => before
    // numinputs=1, how can we change this ??
  }
  {
    // %typemap(in, numinputs=0)
    // we cannot get problem_size here as numinputs=0 => before
    // numinputs=1, how can we change this ??
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:fc3d_NaturalMapFunction",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  {
    array3 = obj_to_sn_vector(obj0, &is_new_object3);
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    
    npy_intp array_len[2] = {
      0,0
    };
    
    if (! *p_problem_size1)
    {
      if (array_numdims(array3) == 1)
      {
        *p_problem_size1 = array_size(array3,0);
      }
      else if (array_numdims(array3) > 1)
      {
        *p_problem_size1 = fmax(array_size(array3,0), array_size(array3,1));
      }
      
      if (*p_problem_size1 % 3 != 0) SWIG_fail;
      
      if (*p_problem_size1 / 3 == 0) SWIG_fail;
      
      
      /* number_of_contacts1 = *p_problem_size1 / 3; */
      
    }
    
    assert (*p_problem_size1);
    
    if (array_numdims(array3) == 1)
    {
      array_len[0] = *p_problem_size1;
    }
    else
    {
      array_len[0] = *p_problem_size1;
      array_len[1] = 1;
    }
    
    if (CHECK_ARRAY_VECTOR(array3) || !CHECK_ARRAY_SIZE(array_len[0], array3, 0) || !(array_numdims(array3) > 1 && CHECK_ARRAY_SIZE(array_len[1], array3, 1))) SWIG_fail;
    
    arg3 = (double *) array_data(array3);
    
  }
  {
    array4 = obj_to_sn_vector(obj1, &is_new_object4);
    if (!array4)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY(array4))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    
    npy_intp array_len[2] = {
      0,0
    };
    
    if (! *p_problem_size1)
    {
      if (array_numdims(array4) == 1)
      {
        *p_problem_size1 = array_size(array4,0);
      }
      else if (array_numdims(array4) > 1)
      {
        *p_problem_size1 = fmax(array_size(array4,0), array_size(array4,1));
      }
      
      if (*p_problem_size1 % 3 != 0) SWIG_fail;
      
      if (*p_problem_size1 / 3 == 0) SWIG_fail;
      
      
      /* number_of_contacts1 = *p_problem_size1 / 3; */
      
    }
    
    assert (*p_problem_size1);
    
    if (array_numdims(array4) == 1)
    {
      array_len[0] = *p_problem_size1;
    }
    else
    {
      array_len[0] = *p_problem_size1;
      array_len[1] = 1;
    }
    
    if (CHECK_ARRAY_VECTOR(array4) || !CHECK_ARRAY_SIZE(array_len[0], array4, 0) || !(array_numdims(array4) > 1 && CHECK_ARRAY_SIZE(array_len[1], array4, 1))) SWIG_fail;
    
    arg4 = (double *) array_data(array4);
    
  }
  {
    array5 = obj_to_sn_vector(obj2, &is_new_object5);
    
    if (!array5)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array5))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg5 = (double *) array_data(array5);
    
  }
  {
    array6 = obj_to_sn_vector(obj3, &is_new_object6);
    if (!array6)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY(array6))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    
    npy_intp array_len[2] = {
      0,0
    };
    
    if (! *p_problem_size1)
    {
      if (array_numdims(array6) == 1)
      {
        *p_problem_size1 = array_size(array6,0);
      }
      else if (array_numdims(array6) > 1)
      {
        *p_problem_size1 = fmax(array_size(array6,0), array_size(array6,1));
      }
      
      if (*p_problem_size1 % 3 != 0) SWIG_fail;
      
      if (*p_problem_size1 / 3 == 0) SWIG_fail;
      
      
      /* number_of_contacts1 = *p_problem_size1 / 3; */
      
    }
    
    assert (*p_problem_size1);
    
    if (array_numdims(array6) == 1)
    {
      array_len[0] = *p_problem_size1;
    }
    else
    {
      array_len[0] = *p_problem_size1;
      array_len[1] = 1;
    }
    
    if (CHECK_ARRAY_VECTOR(array6) || !CHECK_ARRAY_SIZE(array_len[0], array6, 0) || !(array_numdims(array6) > 1 && CHECK_ARRAY_SIZE(array_len[1], array6, 1))) SWIG_fail;
    
    arg6 = (double *) array_data(array6);
    
  }
  {
    if (*p_problem_size1)
    {
      C_to_target_lang2_alloc(arg7, array7, *p_problem_size1, 1, SWIG_fail)
    }
    
  }
  {
    if (*p_problem_size1)
    {
      C_to_target_lang2_alloc(arg8, array8, (*p_problem_size1) * 3, 1, SWIG_fail)
    }
    
  }
  {
    if (*p_problem_size1)
    {
      C_to_target_lang2_alloc(arg9, array9, (*p_problem_size1) * 3, 1, SWIG_fail)
    }
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_NaturalMapFunction(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    if (*p_problem_size1)
    {
      resultobj = SWIG_Python_AppendOutput(resultobj, (PyObject *)array7);
    }
    
  }
  {
    if (*p_problem_size1)
    {
      resultobj = SWIG_Python_AppendOutput(resultobj, (PyObject *)array8);
    }
    
  }
  {
    if (*p_problem_size1)
    {
      resultobj = SWIG_Python_AppendOutput(resultobj, (PyObject *)array9);
    }
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  {
    if(is_new_object5 && array5) {
      Py_DECREF(array5); 
    };
  }
  {
    if(is_new_object6 && array6) {
      Py_DECREF(array6); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  {
    if(is_new_object5 && array5) {
      Py_DECREF(array5); 
    };
  }
  {
    if(is_new_object6 && array6) {
      Py_DECREF(array6); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_nonsmooth_Newton_NaturalMap_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:fc3d_nonsmooth_Newton_NaturalMap_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_nonsmooth_Newton_NaturalMap_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc3d_nonsmooth_Newton_NaturalMap_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_nonsmooth_Newton_NaturalMap_compute_error(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double arg4 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  double *arg6 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  double temp6 ;
  int res6 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  int result;
  
  arg6 = &temp6;
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:fc3d_nonsmooth_Newton_NaturalMap_compute_error",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_nonsmooth_Newton_NaturalMap_compute_error" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  ecode4 = SWIG_AsVal_double(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "fc3d_nonsmooth_Newton_NaturalMap_compute_error" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  res5 = SWIG_ConvertPtr(obj4, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc3d_nonsmooth_Newton_NaturalMap_compute_error" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc3d_nonsmooth_Newton_NaturalMap_compute_error(arg1,arg2,arg3,arg4,arg5,arg6);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_double, new_flags));
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_AlartCurnierFunctionGenerated(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  double *arg1 = (double *) 0 ;
  double *arg2 = (double *) 0 ;
  double arg3 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  double *arg7 = (double *) 0 ;
  PyArrayObject *array1 = NULL ;
  int is_new_object1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:fc3d_AlartCurnierFunctionGenerated",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
  {
    array1 = obj_to_sn_vector(obj0, &is_new_object1);
    
    if (!array1)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array1))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg1 = (double *) array_data(array1);
    
  }
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "fc3d_AlartCurnierFunctionGenerated" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "fc3d_AlartCurnierFunctionGenerated" "', argument " "4"" of type '" "double *""'"); 
  }
  arg4 = (double *)(argp4);
  res5 = SWIG_ConvertPtr(obj4, &argp5,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc3d_AlartCurnierFunctionGenerated" "', argument " "5"" of type '" "double *""'"); 
  }
  arg5 = (double *)(argp5);
  res6 = SWIG_ConvertPtr(obj5, &argp6,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "fc3d_AlartCurnierFunctionGenerated" "', argument " "6"" of type '" "double *""'"); 
  }
  arg6 = (double *)(argp6);
  res7 = SWIG_ConvertPtr(obj6, &argp7,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res7)) {
    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "fc3d_AlartCurnierFunctionGenerated" "', argument " "7"" of type '" "double *""'"); 
  }
  arg7 = (double *)(argp7);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_AlartCurnierFunctionGenerated(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    if(is_new_object1 && array1) {
      Py_DECREF(array1); 
    };
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object1 && array1) {
      Py_DECREF(array1); 
    };
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_AlartCurnierJeanMoreauFunctionGenerated(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  double *arg1 = (double *) 0 ;
  double *arg2 = (double *) 0 ;
  double arg3 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  double *arg7 = (double *) 0 ;
  PyArrayObject *array1 = NULL ;
  int is_new_object1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:fc3d_AlartCurnierJeanMoreauFunctionGenerated",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
  {
    array1 = obj_to_sn_vector(obj0, &is_new_object1);
    
    if (!array1)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array1))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg1 = (double *) array_data(array1);
    
  }
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "fc3d_AlartCurnierJeanMoreauFunctionGenerated" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "fc3d_AlartCurnierJeanMoreauFunctionGenerated" "', argument " "4"" of type '" "double *""'"); 
  }
  arg4 = (double *)(argp4);
  res5 = SWIG_ConvertPtr(obj4, &argp5,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc3d_AlartCurnierJeanMoreauFunctionGenerated" "', argument " "5"" of type '" "double *""'"); 
  }
  arg5 = (double *)(argp5);
  res6 = SWIG_ConvertPtr(obj5, &argp6,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "fc3d_AlartCurnierJeanMoreauFunctionGenerated" "', argument " "6"" of type '" "double *""'"); 
  }
  arg6 = (double *)(argp6);
  res7 = SWIG_ConvertPtr(obj6, &argp7,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res7)) {
    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "fc3d_AlartCurnierJeanMoreauFunctionGenerated" "', argument " "7"" of type '" "double *""'"); 
  }
  arg7 = (double *)(argp7);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_AlartCurnierJeanMoreauFunctionGenerated(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    if(is_new_object1 && array1) {
      Py_DECREF(array1); 
    };
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object1 && array1) {
      Py_DECREF(array1); 
    };
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_FischerBurmeisterFABGenerated(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  double arg1 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  double arg6 ;
  double arg7 ;
  double arg8 ;
  double arg9 ;
  double arg10 ;
  double *arg11 = (double *) 0 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  double val7 ;
  int ecode7 = 0 ;
  double val8 ;
  int ecode8 = 0 ;
  double val9 ;
  int ecode9 = 0 ;
  double val10 ;
  int ecode10 = 0 ;
  double temp11 ;
  int res11 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  
  arg11 = &temp11;
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOOOO:fc3d_FischerBurmeisterFABGenerated",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9)) SWIG_fail;
  ecode1 = SWIG_AsVal_double(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "fc3d_FischerBurmeisterFABGenerated" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = (double)(val1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "fc3d_FischerBurmeisterFABGenerated" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "fc3d_FischerBurmeisterFABGenerated" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  ecode4 = SWIG_AsVal_double(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "fc3d_FischerBurmeisterFABGenerated" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  ecode5 = SWIG_AsVal_double(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "fc3d_FischerBurmeisterFABGenerated" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = (double)(val5);
  ecode6 = SWIG_AsVal_double(obj5, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "fc3d_FischerBurmeisterFABGenerated" "', argument " "6"" of type '" "double""'");
  } 
  arg6 = (double)(val6);
  ecode7 = SWIG_AsVal_double(obj6, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "fc3d_FischerBurmeisterFABGenerated" "', argument " "7"" of type '" "double""'");
  } 
  arg7 = (double)(val7);
  ecode8 = SWIG_AsVal_double(obj7, &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "fc3d_FischerBurmeisterFABGenerated" "', argument " "8"" of type '" "double""'");
  } 
  arg8 = (double)(val8);
  ecode9 = SWIG_AsVal_double(obj8, &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "fc3d_FischerBurmeisterFABGenerated" "', argument " "9"" of type '" "double""'");
  } 
  arg9 = (double)(val9);
  ecode10 = SWIG_AsVal_double(obj9, &val10);
  if (!SWIG_IsOK(ecode10)) {
    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "fc3d_FischerBurmeisterFABGenerated" "', argument " "10"" of type '" "double""'");
  } 
  arg10 = (double)(val10);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_FischerBurmeisterFABGenerated(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res11)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg11)));
  } else {
    int new_flags = SWIG_IsNewObj(res11) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg11), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_FischerBurmeisterFGenerated(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  double arg1 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  double arg6 ;
  double arg7 ;
  double arg8 ;
  double arg9 ;
  double arg10 ;
  double *arg11 = (double *) 0 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  double val7 ;
  int ecode7 = 0 ;
  double val8 ;
  int ecode8 = 0 ;
  double val9 ;
  int ecode9 = 0 ;
  double val10 ;
  int ecode10 = 0 ;
  double temp11 ;
  int res11 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  
  arg11 = &temp11;
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOOOO:fc3d_FischerBurmeisterFGenerated",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9)) SWIG_fail;
  ecode1 = SWIG_AsVal_double(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "fc3d_FischerBurmeisterFGenerated" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = (double)(val1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "fc3d_FischerBurmeisterFGenerated" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "fc3d_FischerBurmeisterFGenerated" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  ecode4 = SWIG_AsVal_double(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "fc3d_FischerBurmeisterFGenerated" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  ecode5 = SWIG_AsVal_double(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "fc3d_FischerBurmeisterFGenerated" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = (double)(val5);
  ecode6 = SWIG_AsVal_double(obj5, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "fc3d_FischerBurmeisterFGenerated" "', argument " "6"" of type '" "double""'");
  } 
  arg6 = (double)(val6);
  ecode7 = SWIG_AsVal_double(obj6, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "fc3d_FischerBurmeisterFGenerated" "', argument " "7"" of type '" "double""'");
  } 
  arg7 = (double)(val7);
  ecode8 = SWIG_AsVal_double(obj7, &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "fc3d_FischerBurmeisterFGenerated" "', argument " "8"" of type '" "double""'");
  } 
  arg8 = (double)(val8);
  ecode9 = SWIG_AsVal_double(obj8, &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "fc3d_FischerBurmeisterFGenerated" "', argument " "9"" of type '" "double""'");
  } 
  arg9 = (double)(val9);
  ecode10 = SWIG_AsVal_double(obj9, &val10);
  if (!SWIG_IsOK(ecode10)) {
    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "fc3d_FischerBurmeisterFGenerated" "', argument " "10"" of type '" "double""'");
  } 
  arg10 = (double)(val10);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_FischerBurmeisterFGenerated(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res11)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg11)));
  } else {
    int new_flags = SWIG_IsNewObj(res11) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg11), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_FischerBurmeisterABGenerated(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  double arg1 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  double arg6 ;
  double arg7 ;
  double arg8 ;
  double arg9 ;
  double arg10 ;
  double *arg11 = (double *) 0 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  double val7 ;
  int ecode7 = 0 ;
  double val8 ;
  int ecode8 = 0 ;
  double val9 ;
  int ecode9 = 0 ;
  double val10 ;
  int ecode10 = 0 ;
  double temp11 ;
  int res11 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  
  arg11 = &temp11;
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOOOO:fc3d_FischerBurmeisterABGenerated",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9)) SWIG_fail;
  ecode1 = SWIG_AsVal_double(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "fc3d_FischerBurmeisterABGenerated" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = (double)(val1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "fc3d_FischerBurmeisterABGenerated" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "fc3d_FischerBurmeisterABGenerated" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  ecode4 = SWIG_AsVal_double(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "fc3d_FischerBurmeisterABGenerated" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  ecode5 = SWIG_AsVal_double(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "fc3d_FischerBurmeisterABGenerated" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = (double)(val5);
  ecode6 = SWIG_AsVal_double(obj5, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "fc3d_FischerBurmeisterABGenerated" "', argument " "6"" of type '" "double""'");
  } 
  arg6 = (double)(val6);
  ecode7 = SWIG_AsVal_double(obj6, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "fc3d_FischerBurmeisterABGenerated" "', argument " "7"" of type '" "double""'");
  } 
  arg7 = (double)(val7);
  ecode8 = SWIG_AsVal_double(obj7, &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "fc3d_FischerBurmeisterABGenerated" "', argument " "8"" of type '" "double""'");
  } 
  arg8 = (double)(val8);
  ecode9 = SWIG_AsVal_double(obj8, &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "fc3d_FischerBurmeisterABGenerated" "', argument " "9"" of type '" "double""'");
  } 
  arg9 = (double)(val9);
  ecode10 = SWIG_AsVal_double(obj9, &val10);
  if (!SWIG_IsOK(ecode10)) {
    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "fc3d_FischerBurmeisterABGenerated" "', argument " "10"" of type '" "double""'");
  } 
  arg10 = (double)(val10);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_FischerBurmeisterABGenerated(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res11)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg11)));
  } else {
    int new_flags = SWIG_IsNewObj(res11) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg11), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_FischerBurmeisterFunctionGenerated(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  double *arg1 = (double *) 0 ;
  double *arg2 = (double *) 0 ;
  double arg3 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  double *arg7 = (double *) 0 ;
  PyArrayObject *array1 = NULL ;
  int is_new_object1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:fc3d_FischerBurmeisterFunctionGenerated",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
  {
    array1 = obj_to_sn_vector(obj0, &is_new_object1);
    
    if (!array1)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array1))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg1 = (double *) array_data(array1);
    
  }
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "fc3d_FischerBurmeisterFunctionGenerated" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "fc3d_FischerBurmeisterFunctionGenerated" "', argument " "4"" of type '" "double *""'"); 
  }
  arg4 = (double *)(argp4);
  res5 = SWIG_ConvertPtr(obj4, &argp5,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc3d_FischerBurmeisterFunctionGenerated" "', argument " "5"" of type '" "double *""'"); 
  }
  arg5 = (double *)(argp5);
  res6 = SWIG_ConvertPtr(obj5, &argp6,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "fc3d_FischerBurmeisterFunctionGenerated" "', argument " "6"" of type '" "double *""'"); 
  }
  arg6 = (double *)(argp6);
  res7 = SWIG_ConvertPtr(obj6, &argp7,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res7)) {
    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "fc3d_FischerBurmeisterFunctionGenerated" "', argument " "7"" of type '" "double *""'"); 
  }
  arg7 = (double *)(argp7);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_FischerBurmeisterFunctionGenerated(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    if(is_new_object1 && array1) {
      Py_DECREF(array1); 
    };
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object1 && array1) {
      Py_DECREF(array1); 
    };
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_FischerBurmeisterFMeritGenerated(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  double arg1 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  double arg6 ;
  double arg7 ;
  double arg8 ;
  double arg9 ;
  double arg10 ;
  double *arg11 = (double *) 0 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  double val7 ;
  int ecode7 = 0 ;
  double val8 ;
  int ecode8 = 0 ;
  double val9 ;
  int ecode9 = 0 ;
  double val10 ;
  int ecode10 = 0 ;
  double temp11 ;
  int res11 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  
  arg11 = &temp11;
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOOOO:fc3d_FischerBurmeisterFMeritGenerated",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9)) SWIG_fail;
  ecode1 = SWIG_AsVal_double(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "fc3d_FischerBurmeisterFMeritGenerated" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = (double)(val1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "fc3d_FischerBurmeisterFMeritGenerated" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "fc3d_FischerBurmeisterFMeritGenerated" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  ecode4 = SWIG_AsVal_double(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "fc3d_FischerBurmeisterFMeritGenerated" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  ecode5 = SWIG_AsVal_double(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "fc3d_FischerBurmeisterFMeritGenerated" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = (double)(val5);
  ecode6 = SWIG_AsVal_double(obj5, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "fc3d_FischerBurmeisterFMeritGenerated" "', argument " "6"" of type '" "double""'");
  } 
  arg6 = (double)(val6);
  ecode7 = SWIG_AsVal_double(obj6, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "fc3d_FischerBurmeisterFMeritGenerated" "', argument " "7"" of type '" "double""'");
  } 
  arg7 = (double)(val7);
  ecode8 = SWIG_AsVal_double(obj7, &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "fc3d_FischerBurmeisterFMeritGenerated" "', argument " "8"" of type '" "double""'");
  } 
  arg8 = (double)(val8);
  ecode9 = SWIG_AsVal_double(obj8, &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "fc3d_FischerBurmeisterFMeritGenerated" "', argument " "9"" of type '" "double""'");
  } 
  arg9 = (double)(val9);
  ecode10 = SWIG_AsVal_double(obj9, &val10);
  if (!SWIG_IsOK(ecode10)) {
    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "fc3d_FischerBurmeisterFMeritGenerated" "', argument " "10"" of type '" "double""'");
  } 
  arg10 = (double)(val10);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_FischerBurmeisterFMeritGenerated(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res11)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg11)));
  } else {
    int new_flags = SWIG_IsNewObj(res11) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg11), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_FischerBurmeisterGradFMeritGenerated(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  double arg1 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  double arg6 ;
  double arg7 ;
  double arg8 ;
  double arg9 ;
  double arg10 ;
  double *arg11 = (double *) 0 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  double val7 ;
  int ecode7 = 0 ;
  double val8 ;
  int ecode8 = 0 ;
  double val9 ;
  int ecode9 = 0 ;
  double val10 ;
  int ecode10 = 0 ;
  double temp11 ;
  int res11 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  
  arg11 = &temp11;
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOOOO:fc3d_FischerBurmeisterGradFMeritGenerated",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9)) SWIG_fail;
  ecode1 = SWIG_AsVal_double(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "fc3d_FischerBurmeisterGradFMeritGenerated" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = (double)(val1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "fc3d_FischerBurmeisterGradFMeritGenerated" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "fc3d_FischerBurmeisterGradFMeritGenerated" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  ecode4 = SWIG_AsVal_double(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "fc3d_FischerBurmeisterGradFMeritGenerated" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  ecode5 = SWIG_AsVal_double(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "fc3d_FischerBurmeisterGradFMeritGenerated" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = (double)(val5);
  ecode6 = SWIG_AsVal_double(obj5, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "fc3d_FischerBurmeisterGradFMeritGenerated" "', argument " "6"" of type '" "double""'");
  } 
  arg6 = (double)(val6);
  ecode7 = SWIG_AsVal_double(obj6, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "fc3d_FischerBurmeisterGradFMeritGenerated" "', argument " "7"" of type '" "double""'");
  } 
  arg7 = (double)(val7);
  ecode8 = SWIG_AsVal_double(obj7, &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "fc3d_FischerBurmeisterGradFMeritGenerated" "', argument " "8"" of type '" "double""'");
  } 
  arg8 = (double)(val8);
  ecode9 = SWIG_AsVal_double(obj8, &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "fc3d_FischerBurmeisterGradFMeritGenerated" "', argument " "9"" of type '" "double""'");
  } 
  arg9 = (double)(val9);
  ecode10 = SWIG_AsVal_double(obj9, &val10);
  if (!SWIG_IsOK(ecode10)) {
    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "fc3d_FischerBurmeisterGradFMeritGenerated" "', argument " "10"" of type '" "double""'");
  } 
  arg10 = (double)(val10);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_FischerBurmeisterGradFMeritGenerated(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res11)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg11)));
  } else {
    int new_flags = SWIG_IsNewObj(res11) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg11), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_FischerBurmeisterGradMeritFunctionGenerated(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  double *arg1 = (double *) 0 ;
  double *arg2 = (double *) 0 ;
  double arg3 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  PyArrayObject *array1 = NULL ;
  int is_new_object1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:fc3d_FischerBurmeisterGradMeritFunctionGenerated",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  {
    array1 = obj_to_sn_vector(obj0, &is_new_object1);
    
    if (!array1)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array1))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg1 = (double *) array_data(array1);
    
  }
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "fc3d_FischerBurmeisterGradMeritFunctionGenerated" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "fc3d_FischerBurmeisterGradMeritFunctionGenerated" "', argument " "4"" of type '" "double *""'"); 
  }
  arg4 = (double *)(argp4);
  res5 = SWIG_ConvertPtr(obj4, &argp5,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc3d_FischerBurmeisterGradMeritFunctionGenerated" "', argument " "5"" of type '" "double *""'"); 
  }
  arg5 = (double *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_FischerBurmeisterGradMeritFunctionGenerated(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    if(is_new_object1 && array1) {
      Py_DECREF(array1); 
    };
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object1 && array1) {
      Py_DECREF(array1); 
    };
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_NaturalMapFunctionGenerated(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  double *arg1 = (double *) 0 ;
  double *arg2 = (double *) 0 ;
  double arg3 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  double *arg7 = (double *) 0 ;
  PyArrayObject *array1 = NULL ;
  int is_new_object1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:fc3d_NaturalMapFunctionGenerated",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
  {
    array1 = obj_to_sn_vector(obj0, &is_new_object1);
    
    if (!array1)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array1))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg1 = (double *) array_data(array1);
    
  }
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "fc3d_NaturalMapFunctionGenerated" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "fc3d_NaturalMapFunctionGenerated" "', argument " "4"" of type '" "double *""'"); 
  }
  arg4 = (double *)(argp4);
  res5 = SWIG_ConvertPtr(obj4, &argp5,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc3d_NaturalMapFunctionGenerated" "', argument " "5"" of type '" "double *""'"); 
  }
  arg5 = (double *)(argp5);
  res6 = SWIG_ConvertPtr(obj5, &argp6,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "fc3d_NaturalMapFunctionGenerated" "', argument " "6"" of type '" "double *""'"); 
  }
  arg6 = (double *)(argp6);
  res7 = SWIG_ConvertPtr(obj6, &argp7,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res7)) {
    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "fc3d_NaturalMapFunctionGenerated" "', argument " "7"" of type '" "double *""'"); 
  }
  arg7 = (double *)(argp7);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_NaturalMapFunctionGenerated(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    if(is_new_object1 && array1) {
      Py_DECREF(array1); 
    };
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object1 && array1) {
      Py_DECREF(array1); 
    };
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:fc3d_setDefaultSolverOptions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "fc3d_setDefaultSolverOptions" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc3d_setDefaultSolverOptions(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_nsgs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:fc3d_nsgs",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_nsgs" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc3d_nsgs" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_nsgs(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_nsgs_initialize_local_solver(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverPtr *arg1 = (SolverPtr *) 0 ;
  UpdatePtr *arg2 = (UpdatePtr *) 0 ;
  FreeSolverNSGSPtr *arg3 = (FreeSolverNSGSPtr *) 0 ;
  ComputeErrorPtr *arg4 = (ComputeErrorPtr *) 0 ;
  FrictionContactProblem *arg5 = (FrictionContactProblem *) 0 ;
  FrictionContactProblem *arg6 = (FrictionContactProblem *) 0 ;
  SolverOptions *arg7 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:fc3d_nsgs_initialize_local_solver",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_p_f_p_FrictionContactProblem_p_double_p_SolverOptions__int, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_nsgs_initialize_local_solver" "', argument " "1"" of type '" "SolverPtr *""'"); 
  }
  arg1 = (SolverPtr *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_p_f_int_p_FrictionContactProblem_p_FrictionContactProblem_p_double_p_SolverOptions__void, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "fc3d_nsgs_initialize_local_solver" "', argument " "2"" of type '" "UpdatePtr *""'"); 
  }
  arg2 = (UpdatePtr *)(argp2);
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_p_f_p_FrictionContactProblem_p_FrictionContactProblem_p_SolverOptions__void, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "fc3d_nsgs_initialize_local_solver" "', argument " "3"" of type '" "FreeSolverNSGSPtr *""'"); 
  }
  arg3 = (FreeSolverNSGSPtr *)(argp3);
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_p_f_p_FrictionContactProblem_p_double_p_double_double_p_SolverOptions_double_p_double__void, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "fc3d_nsgs_initialize_local_solver" "', argument " "4"" of type '" "ComputeErrorPtr *""'"); 
  }
  arg4 = (ComputeErrorPtr *)(argp4);
  res5 = SWIG_ConvertPtr(obj4, &argp5,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc3d_nsgs_initialize_local_solver" "', argument " "5"" of type '" "FrictionContactProblem *""'"); 
  }
  arg5 = (FrictionContactProblem *)(argp5);
  res6 = SWIG_ConvertPtr(obj5, &argp6,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "fc3d_nsgs_initialize_local_solver" "', argument " "6"" of type '" "FrictionContactProblem *""'"); 
  }
  arg6 = (FrictionContactProblem *)(argp6);
  res7 = SWIG_ConvertPtr(obj6, &argp7,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res7)) {
    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "fc3d_nsgs_initialize_local_solver" "', argument " "7"" of type '" "SolverOptions *""'"); 
  }
  arg7 = (SolverOptions *)(argp7);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_nsgs_initialize_local_solver(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_nsgs_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:fc3d_nsgs_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_nsgs_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc3d_nsgs_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_admm(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:fc3d_admm",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_admm" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc3d_admm" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_admm(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_admm_init(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:fc3d_admm_init",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_admm_init" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "fc3d_admm_init" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_admm_init(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_admm_free(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:fc3d_admm_free",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_admm_free" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "fc3d_admm_free" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_admm_free(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_admm_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:fc3d_admm_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_admm_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc3d_admm_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_nsgs_velocity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:fc3d_nsgs_velocity",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_nsgs_velocity" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc3d_nsgs_velocity" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_nsgs_velocity(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_nsgs_velocity_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:fc3d_nsgs_velocity_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_nsgs_velocity_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc3d_nsgs_velocity_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_proximal(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:fc3d_proximal",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_proximal" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc3d_proximal" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_proximal(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_proximal_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:fc3d_proximal_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_proximal_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc3d_proximal_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_set_internalsolver_tolerance(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  SolverOptions *arg3 = (SolverOptions *) 0 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:fc3d_set_internalsolver_tolerance",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_set_internalsolver_tolerance" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "fc3d_set_internalsolver_tolerance" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "fc3d_set_internalsolver_tolerance" "', argument " "3"" of type '" "SolverOptions *""'"); 
  }
  arg3 = (SolverOptions *)(argp3);
  ecode4 = SWIG_AsVal_double(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "fc3d_set_internalsolver_tolerance" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_set_internalsolver_tolerance(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_TrescaFixedPoint(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:fc3d_TrescaFixedPoint",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_TrescaFixedPoint" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc3d_TrescaFixedPoint" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_TrescaFixedPoint(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_TrescaFixedPoint_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:fc3d_TrescaFixedPoint_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_TrescaFixedPoint_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc3d_TrescaFixedPoint_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_Panagiotopoulos_FixedPoint(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:fc3d_Panagiotopoulos_FixedPoint",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_Panagiotopoulos_FixedPoint" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc3d_Panagiotopoulos_FixedPoint" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_Panagiotopoulos_FixedPoint(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_Panagiotopoulos_FixedPoint_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:fc3d_Panagiotopoulos_FixedPoint_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_Panagiotopoulos_FixedPoint_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc3d_Panagiotopoulos_FixedPoint_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_SOCLCP_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:fc3d_SOCLCP_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_SOCLCP_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc3d_SOCLCP_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_SOCLCP(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:fc3d_SOCLCP",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_SOCLCP" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc3d_SOCLCP" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_SOCLCP(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_ACLMFixedPoint(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:fc3d_ACLMFixedPoint",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_ACLMFixedPoint" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc3d_ACLMFixedPoint" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_ACLMFixedPoint(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_ACLMFixedPoint_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:fc3d_ACLMFixedPoint_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_ACLMFixedPoint_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc3d_ACLMFixedPoint_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_ConvexQP_ProjectedGradient_Cylinder(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:fc3d_ConvexQP_ProjectedGradient_Cylinder",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_ConvexQP_ProjectedGradient_Cylinder" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc3d_ConvexQP_ProjectedGradient_Cylinder" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_ConvexQP_ProjectedGradient_Cylinder(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_ConvexQP_ProjectedGradient_Cylinder_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:fc3d_ConvexQP_ProjectedGradient_Cylinder_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_ConvexQP_ProjectedGradient_Cylinder_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc3d_ConvexQP_ProjectedGradient_Cylinder_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_DeSaxceFixedPoint(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:fc3d_DeSaxceFixedPoint",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_DeSaxceFixedPoint" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc3d_DeSaxceFixedPoint" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_DeSaxceFixedPoint(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_DeSaxceFixedPoint_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:fc3d_DeSaxceFixedPoint_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_DeSaxceFixedPoint_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc3d_DeSaxceFixedPoint_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_fixedPointProjection(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:fc3d_fixedPointProjection",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_fixedPointProjection" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc3d_fixedPointProjection" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_fixedPointProjection(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_fixedPointProjection_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:fc3d_fixedPointProjection_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_fixedPointProjection_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc3d_fixedPointProjection_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_VI_FixedPointProjection(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:fc3d_VI_FixedPointProjection",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_VI_FixedPointProjection" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc3d_VI_FixedPointProjection" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_VI_FixedPointProjection(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_VI_FixedPointProjection_Cylinder(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:fc3d_VI_FixedPointProjection_Cylinder",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_VI_FixedPointProjection_Cylinder" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc3d_VI_FixedPointProjection_Cylinder" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_VI_FixedPointProjection_Cylinder(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_VI_FixedPointProjection_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:fc3d_VI_FixedPointProjection_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_VI_FixedPointProjection_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc3d_VI_FixedPointProjection_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_VI_FixedPointProjection_Cylinder_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:fc3d_VI_FixedPointProjection_Cylinder_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_VI_FixedPointProjection_Cylinder_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc3d_VI_FixedPointProjection_Cylinder_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_ExtraGradient(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:fc3d_ExtraGradient",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_ExtraGradient" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc3d_ExtraGradient" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_ExtraGradient(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_ExtraGradient_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:fc3d_ExtraGradient_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_ExtraGradient_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc3d_ExtraGradient_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_VI_ExtraGradient(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:fc3d_VI_ExtraGradient",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_VI_ExtraGradient" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc3d_VI_ExtraGradient" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_VI_ExtraGradient(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_VI_ExtraGradient_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:fc3d_VI_ExtraGradient_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_VI_ExtraGradient_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc3d_VI_ExtraGradient_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_HyperplaneProjection(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:fc3d_HyperplaneProjection",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_HyperplaneProjection" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc3d_HyperplaneProjection" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_HyperplaneProjection(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_AVI_gams_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:fc3d_AVI_gams_path",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_AVI_gams_path" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc3d_AVI_gams_path" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_AVI_gams_path(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_AVI_gams_pathvi(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:fc3d_AVI_gams_pathvi",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_AVI_gams_pathvi" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc3d_AVI_gams_pathvi" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_AVI_gams_pathvi(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_lcp_gams_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:fc3d_lcp_gams_path",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_lcp_gams_path" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc3d_lcp_gams_path" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_lcp_gams_path(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_lcp_gams_pathvi(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:fc3d_lcp_gams_pathvi",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_lcp_gams_pathvi" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc3d_lcp_gams_pathvi" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_lcp_gams_pathvi(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_HyperplaneProjection_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:fc3d_HyperplaneProjection_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_HyperplaneProjection_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc3d_HyperplaneProjection_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_checkTrivialCase(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  SolverOptions *arg4 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:fc3d_checkTrivialCase",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_checkTrivialCase" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "fc3d_checkTrivialCase" "', argument " "4"" of type '" "SolverOptions *""'"); 
  }
  arg4 = (SolverOptions *)(argp4);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc3d_checkTrivialCase(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_nonsmooth_Newton_AlartCurnier2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:fc3d_nonsmooth_Newton_AlartCurnier2",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_nonsmooth_Newton_AlartCurnier2" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc3d_nonsmooth_Newton_AlartCurnier2" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_nonsmooth_Newton_AlartCurnier2(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_unitary_enumerative_free(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:fc3d_unitary_enumerative_free",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_unitary_enumerative_free" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_unitary_enumerative_free(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_unitary_enumerative_initialize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:fc3d_unitary_enumerative_initialize",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_unitary_enumerative_initialize" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_unitary_enumerative_initialize(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_unitary_enumerative_solve(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  SolverOptions *arg3 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:fc3d_unitary_enumerative_solve",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_unitary_enumerative_solve" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "fc3d_unitary_enumerative_solve" "', argument " "3"" of type '" "SolverOptions *""'"); 
  }
  arg3 = (SolverOptions *)(argp3);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc3d_unitary_enumerative_solve(arg1,arg2,arg3);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_unitary_enumerative_solve_sliding(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  SolverOptions *arg3 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:fc3d_unitary_enumerative_solve_sliding",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_unitary_enumerative_solve_sliding" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "fc3d_unitary_enumerative_solve_sliding" "', argument " "3"" of type '" "SolverOptions *""'"); 
  }
  arg3 = (SolverOptions *)(argp3);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc3d_unitary_enumerative_solve_sliding(arg1,arg2,arg3);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_unitary_enumerative_test_non_sliding(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  SolverOptions *arg4 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:fc3d_unitary_enumerative_test_non_sliding",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_unitary_enumerative_test_non_sliding" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "fc3d_unitary_enumerative_test_non_sliding" "', argument " "4"" of type '" "SolverOptions *""'"); 
  }
  arg4 = (SolverOptions *)(argp4);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc3d_unitary_enumerative_test_non_sliding(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_unitary_enumerative(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  int result;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:fc3d_unitary_enumerative",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_unitary_enumerative" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc3d_unitary_enumerative" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc3d_unitary_enumerative(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_unitary_enumerative_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:fc3d_unitary_enumerative_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_unitary_enumerative_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc3d_unitary_enumerative_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_unitary_enumerative_solve_poly_nu_sliding(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  SolverOptions *arg3 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:fc3d_unitary_enumerative_solve_poly_nu_sliding",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_unitary_enumerative_solve_poly_nu_sliding" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "fc3d_unitary_enumerative_solve_poly_nu_sliding" "', argument " "3"" of type '" "SolverOptions *""'"); 
  }
  arg3 = (SolverOptions *)(argp3);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc3d_unitary_enumerative_solve_poly_nu_sliding(arg1,arg2,arg3);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc2d_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:fc2d_setDefaultSolverOptions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc2d_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "fc2d_setDefaultSolverOptions" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc2d_setDefaultSolverOptions(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc2d_cpg(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:fc2d_cpg",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc2d_cpg" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc2d_cpg" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc2d_cpg(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc2d_cpg_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:fc2d_cpg_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc2d_cpg_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc2d_cpg_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc2d_nsgs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:fc2d_nsgs",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc2d_nsgs" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc2d_nsgs" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc2d_nsgs(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc2d_nsgs_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:fc2d_nsgs_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc2d_nsgs_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc2d_nsgs_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc2d_latin(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:fc2d_latin",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc2d_latin" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc2d_latin" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc2d_latin(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc2d_latin_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:fc2d_latin_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc2d_latin_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc2d_latin_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc2d_projc(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  double *arg1 ;
  int *arg2 = (int *) 0 ;
  int *arg3 ;
  double *arg4 ;
  double *arg5 ;
  double *arg6 = (double *) 0 ;
  int *arg7 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyArrayObject *array6 = NULL ;
  int is_new_object6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:fc2d_projc",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc2d_projc" "', argument " "1"" of type '" "double []""'"); 
  } 
  arg1 = (double *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_int, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "fc2d_projc" "', argument " "2"" of type '" "int *""'"); 
  }
  arg2 = (int *)(argp2);
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_int, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "fc2d_projc" "', argument " "3"" of type '" "int []""'"); 
  } 
  arg3 = (int *)(argp3);
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "fc2d_projc" "', argument " "4"" of type '" "double []""'"); 
  } 
  arg4 = (double *)(argp4);
  res5 = SWIG_ConvertPtr(obj4, &argp5,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc2d_projc" "', argument " "5"" of type '" "double []""'"); 
  } 
  arg5 = (double *)(argp5);
  {
    array6 = obj_to_sn_vector(obj5, &is_new_object6);
    
    if (!array6)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array6))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg6 = (double *) array_data(array6);
    
  }
  res7 = SWIG_ConvertPtr(obj6, &argp7,SWIGTYPE_p_int, 0 |  0 );
  if (!SWIG_IsOK(res7)) {
    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "fc2d_projc" "', argument " "7"" of type '" "int *""'"); 
  }
  arg7 = (int *)(argp7);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc2d_projc(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    if(is_new_object6 && array6) {
      Py_DECREF(array6); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object6 && array6) {
      Py_DECREF(array6); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc2d_projf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int *arg1 ;
  int *arg2 = (int *) 0 ;
  double *arg3 ;
  double *arg4 ;
  double *arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:fc2d_projf",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_int, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc2d_projf" "', argument " "1"" of type '" "int []""'"); 
  } 
  arg1 = (int *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_int, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "fc2d_projf" "', argument " "2"" of type '" "int *""'"); 
  }
  arg2 = (int *)(argp2);
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "fc2d_projf" "', argument " "3"" of type '" "double []""'"); 
  } 
  arg3 = (double *)(argp3);
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "fc2d_projf" "', argument " "4"" of type '" "double []""'"); 
  } 
  arg4 = (double *)(argp4);
  res5 = SWIG_ConvertPtr(obj4, &argp5,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc2d_projf" "', argument " "5"" of type '" "double []""'"); 
  } 
  arg5 = (double *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc2d_projf(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc2d_sparse_nsgs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:fc2d_sparse_nsgs",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc2d_sparse_nsgs" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc2d_sparse_nsgs" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc2d_sparse_nsgs(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc2d_sparse_nsgs_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:fc2d_sparse_nsgs_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc2d_sparse_nsgs_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc2d_sparse_nsgs_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc2d_lexicolemke(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:fc2d_lexicolemke",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc2d_lexicolemke" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc2d_lexicolemke" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc2d_lexicolemke(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc2d_lexicolemke_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:fc2d_lexicolemke_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc2d_lexicolemke_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc2d_lexicolemke_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc2d_tolcp(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  LinearComplementarityProblem *arg2 = (LinearComplementarityProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:fc2d_tolcp",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc2d_tolcp" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_LinearComplementarityProblem, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "fc2d_tolcp" "', argument " "2"" of type '" "LinearComplementarityProblem *""'"); 
  }
  arg2 = (LinearComplementarityProblem *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc2d_tolcp(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc2d_enum_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:fc2d_enum_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc2d_enum_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc2d_enum_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc2d_enum(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:fc2d_enum",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc2d_enum" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc2d_enum" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc2d_enum(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_compute_error(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double arg4 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  double arg6 ;
  double *arg7 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  double temp7 ;
  int res7 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  int result;
  
  arg7 = &temp7;
  if (!PyArg_ParseTuple(args,(char *)"OOOOOO:fc3d_compute_error",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_compute_error" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  ecode4 = SWIG_AsVal_double(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "fc3d_compute_error" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  res5 = SWIG_ConvertPtr(obj4, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc3d_compute_error" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  ecode6 = SWIG_AsVal_double(obj5, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "fc3d_compute_error" "', argument " "6"" of type '" "double""'");
  } 
  arg6 = (double)(val6);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc3d_compute_error(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  if (SWIG_IsTmpObj(res7)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg7)));
  } else {
    int new_flags = SWIG_IsNewObj(res7) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg7), SWIGTYPE_p_double, new_flags));
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_unitary_compute_and_add_error(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  double *arg1 ;
  double *arg2 ;
  double arg3 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  arg4 = &temp4;
  if (!PyArg_ParseTuple(args,(char *)"OOOO:fc3d_unitary_compute_and_add_error",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_unitary_compute_and_add_error" "', argument " "1"" of type '" "double [3]""'"); 
  } 
  arg1 = (double *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "fc3d_unitary_compute_and_add_error" "', argument " "2"" of type '" "double [3]""'"); 
  } 
  arg2 = (double *)(argp2);
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "fc3d_unitary_compute_and_add_error" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc3d_unitary_compute_and_add_error" "', argument " "5"" of type '" "double *""'"); 
  }
  arg5 = (double *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_unitary_compute_and_add_error(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_compute_error_velocity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double arg4 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  double *arg6 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  double temp6 ;
  int res6 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  int result;
  
  arg6 = &temp6;
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:fc3d_compute_error_velocity",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_compute_error_velocity" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  ecode4 = SWIG_AsVal_double(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "fc3d_compute_error_velocity" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  res5 = SWIG_ConvertPtr(obj4, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc3d_compute_error_velocity" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc3d_compute_error_velocity(arg1,arg2,arg3,arg4,arg5,arg6);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_double, new_flags));
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_Tresca_unitary_compute_and_add_error(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  double *arg1 ;
  double *arg2 ;
  double arg3 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  arg4 = &temp4;
  if (!PyArg_ParseTuple(args,(char *)"OOOO:fc3d_Tresca_unitary_compute_and_add_error",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_Tresca_unitary_compute_and_add_error" "', argument " "1"" of type '" "double [3]""'"); 
  } 
  arg1 = (double *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "fc3d_Tresca_unitary_compute_and_add_error" "', argument " "2"" of type '" "double [3]""'"); 
  } 
  arg2 = (double *)(argp2);
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "fc3d_Tresca_unitary_compute_and_add_error" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc3d_Tresca_unitary_compute_and_add_error" "', argument " "5"" of type '" "double *""'"); 
  }
  arg5 = (double *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        fc3d_Tresca_unitary_compute_and_add_error(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fc3d_Tresca_compute_error(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FrictionContactProblem *arg1 = (FrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double arg4 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  double arg6 ;
  double *arg7 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  double temp7 ;
  int res7 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  int result;
  
  arg7 = &temp7;
  if (!PyArg_ParseTuple(args,(char *)"OOOOOO:fc3d_Tresca_compute_error",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fc3d_Tresca_compute_error" "', argument " "1"" of type '" "FrictionContactProblem *""'"); 
  }
  arg1 = (FrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  ecode4 = SWIG_AsVal_double(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "fc3d_Tresca_compute_error" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  res5 = SWIG_ConvertPtr(obj4, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "fc3d_Tresca_compute_error" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  ecode6 = SWIG_AsVal_double(obj5, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "fc3d_Tresca_compute_error" "', argument " "6"" of type '" "double""'");
  } 
  arg6 = (double)(val6);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)fc3d_Tresca_compute_error(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  if (SWIG_IsTmpObj(res7)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg7)));
  } else {
    int new_flags = SWIG_IsNewObj(res7) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg7), SWIGTYPE_p_double, new_flags));
  }
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_frictionContactProblemFromFile(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  PyObject * obj0 = 0 ;
  FrictionContactProblem *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:frictionContactProblemFromFile",&obj0)) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "frictionContactProblemFromFile" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = (char *)(buf1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (FrictionContactProblem *)frictionContactProblemFromFile((char const *)arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FrictionContactProblem, 0 |  0 );
  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
  return resultobj;
fail:
  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
  return NULL;
}


SWIGINTERN PyObject *_wrap_GAMS_opt_bool_name_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GAMS_opt_bool_ *arg1 = (struct GAMS_opt_bool_ *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:GAMS_opt_bool_name_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GAMS_opt_bool_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GAMS_opt_bool_name_set" "', argument " "1"" of type '" "struct GAMS_opt_bool_ *""'"); 
  }
  arg1 = (struct GAMS_opt_bool_ *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GAMS_opt_bool_name_set" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  if (arg1->name) free((char*)arg1->name);
  if (arg2) {
    size_t size = strlen((const char *)(arg2)) + 1;
    arg1->name = (char *)(char *)memcpy(malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
  } else {
    arg1->name = 0;
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_GAMS_opt_bool_name_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GAMS_opt_bool_ *arg1 = (struct GAMS_opt_bool_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:GAMS_opt_bool_name_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GAMS_opt_bool_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GAMS_opt_bool_name_get" "', argument " "1"" of type '" "struct GAMS_opt_bool_ *""'"); 
  }
  arg1 = (struct GAMS_opt_bool_ *)(argp1);
  result = (char *) ((arg1)->name);
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GAMS_opt_bool_value_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GAMS_opt_bool_ *arg1 = (struct GAMS_opt_bool_ *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:GAMS_opt_bool_value_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GAMS_opt_bool_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GAMS_opt_bool_value_set" "', argument " "1"" of type '" "struct GAMS_opt_bool_ *""'"); 
  }
  arg1 = (struct GAMS_opt_bool_ *)(argp1);
  ecode2 = SWIG_AsVal_bool(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GAMS_opt_bool_value_set" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = (bool)(val2);
  if (arg1) (arg1)->value = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GAMS_opt_bool_value_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GAMS_opt_bool_ *arg1 = (struct GAMS_opt_bool_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:GAMS_opt_bool_value_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GAMS_opt_bool_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GAMS_opt_bool_value_get" "', argument " "1"" of type '" "struct GAMS_opt_bool_ *""'"); 
  }
  arg1 = (struct GAMS_opt_bool_ *)(argp1);
  result = (bool) ((arg1)->value);
  resultobj = SWIG_From_bool((bool)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GAMS_opt_bool_type_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GAMS_opt_bool_ *arg1 = (struct GAMS_opt_bool_ *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:GAMS_opt_bool_type_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GAMS_opt_bool_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GAMS_opt_bool_type_set" "', argument " "1"" of type '" "struct GAMS_opt_bool_ *""'"); 
  }
  arg1 = (struct GAMS_opt_bool_ *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GAMS_opt_bool_type_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  if (arg1) (arg1)->type = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GAMS_opt_bool_type_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GAMS_opt_bool_ *arg1 = (struct GAMS_opt_bool_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:GAMS_opt_bool_type_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GAMS_opt_bool_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GAMS_opt_bool_type_get" "', argument " "1"" of type '" "struct GAMS_opt_bool_ *""'"); 
  }
  arg1 = (struct GAMS_opt_bool_ *)(argp1);
  result = (unsigned int) ((arg1)->type);
  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GAMS_opt_bool_next_opt_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GAMS_opt_bool_ *arg1 = (struct GAMS_opt_bool_ *) 0 ;
  struct GAMS_opt_bool_ *arg2 = (struct GAMS_opt_bool_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:GAMS_opt_bool_next_opt_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GAMS_opt_bool_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GAMS_opt_bool_next_opt_set" "', argument " "1"" of type '" "struct GAMS_opt_bool_ *""'"); 
  }
  arg1 = (struct GAMS_opt_bool_ *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_GAMS_opt_bool_, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GAMS_opt_bool_next_opt_set" "', argument " "2"" of type '" "struct GAMS_opt_bool_ *""'"); 
  }
  arg2 = (struct GAMS_opt_bool_ *)(argp2);
  if (arg1) (arg1)->next_opt = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GAMS_opt_bool_next_opt_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GAMS_opt_bool_ *arg1 = (struct GAMS_opt_bool_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  struct GAMS_opt_bool_ *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:GAMS_opt_bool_next_opt_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GAMS_opt_bool_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GAMS_opt_bool_next_opt_get" "', argument " "1"" of type '" "struct GAMS_opt_bool_ *""'"); 
  }
  arg1 = (struct GAMS_opt_bool_ *)(argp1);
  result = (struct GAMS_opt_bool_ *) ((arg1)->next_opt);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GAMS_opt_bool_, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_GAMS_opt_bool(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GAMS_opt_bool_ *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_GAMS_opt_bool")) SWIG_fail;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct GAMS_opt_bool_ *)calloc(1, sizeof(struct GAMS_opt_bool_));
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GAMS_opt_bool_, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_GAMS_opt_bool(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GAMS_opt_bool_ *arg1 = (struct GAMS_opt_bool_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_GAMS_opt_bool",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GAMS_opt_bool_, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_GAMS_opt_bool" "', argument " "1"" of type '" "struct GAMS_opt_bool_ *""'"); 
  }
  arg1 = (struct GAMS_opt_bool_ *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        free((char *) arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *GAMS_opt_bool_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_GAMS_opt_bool_, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_GAMS_opt_int_name_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GAMS_opt_int_ *arg1 = (struct GAMS_opt_int_ *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:GAMS_opt_int_name_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GAMS_opt_int_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GAMS_opt_int_name_set" "', argument " "1"" of type '" "struct GAMS_opt_int_ *""'"); 
  }
  arg1 = (struct GAMS_opt_int_ *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GAMS_opt_int_name_set" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  if (arg1->name) free((char*)arg1->name);
  if (arg2) {
    size_t size = strlen((const char *)(arg2)) + 1;
    arg1->name = (char *)(char *)memcpy(malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
  } else {
    arg1->name = 0;
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_GAMS_opt_int_name_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GAMS_opt_int_ *arg1 = (struct GAMS_opt_int_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:GAMS_opt_int_name_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GAMS_opt_int_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GAMS_opt_int_name_get" "', argument " "1"" of type '" "struct GAMS_opt_int_ *""'"); 
  }
  arg1 = (struct GAMS_opt_int_ *)(argp1);
  result = (char *) ((arg1)->name);
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GAMS_opt_int_value_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GAMS_opt_int_ *arg1 = (struct GAMS_opt_int_ *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:GAMS_opt_int_value_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GAMS_opt_int_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GAMS_opt_int_value_set" "', argument " "1"" of type '" "struct GAMS_opt_int_ *""'"); 
  }
  arg1 = (struct GAMS_opt_int_ *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GAMS_opt_int_value_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->value = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GAMS_opt_int_value_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GAMS_opt_int_ *arg1 = (struct GAMS_opt_int_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:GAMS_opt_int_value_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GAMS_opt_int_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GAMS_opt_int_value_get" "', argument " "1"" of type '" "struct GAMS_opt_int_ *""'"); 
  }
  arg1 = (struct GAMS_opt_int_ *)(argp1);
  result = (int) ((arg1)->value);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GAMS_opt_int_type_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GAMS_opt_int_ *arg1 = (struct GAMS_opt_int_ *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:GAMS_opt_int_type_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GAMS_opt_int_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GAMS_opt_int_type_set" "', argument " "1"" of type '" "struct GAMS_opt_int_ *""'"); 
  }
  arg1 = (struct GAMS_opt_int_ *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GAMS_opt_int_type_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  if (arg1) (arg1)->type = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GAMS_opt_int_type_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GAMS_opt_int_ *arg1 = (struct GAMS_opt_int_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:GAMS_opt_int_type_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GAMS_opt_int_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GAMS_opt_int_type_get" "', argument " "1"" of type '" "struct GAMS_opt_int_ *""'"); 
  }
  arg1 = (struct GAMS_opt_int_ *)(argp1);
  result = (unsigned int) ((arg1)->type);
  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GAMS_opt_int_next_opt_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GAMS_opt_int_ *arg1 = (struct GAMS_opt_int_ *) 0 ;
  struct GAMS_opt_int_ *arg2 = (struct GAMS_opt_int_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:GAMS_opt_int_next_opt_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GAMS_opt_int_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GAMS_opt_int_next_opt_set" "', argument " "1"" of type '" "struct GAMS_opt_int_ *""'"); 
  }
  arg1 = (struct GAMS_opt_int_ *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_GAMS_opt_int_, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GAMS_opt_int_next_opt_set" "', argument " "2"" of type '" "struct GAMS_opt_int_ *""'"); 
  }
  arg2 = (struct GAMS_opt_int_ *)(argp2);
  if (arg1) (arg1)->next_opt = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GAMS_opt_int_next_opt_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GAMS_opt_int_ *arg1 = (struct GAMS_opt_int_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  struct GAMS_opt_int_ *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:GAMS_opt_int_next_opt_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GAMS_opt_int_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GAMS_opt_int_next_opt_get" "', argument " "1"" of type '" "struct GAMS_opt_int_ *""'"); 
  }
  arg1 = (struct GAMS_opt_int_ *)(argp1);
  result = (struct GAMS_opt_int_ *) ((arg1)->next_opt);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GAMS_opt_int_, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_GAMS_opt_int(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GAMS_opt_int_ *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_GAMS_opt_int")) SWIG_fail;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct GAMS_opt_int_ *)calloc(1, sizeof(struct GAMS_opt_int_));
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GAMS_opt_int_, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_GAMS_opt_int(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GAMS_opt_int_ *arg1 = (struct GAMS_opt_int_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_GAMS_opt_int",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GAMS_opt_int_, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_GAMS_opt_int" "', argument " "1"" of type '" "struct GAMS_opt_int_ *""'"); 
  }
  arg1 = (struct GAMS_opt_int_ *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        free((char *) arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *GAMS_opt_int_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_GAMS_opt_int_, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_GAMS_opt_double_name_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GAMS_opt_double_ *arg1 = (struct GAMS_opt_double_ *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:GAMS_opt_double_name_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GAMS_opt_double_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GAMS_opt_double_name_set" "', argument " "1"" of type '" "struct GAMS_opt_double_ *""'"); 
  }
  arg1 = (struct GAMS_opt_double_ *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GAMS_opt_double_name_set" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  if (arg1->name) free((char*)arg1->name);
  if (arg2) {
    size_t size = strlen((const char *)(arg2)) + 1;
    arg1->name = (char *)(char *)memcpy(malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
  } else {
    arg1->name = 0;
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_GAMS_opt_double_name_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GAMS_opt_double_ *arg1 = (struct GAMS_opt_double_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:GAMS_opt_double_name_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GAMS_opt_double_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GAMS_opt_double_name_get" "', argument " "1"" of type '" "struct GAMS_opt_double_ *""'"); 
  }
  arg1 = (struct GAMS_opt_double_ *)(argp1);
  result = (char *) ((arg1)->name);
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GAMS_opt_double_value_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GAMS_opt_double_ *arg1 = (struct GAMS_opt_double_ *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:GAMS_opt_double_value_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GAMS_opt_double_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GAMS_opt_double_value_set" "', argument " "1"" of type '" "struct GAMS_opt_double_ *""'"); 
  }
  arg1 = (struct GAMS_opt_double_ *)(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GAMS_opt_double_value_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->value = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GAMS_opt_double_value_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GAMS_opt_double_ *arg1 = (struct GAMS_opt_double_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:GAMS_opt_double_value_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GAMS_opt_double_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GAMS_opt_double_value_get" "', argument " "1"" of type '" "struct GAMS_opt_double_ *""'"); 
  }
  arg1 = (struct GAMS_opt_double_ *)(argp1);
  result = (double) ((arg1)->value);
  resultobj = SWIG_From_double((double)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GAMS_opt_double_type_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GAMS_opt_double_ *arg1 = (struct GAMS_opt_double_ *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:GAMS_opt_double_type_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GAMS_opt_double_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GAMS_opt_double_type_set" "', argument " "1"" of type '" "struct GAMS_opt_double_ *""'"); 
  }
  arg1 = (struct GAMS_opt_double_ *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GAMS_opt_double_type_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  if (arg1) (arg1)->type = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GAMS_opt_double_type_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GAMS_opt_double_ *arg1 = (struct GAMS_opt_double_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:GAMS_opt_double_type_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GAMS_opt_double_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GAMS_opt_double_type_get" "', argument " "1"" of type '" "struct GAMS_opt_double_ *""'"); 
  }
  arg1 = (struct GAMS_opt_double_ *)(argp1);
  result = (unsigned int) ((arg1)->type);
  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GAMS_opt_double_next_opt_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GAMS_opt_double_ *arg1 = (struct GAMS_opt_double_ *) 0 ;
  struct GAMS_opt_double_ *arg2 = (struct GAMS_opt_double_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:GAMS_opt_double_next_opt_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GAMS_opt_double_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GAMS_opt_double_next_opt_set" "', argument " "1"" of type '" "struct GAMS_opt_double_ *""'"); 
  }
  arg1 = (struct GAMS_opt_double_ *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_GAMS_opt_double_, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GAMS_opt_double_next_opt_set" "', argument " "2"" of type '" "struct GAMS_opt_double_ *""'"); 
  }
  arg2 = (struct GAMS_opt_double_ *)(argp2);
  if (arg1) (arg1)->next_opt = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GAMS_opt_double_next_opt_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GAMS_opt_double_ *arg1 = (struct GAMS_opt_double_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  struct GAMS_opt_double_ *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:GAMS_opt_double_next_opt_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GAMS_opt_double_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GAMS_opt_double_next_opt_get" "', argument " "1"" of type '" "struct GAMS_opt_double_ *""'"); 
  }
  arg1 = (struct GAMS_opt_double_ *)(argp1);
  result = (struct GAMS_opt_double_ *) ((arg1)->next_opt);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GAMS_opt_double_, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_GAMS_opt_double(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GAMS_opt_double_ *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_GAMS_opt_double")) SWIG_fail;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct GAMS_opt_double_ *)calloc(1, sizeof(struct GAMS_opt_double_));
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GAMS_opt_double_, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_GAMS_opt_double(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GAMS_opt_double_ *arg1 = (struct GAMS_opt_double_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_GAMS_opt_double",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GAMS_opt_double_, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_GAMS_opt_double" "', argument " "1"" of type '" "struct GAMS_opt_double_ *""'"); 
  }
  arg1 = (struct GAMS_opt_double_ *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        free((char *) arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *GAMS_opt_double_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_GAMS_opt_double_, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_GAMS_opt_str_name_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GAMS_opt_str_ *arg1 = (struct GAMS_opt_str_ *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:GAMS_opt_str_name_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GAMS_opt_str_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GAMS_opt_str_name_set" "', argument " "1"" of type '" "struct GAMS_opt_str_ *""'"); 
  }
  arg1 = (struct GAMS_opt_str_ *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GAMS_opt_str_name_set" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  if (arg1->name) free((char*)arg1->name);
  if (arg2) {
    size_t size = strlen((const char *)(arg2)) + 1;
    arg1->name = (char *)(char *)memcpy(malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
  } else {
    arg1->name = 0;
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_GAMS_opt_str_name_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GAMS_opt_str_ *arg1 = (struct GAMS_opt_str_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:GAMS_opt_str_name_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GAMS_opt_str_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GAMS_opt_str_name_get" "', argument " "1"" of type '" "struct GAMS_opt_str_ *""'"); 
  }
  arg1 = (struct GAMS_opt_str_ *)(argp1);
  result = (char *) ((arg1)->name);
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GAMS_opt_str_value_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GAMS_opt_str_ *arg1 = (struct GAMS_opt_str_ *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:GAMS_opt_str_value_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GAMS_opt_str_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GAMS_opt_str_value_set" "', argument " "1"" of type '" "struct GAMS_opt_str_ *""'"); 
  }
  arg1 = (struct GAMS_opt_str_ *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GAMS_opt_str_value_set" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  if (arg1->value) free((char*)arg1->value);
  if (arg2) {
    size_t size = strlen((const char *)(arg2)) + 1;
    arg1->value = (char *)(char *)memcpy(malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
  } else {
    arg1->value = 0;
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_GAMS_opt_str_value_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GAMS_opt_str_ *arg1 = (struct GAMS_opt_str_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:GAMS_opt_str_value_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GAMS_opt_str_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GAMS_opt_str_value_get" "', argument " "1"" of type '" "struct GAMS_opt_str_ *""'"); 
  }
  arg1 = (struct GAMS_opt_str_ *)(argp1);
  result = (char *) ((arg1)->value);
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GAMS_opt_str_type_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GAMS_opt_str_ *arg1 = (struct GAMS_opt_str_ *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:GAMS_opt_str_type_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GAMS_opt_str_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GAMS_opt_str_type_set" "', argument " "1"" of type '" "struct GAMS_opt_str_ *""'"); 
  }
  arg1 = (struct GAMS_opt_str_ *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GAMS_opt_str_type_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  if (arg1) (arg1)->type = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GAMS_opt_str_type_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GAMS_opt_str_ *arg1 = (struct GAMS_opt_str_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:GAMS_opt_str_type_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GAMS_opt_str_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GAMS_opt_str_type_get" "', argument " "1"" of type '" "struct GAMS_opt_str_ *""'"); 
  }
  arg1 = (struct GAMS_opt_str_ *)(argp1);
  result = (unsigned int) ((arg1)->type);
  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GAMS_opt_str_next_opt_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GAMS_opt_str_ *arg1 = (struct GAMS_opt_str_ *) 0 ;
  struct GAMS_opt_str_ *arg2 = (struct GAMS_opt_str_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:GAMS_opt_str_next_opt_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GAMS_opt_str_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GAMS_opt_str_next_opt_set" "', argument " "1"" of type '" "struct GAMS_opt_str_ *""'"); 
  }
  arg1 = (struct GAMS_opt_str_ *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_GAMS_opt_str_, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GAMS_opt_str_next_opt_set" "', argument " "2"" of type '" "struct GAMS_opt_str_ *""'"); 
  }
  arg2 = (struct GAMS_opt_str_ *)(argp2);
  if (arg1) (arg1)->next_opt = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GAMS_opt_str_next_opt_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GAMS_opt_str_ *arg1 = (struct GAMS_opt_str_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  struct GAMS_opt_str_ *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:GAMS_opt_str_next_opt_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GAMS_opt_str_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GAMS_opt_str_next_opt_get" "', argument " "1"" of type '" "struct GAMS_opt_str_ *""'"); 
  }
  arg1 = (struct GAMS_opt_str_ *)(argp1);
  result = (struct GAMS_opt_str_ *) ((arg1)->next_opt);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GAMS_opt_str_, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_GAMS_opt_str(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GAMS_opt_str_ *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_GAMS_opt_str")) SWIG_fail;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct GAMS_opt_str_ *)calloc(1, sizeof(struct GAMS_opt_str_));
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GAMS_opt_str_, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_GAMS_opt_str(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GAMS_opt_str_ *arg1 = (struct GAMS_opt_str_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_GAMS_opt_str",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GAMS_opt_str_, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_GAMS_opt_str" "', argument " "1"" of type '" "struct GAMS_opt_str_ *""'"); 
  }
  arg1 = (struct GAMS_opt_str_ *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        free((char *) arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *GAMS_opt_str_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_GAMS_opt_str_, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_SN_GAMSparams_model_dir_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SN_GAMSparams *arg1 = (SN_GAMSparams *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SN_GAMSparams_model_dir_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMSparams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_GAMSparams_model_dir_set" "', argument " "1"" of type '" "SN_GAMSparams *""'"); 
  }
  arg1 = (SN_GAMSparams *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SN_GAMSparams_model_dir_set" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  if (arg1->model_dir) free((char*)arg1->model_dir);
  if (arg2) {
    size_t size = strlen((const char *)(arg2)) + 1;
    arg1->model_dir = (char *)(char *)memcpy(malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
  } else {
    arg1->model_dir = 0;
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_SN_GAMSparams_model_dir_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SN_GAMSparams *arg1 = (SN_GAMSparams *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SN_GAMSparams_model_dir_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMSparams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_GAMSparams_model_dir_get" "', argument " "1"" of type '" "SN_GAMSparams *""'"); 
  }
  arg1 = (SN_GAMSparams *)(argp1);
  result = (char *) ((arg1)->model_dir);
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SN_GAMSparams_gams_dir_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SN_GAMSparams *arg1 = (SN_GAMSparams *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SN_GAMSparams_gams_dir_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMSparams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_GAMSparams_gams_dir_set" "', argument " "1"" of type '" "SN_GAMSparams *""'"); 
  }
  arg1 = (SN_GAMSparams *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SN_GAMSparams_gams_dir_set" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  if (arg1->gams_dir) free((char*)arg1->gams_dir);
  if (arg2) {
    size_t size = strlen((const char *)(arg2)) + 1;
    arg1->gams_dir = (char *)(char *)memcpy(malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
  } else {
    arg1->gams_dir = 0;
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_SN_GAMSparams_gams_dir_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SN_GAMSparams *arg1 = (SN_GAMSparams *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SN_GAMSparams_gams_dir_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMSparams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_GAMSparams_gams_dir_get" "', argument " "1"" of type '" "SN_GAMSparams *""'"); 
  }
  arg1 = (SN_GAMSparams *)(argp1);
  result = (char *) ((arg1)->gams_dir);
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SN_GAMSparams_filename_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SN_GAMSparams *arg1 = (SN_GAMSparams *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SN_GAMSparams_filename_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMSparams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_GAMSparams_filename_set" "', argument " "1"" of type '" "SN_GAMSparams *""'"); 
  }
  arg1 = (SN_GAMSparams *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SN_GAMSparams_filename_set" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  if (arg1->filename) free((char*)arg1->filename);
  if (arg2) {
    size_t size = strlen((const char *)(arg2)) + 1;
    arg1->filename = (char *)(char *)memcpy(malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
  } else {
    arg1->filename = 0;
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_SN_GAMSparams_filename_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SN_GAMSparams *arg1 = (SN_GAMSparams *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SN_GAMSparams_filename_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMSparams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_GAMSparams_filename_get" "', argument " "1"" of type '" "SN_GAMSparams *""'"); 
  }
  arg1 = (SN_GAMSparams *)(argp1);
  result = (char *) ((arg1)->filename);
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SN_GAMSparams_filename_suffix_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SN_GAMSparams *arg1 = (SN_GAMSparams *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SN_GAMSparams_filename_suffix_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMSparams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_GAMSparams_filename_suffix_set" "', argument " "1"" of type '" "SN_GAMSparams *""'"); 
  }
  arg1 = (SN_GAMSparams *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SN_GAMSparams_filename_suffix_set" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  if (arg1->filename_suffix) free((char*)arg1->filename_suffix);
  if (arg2) {
    size_t size = strlen((const char *)(arg2)) + 1;
    arg1->filename_suffix = (char *)(char *)memcpy(malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
  } else {
    arg1->filename_suffix = 0;
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_SN_GAMSparams_filename_suffix_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SN_GAMSparams *arg1 = (SN_GAMSparams *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SN_GAMSparams_filename_suffix_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMSparams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_GAMSparams_filename_suffix_get" "', argument " "1"" of type '" "SN_GAMSparams *""'"); 
  }
  arg1 = (SN_GAMSparams *)(argp1);
  result = (char *) ((arg1)->filename_suffix);
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SN_GAMSparams_opt_str_list_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SN_GAMSparams *arg1 = (SN_GAMSparams *) 0 ;
  GAMS_opt_str *arg2 = (GAMS_opt_str *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SN_GAMSparams_opt_str_list_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMSparams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_GAMSparams_opt_str_list_set" "', argument " "1"" of type '" "SN_GAMSparams *""'"); 
  }
  arg1 = (SN_GAMSparams *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_GAMS_opt_str_, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SN_GAMSparams_opt_str_list_set" "', argument " "2"" of type '" "GAMS_opt_str *""'"); 
  }
  arg2 = (GAMS_opt_str *)(argp2);
  if (arg1) (arg1)->opt_str_list = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SN_GAMSparams_opt_str_list_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SN_GAMSparams *arg1 = (SN_GAMSparams *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  GAMS_opt_str *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SN_GAMSparams_opt_str_list_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMSparams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_GAMSparams_opt_str_list_get" "', argument " "1"" of type '" "SN_GAMSparams *""'"); 
  }
  arg1 = (SN_GAMSparams *)(argp1);
  result = (GAMS_opt_str *) ((arg1)->opt_str_list);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GAMS_opt_str_, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SN_GAMSparams_opt_bool_list_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SN_GAMSparams *arg1 = (SN_GAMSparams *) 0 ;
  GAMS_opt_bool *arg2 = (GAMS_opt_bool *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SN_GAMSparams_opt_bool_list_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMSparams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_GAMSparams_opt_bool_list_set" "', argument " "1"" of type '" "SN_GAMSparams *""'"); 
  }
  arg1 = (SN_GAMSparams *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_GAMS_opt_bool_, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SN_GAMSparams_opt_bool_list_set" "', argument " "2"" of type '" "GAMS_opt_bool *""'"); 
  }
  arg2 = (GAMS_opt_bool *)(argp2);
  if (arg1) (arg1)->opt_bool_list = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SN_GAMSparams_opt_bool_list_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SN_GAMSparams *arg1 = (SN_GAMSparams *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  GAMS_opt_bool *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SN_GAMSparams_opt_bool_list_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMSparams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_GAMSparams_opt_bool_list_get" "', argument " "1"" of type '" "SN_GAMSparams *""'"); 
  }
  arg1 = (SN_GAMSparams *)(argp1);
  result = (GAMS_opt_bool *) ((arg1)->opt_bool_list);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GAMS_opt_bool_, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SN_GAMSparams_opt_int_list_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SN_GAMSparams *arg1 = (SN_GAMSparams *) 0 ;
  GAMS_opt_int *arg2 = (GAMS_opt_int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SN_GAMSparams_opt_int_list_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMSparams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_GAMSparams_opt_int_list_set" "', argument " "1"" of type '" "SN_GAMSparams *""'"); 
  }
  arg1 = (SN_GAMSparams *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_GAMS_opt_int_, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SN_GAMSparams_opt_int_list_set" "', argument " "2"" of type '" "GAMS_opt_int *""'"); 
  }
  arg2 = (GAMS_opt_int *)(argp2);
  if (arg1) (arg1)->opt_int_list = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SN_GAMSparams_opt_int_list_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SN_GAMSparams *arg1 = (SN_GAMSparams *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  GAMS_opt_int *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SN_GAMSparams_opt_int_list_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMSparams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_GAMSparams_opt_int_list_get" "', argument " "1"" of type '" "SN_GAMSparams *""'"); 
  }
  arg1 = (SN_GAMSparams *)(argp1);
  result = (GAMS_opt_int *) ((arg1)->opt_int_list);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GAMS_opt_int_, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SN_GAMSparams_opt_double_list_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SN_GAMSparams *arg1 = (SN_GAMSparams *) 0 ;
  GAMS_opt_double *arg2 = (GAMS_opt_double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SN_GAMSparams_opt_double_list_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMSparams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_GAMSparams_opt_double_list_set" "', argument " "1"" of type '" "SN_GAMSparams *""'"); 
  }
  arg1 = (SN_GAMSparams *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_GAMS_opt_double_, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SN_GAMSparams_opt_double_list_set" "', argument " "2"" of type '" "GAMS_opt_double *""'"); 
  }
  arg2 = (GAMS_opt_double *)(argp2);
  if (arg1) (arg1)->opt_double_list = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SN_GAMSparams_opt_double_list_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SN_GAMSparams *arg1 = (SN_GAMSparams *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  GAMS_opt_double *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SN_GAMSparams_opt_double_list_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMSparams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_GAMSparams_opt_double_list_get" "', argument " "1"" of type '" "SN_GAMSparams *""'"); 
  }
  arg1 = (SN_GAMSparams *)(argp1);
  result = (GAMS_opt_double *) ((arg1)->opt_double_list);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GAMS_opt_double_, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SN_GAMSparams(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SN_GAMSparams *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_SN_GAMSparams",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SN_GAMSparams" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (SN_GAMSparams *)new_SN_GAMSparams(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SN_GAMSparams, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SN_GAMSparams_gamsdir_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SN_GAMSparams *arg1 = (SN_GAMSparams *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SN_GAMSparams_gamsdir_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMSparams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_GAMSparams_gamsdir_set" "', argument " "1"" of type '" "SN_GAMSparams *""'"); 
  }
  arg1 = (SN_GAMSparams *)(argp1);
  arg2 = obj1;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        SN_GAMSparams_gamsdir_set(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SN_GAMSparams_modeldir_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SN_GAMSparams *arg1 = (SN_GAMSparams *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SN_GAMSparams_modeldir_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMSparams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_GAMSparams_modeldir_set" "', argument " "1"" of type '" "SN_GAMSparams *""'"); 
  }
  arg1 = (SN_GAMSparams *)(argp1);
  arg2 = obj1;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        SN_GAMSparams_modeldir_set(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SN_GAMSparams(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SN_GAMSparams *arg1 = (SN_GAMSparams *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_SN_GAMSparams",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMSparams, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SN_GAMSparams" "', argument " "1"" of type '" "SN_GAMSparams *""'"); 
  }
  arg1 = (SN_GAMSparams *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        delete_SN_GAMSparams(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SN_GAMSparams_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_SN_GAMSparams, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_SN_GAMS_NM_gdx_mat_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SN_GAMS_NM_gdx_ *arg1 = (struct SN_GAMS_NM_gdx_ *) 0 ;
  NumericsMatrix *arg2 = (NumericsMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array_2 = NULL ;
  int array_ctrl_2 = 0 ;
  PyArrayObject *array_i_2 = NULL ;
  int array_i_ctrl_2 = 0 ;
  PyArrayObject *array_p_2 = NULL ;
  int array_p_ctrl_2 = 0 ;
  int alloc_ctrl_2 = 0 ;
  NumericsMatrix *nummat2 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SN_GAMS_NM_gdx_mat_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMS_NM_gdx_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_GAMS_NM_gdx_mat_set" "', argument " "1"" of type '" "struct SN_GAMS_NM_gdx_ *""'"); 
  }
  arg1 = (struct SN_GAMS_NM_gdx_ *)(argp1);
  {
    arg2 = NM_convert_from_python(obj1, &nummat2, &array_2, &array_ctrl_2, &array_i_2, &array_i_ctrl_2, &array_p_2, &array_p_ctrl_2, &alloc_ctrl_2);
    
    
    
    
    
    if (!arg2) {
      SWIG_fail; 
    }
  }
  {
    //  %typemap(memberin) (NumericsMatrix*)
    // perform a deep copy
    if (!arg1->mat) {
      arg1->mat = NM_create(arg2->storageType, arg2->size0, arg2->size1); 
    }
    NM_copy(arg2, arg1->mat);
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_SN_GAMS_NM_gdx_mat_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SN_GAMS_NM_gdx_ *arg1 = (struct SN_GAMS_NM_gdx_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  NumericsMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SN_GAMS_NM_gdx_mat_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMS_NM_gdx_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_GAMS_NM_gdx_mat_get" "', argument " "1"" of type '" "struct SN_GAMS_NM_gdx_ *""'"); 
  }
  arg1 = (struct SN_GAMS_NM_gdx_ *)(argp1);
  result = (NumericsMatrix *) ((arg1)->mat);
  {
    if (strcmp("SN_GAMS_NM_gdx_mat_get", "new_NumericsMatrix"))
    {
      resultobj = NM_to_python(result);
      
      
      
      if (!resultobj) SWIG_fail;
    }
    else
    {
      resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NumericsMatrix, SWIG_POINTER_NEW |  0 );
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SN_GAMS_NM_gdx_name_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SN_GAMS_NM_gdx_ *arg1 = (struct SN_GAMS_NM_gdx_ *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SN_GAMS_NM_gdx_name_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMS_NM_gdx_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_GAMS_NM_gdx_name_set" "', argument " "1"" of type '" "struct SN_GAMS_NM_gdx_ *""'"); 
  }
  arg1 = (struct SN_GAMS_NM_gdx_ *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SN_GAMS_NM_gdx_name_set" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  if (arg1->name) free((char*)arg1->name);
  if (arg2) {
    size_t size = strlen((const char *)(arg2)) + 1;
    arg1->name = (char *)(char *)memcpy(malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
  } else {
    arg1->name = 0;
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_SN_GAMS_NM_gdx_name_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SN_GAMS_NM_gdx_ *arg1 = (struct SN_GAMS_NM_gdx_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SN_GAMS_NM_gdx_name_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMS_NM_gdx_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_GAMS_NM_gdx_name_get" "', argument " "1"" of type '" "struct SN_GAMS_NM_gdx_ *""'"); 
  }
  arg1 = (struct SN_GAMS_NM_gdx_ *)(argp1);
  result = (char *) ((arg1)->name);
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SN_GAMS_NM_gdx_next_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SN_GAMS_NM_gdx_ *arg1 = (struct SN_GAMS_NM_gdx_ *) 0 ;
  struct SN_GAMS_NM_gdx_ *arg2 = (struct SN_GAMS_NM_gdx_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SN_GAMS_NM_gdx_next_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMS_NM_gdx_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_GAMS_NM_gdx_next_set" "', argument " "1"" of type '" "struct SN_GAMS_NM_gdx_ *""'"); 
  }
  arg1 = (struct SN_GAMS_NM_gdx_ *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SN_GAMS_NM_gdx_, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SN_GAMS_NM_gdx_next_set" "', argument " "2"" of type '" "struct SN_GAMS_NM_gdx_ *""'"); 
  }
  arg2 = (struct SN_GAMS_NM_gdx_ *)(argp2);
  if (arg1) (arg1)->next = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SN_GAMS_NM_gdx_next_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SN_GAMS_NM_gdx_ *arg1 = (struct SN_GAMS_NM_gdx_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  struct SN_GAMS_NM_gdx_ *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SN_GAMS_NM_gdx_next_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMS_NM_gdx_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_GAMS_NM_gdx_next_get" "', argument " "1"" of type '" "struct SN_GAMS_NM_gdx_ *""'"); 
  }
  arg1 = (struct SN_GAMS_NM_gdx_ *)(argp1);
  result = (struct SN_GAMS_NM_gdx_ *) ((arg1)->next);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SN_GAMS_NM_gdx_, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SN_GAMS_NM_gdx(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SN_GAMS_NM_gdx_ *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_SN_GAMS_NM_gdx")) SWIG_fail;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct SN_GAMS_NM_gdx_ *)calloc(1, sizeof(struct SN_GAMS_NM_gdx_));
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SN_GAMS_NM_gdx_, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SN_GAMS_NM_gdx(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SN_GAMS_NM_gdx_ *arg1 = (struct SN_GAMS_NM_gdx_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_SN_GAMS_NM_gdx",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMS_NM_gdx_, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SN_GAMS_NM_gdx" "', argument " "1"" of type '" "struct SN_GAMS_NM_gdx_ *""'"); 
  }
  arg1 = (struct SN_GAMS_NM_gdx_ *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        free((char *) arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SN_GAMS_NM_gdx_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_SN_GAMS_NM_gdx_, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_SN_GAMS_NV_gdx_vec_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SN_GAMS_NV_gdx_ *arg1 = (struct SN_GAMS_NV_gdx_ *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SN_GAMS_NV_gdx_vec_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMS_NV_gdx_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_GAMS_NV_gdx_vec_set" "', argument " "1"" of type '" "struct SN_GAMS_NV_gdx_ *""'"); 
  }
  arg1 = (struct SN_GAMS_NV_gdx_ *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_double, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SN_GAMS_NV_gdx_vec_set" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = (double *)(argp2);
  if (arg1) (arg1)->vec = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SN_GAMS_NV_gdx_vec_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SN_GAMS_NV_gdx_ *arg1 = (struct SN_GAMS_NV_gdx_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SN_GAMS_NV_gdx_vec_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMS_NV_gdx_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_GAMS_NV_gdx_vec_get" "', argument " "1"" of type '" "struct SN_GAMS_NV_gdx_ *""'"); 
  }
  arg1 = (struct SN_GAMS_NV_gdx_ *)(argp1);
  result = (double *) ((arg1)->vec);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SN_GAMS_NV_gdx_name_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SN_GAMS_NV_gdx_ *arg1 = (struct SN_GAMS_NV_gdx_ *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SN_GAMS_NV_gdx_name_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMS_NV_gdx_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_GAMS_NV_gdx_name_set" "', argument " "1"" of type '" "struct SN_GAMS_NV_gdx_ *""'"); 
  }
  arg1 = (struct SN_GAMS_NV_gdx_ *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SN_GAMS_NV_gdx_name_set" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  if (arg1->name) free((char*)arg1->name);
  if (arg2) {
    size_t size = strlen((const char *)(arg2)) + 1;
    arg1->name = (char *)(char *)memcpy(malloc((size)*sizeof(char)), (const char *)(arg2), sizeof(char)*(size));
  } else {
    arg1->name = 0;
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_SN_GAMS_NV_gdx_name_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SN_GAMS_NV_gdx_ *arg1 = (struct SN_GAMS_NV_gdx_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SN_GAMS_NV_gdx_name_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMS_NV_gdx_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_GAMS_NV_gdx_name_get" "', argument " "1"" of type '" "struct SN_GAMS_NV_gdx_ *""'"); 
  }
  arg1 = (struct SN_GAMS_NV_gdx_ *)(argp1);
  result = (char *) ((arg1)->name);
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SN_GAMS_NV_gdx_size_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SN_GAMS_NV_gdx_ *arg1 = (struct SN_GAMS_NV_gdx_ *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SN_GAMS_NV_gdx_size_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMS_NV_gdx_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_GAMS_NV_gdx_size_set" "', argument " "1"" of type '" "struct SN_GAMS_NV_gdx_ *""'"); 
  }
  arg1 = (struct SN_GAMS_NV_gdx_ *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SN_GAMS_NV_gdx_size_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  if (arg1) (arg1)->size = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SN_GAMS_NV_gdx_size_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SN_GAMS_NV_gdx_ *arg1 = (struct SN_GAMS_NV_gdx_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SN_GAMS_NV_gdx_size_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMS_NV_gdx_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_GAMS_NV_gdx_size_get" "', argument " "1"" of type '" "struct SN_GAMS_NV_gdx_ *""'"); 
  }
  arg1 = (struct SN_GAMS_NV_gdx_ *)(argp1);
  result = (unsigned int) ((arg1)->size);
  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SN_GAMS_NV_gdx_next_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SN_GAMS_NV_gdx_ *arg1 = (struct SN_GAMS_NV_gdx_ *) 0 ;
  struct SN_GAMS_NV_gdx_ *arg2 = (struct SN_GAMS_NV_gdx_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SN_GAMS_NV_gdx_next_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMS_NV_gdx_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_GAMS_NV_gdx_next_set" "', argument " "1"" of type '" "struct SN_GAMS_NV_gdx_ *""'"); 
  }
  arg1 = (struct SN_GAMS_NV_gdx_ *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SN_GAMS_NV_gdx_, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SN_GAMS_NV_gdx_next_set" "', argument " "2"" of type '" "struct SN_GAMS_NV_gdx_ *""'"); 
  }
  arg2 = (struct SN_GAMS_NV_gdx_ *)(argp2);
  if (arg1) (arg1)->next = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SN_GAMS_NV_gdx_next_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SN_GAMS_NV_gdx_ *arg1 = (struct SN_GAMS_NV_gdx_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  struct SN_GAMS_NV_gdx_ *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SN_GAMS_NV_gdx_next_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMS_NV_gdx_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_GAMS_NV_gdx_next_get" "', argument " "1"" of type '" "struct SN_GAMS_NV_gdx_ *""'"); 
  }
  arg1 = (struct SN_GAMS_NV_gdx_ *)(argp1);
  result = (struct SN_GAMS_NV_gdx_ *) ((arg1)->next);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SN_GAMS_NV_gdx_, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SN_GAMS_NV_gdx(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SN_GAMS_NV_gdx_ *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_SN_GAMS_NV_gdx")) SWIG_fail;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct SN_GAMS_NV_gdx_ *)calloc(1, sizeof(struct SN_GAMS_NV_gdx_));
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SN_GAMS_NV_gdx_, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SN_GAMS_NV_gdx(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct SN_GAMS_NV_gdx_ *arg1 = (struct SN_GAMS_NV_gdx_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_SN_GAMS_NV_gdx",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMS_NV_gdx_, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SN_GAMS_NV_gdx" "', argument " "1"" of type '" "struct SN_GAMS_NV_gdx_ *""'"); 
  }
  arg1 = (struct SN_GAMS_NV_gdx_ *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        free((char *) arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SN_GAMS_NV_gdx_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_SN_GAMS_NV_gdx_, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_SN_GAMS_gdx_mat_for_gdx_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SN_GAMS_gdx *arg1 = (SN_GAMS_gdx *) 0 ;
  SN_GAMS_NM_gdx *arg2 = (SN_GAMS_NM_gdx *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SN_GAMS_gdx_mat_for_gdx_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMS_gdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_GAMS_gdx_mat_for_gdx_set" "', argument " "1"" of type '" "SN_GAMS_gdx *""'"); 
  }
  arg1 = (SN_GAMS_gdx *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SN_GAMS_NM_gdx_, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SN_GAMS_gdx_mat_for_gdx_set" "', argument " "2"" of type '" "SN_GAMS_NM_gdx *""'"); 
  }
  arg2 = (SN_GAMS_NM_gdx *)(argp2);
  if (arg1) (arg1)->mat_for_gdx = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SN_GAMS_gdx_mat_for_gdx_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SN_GAMS_gdx *arg1 = (SN_GAMS_gdx *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SN_GAMS_NM_gdx *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SN_GAMS_gdx_mat_for_gdx_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMS_gdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_GAMS_gdx_mat_for_gdx_get" "', argument " "1"" of type '" "SN_GAMS_gdx *""'"); 
  }
  arg1 = (SN_GAMS_gdx *)(argp1);
  result = (SN_GAMS_NM_gdx *) ((arg1)->mat_for_gdx);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SN_GAMS_NM_gdx_, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SN_GAMS_gdx_vec_for_gdx_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SN_GAMS_gdx *arg1 = (SN_GAMS_gdx *) 0 ;
  SN_GAMS_NV_gdx *arg2 = (SN_GAMS_NV_gdx *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SN_GAMS_gdx_vec_for_gdx_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMS_gdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_GAMS_gdx_vec_for_gdx_set" "', argument " "1"" of type '" "SN_GAMS_gdx *""'"); 
  }
  arg1 = (SN_GAMS_gdx *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SN_GAMS_NV_gdx_, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SN_GAMS_gdx_vec_for_gdx_set" "', argument " "2"" of type '" "SN_GAMS_NV_gdx *""'"); 
  }
  arg2 = (SN_GAMS_NV_gdx *)(argp2);
  if (arg1) (arg1)->vec_for_gdx = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SN_GAMS_gdx_vec_for_gdx_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SN_GAMS_gdx *arg1 = (SN_GAMS_gdx *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SN_GAMS_NV_gdx *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SN_GAMS_gdx_vec_for_gdx_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMS_gdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_GAMS_gdx_vec_for_gdx_get" "', argument " "1"" of type '" "SN_GAMS_gdx *""'"); 
  }
  arg1 = (SN_GAMS_gdx *)(argp1);
  result = (SN_GAMS_NV_gdx *) ((arg1)->vec_for_gdx);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SN_GAMS_NV_gdx_, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SN_GAMS_gdx_vec_from_gdx_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SN_GAMS_gdx *arg1 = (SN_GAMS_gdx *) 0 ;
  SN_GAMS_NV_gdx *arg2 = (SN_GAMS_NV_gdx *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SN_GAMS_gdx_vec_from_gdx_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMS_gdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_GAMS_gdx_vec_from_gdx_set" "', argument " "1"" of type '" "SN_GAMS_gdx *""'"); 
  }
  arg1 = (SN_GAMS_gdx *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SN_GAMS_NV_gdx_, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SN_GAMS_gdx_vec_from_gdx_set" "', argument " "2"" of type '" "SN_GAMS_NV_gdx *""'"); 
  }
  arg2 = (SN_GAMS_NV_gdx *)(argp2);
  if (arg1) (arg1)->vec_from_gdx = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SN_GAMS_gdx_vec_from_gdx_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SN_GAMS_gdx *arg1 = (SN_GAMS_gdx *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SN_GAMS_NV_gdx *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SN_GAMS_gdx_vec_from_gdx_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMS_gdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_GAMS_gdx_vec_from_gdx_get" "', argument " "1"" of type '" "SN_GAMS_gdx *""'"); 
  }
  arg1 = (SN_GAMS_gdx *)(argp1);
  result = (SN_GAMS_NV_gdx *) ((arg1)->vec_from_gdx);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SN_GAMS_NV_gdx_, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SN_GAMS_gdx(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SN_GAMS_gdx *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_SN_GAMS_gdx")) SWIG_fail;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (SN_GAMS_gdx *)calloc(1, sizeof(SN_GAMS_gdx));
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SN_GAMS_gdx, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SN_GAMS_gdx(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SN_GAMS_gdx *arg1 = (SN_GAMS_gdx *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_SN_GAMS_gdx",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMS_gdx, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SN_GAMS_gdx" "', argument " "1"" of type '" "SN_GAMS_gdx *""'"); 
  }
  arg1 = (SN_GAMS_gdx *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        free((char *) arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SN_GAMS_gdx_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_SN_GAMS_gdx, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_GAMSP_get_filename(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  void *arg1 = (void *) 0 ;
  int res1 ;
  PyObject * obj0 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:GAMSP_get_filename",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0,SWIG_as_voidptrptr(&arg1), 0, 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GAMSP_get_filename" "', argument " "1"" of type '" "void const *""'"); 
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (char *)GAMSP_get_filename((void const *)arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GAMSP_set_filename(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  void *arg1 = (void *) 0 ;
  char *arg2 = (char *) 0 ;
  int res1 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:GAMSP_set_filename",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0,SWIG_as_voidptrptr(&arg1), 0, 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GAMSP_set_filename" "', argument " "1"" of type '" "void *""'"); 
  }
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GAMSP_set_filename" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        GAMSP_set_filename(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_GAMSP_get_filename_suffix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  void *arg1 = (void *) 0 ;
  int res1 ;
  PyObject * obj0 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:GAMSP_get_filename_suffix",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0,SWIG_as_voidptrptr(&arg1), 0, 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GAMSP_get_filename_suffix" "', argument " "1"" of type '" "void const *""'"); 
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (char *)GAMSP_get_filename_suffix((void const *)arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GAMSP_set_filename_suffix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  void *arg1 = (void *) 0 ;
  char *arg2 = (char *) 0 ;
  int res1 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:GAMSP_set_filename_suffix",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0,SWIG_as_voidptrptr(&arg1), 0, 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GAMSP_set_filename_suffix" "', argument " "1"" of type '" "void *""'"); 
  }
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GAMSP_set_filename_suffix" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        GAMSP_set_filename_suffix(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_SN_free_SN_GAMS_gdx(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SN_GAMS_gdx *arg1 = (SN_GAMS_gdx *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SN_free_SN_GAMS_gdx",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMS_gdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_free_SN_GAMS_gdx" "', argument " "1"" of type '" "SN_GAMS_gdx *""'"); 
  }
  arg1 = (SN_GAMS_gdx *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        SN_free_SN_GAMS_gdx(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SN_GAMS_add_NM_to_gdx(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SN_GAMS_gdx *arg1 = (SN_GAMS_gdx *) 0 ;
  NumericsMatrix *arg2 = (NumericsMatrix *) 0 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array_2 = NULL ;
  int array_ctrl_2 = 0 ;
  PyArrayObject *array_i_2 = NULL ;
  int array_i_ctrl_2 = 0 ;
  PyArrayObject *array_p_2 = NULL ;
  int array_p_ctrl_2 = 0 ;
  int alloc_ctrl_2 = 0 ;
  NumericsMatrix *nummat2 = NULL ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:SN_GAMS_add_NM_to_gdx",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMS_gdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_GAMS_add_NM_to_gdx" "', argument " "1"" of type '" "SN_GAMS_gdx *""'"); 
  }
  arg1 = (SN_GAMS_gdx *)(argp1);
  {
    arg2 = NM_convert_from_python(obj1, &nummat2, &array_2, &array_ctrl_2, &array_i_2, &array_i_ctrl_2, &array_p_2, &array_p_ctrl_2, &alloc_ctrl_2);
    
    
    
    
    
    if (!arg2) {
      SWIG_fail; 
    }
  }
  res3 = SWIG_AsCharPtrAndSize(obj2, &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SN_GAMS_add_NM_to_gdx" "', argument " "3"" of type '" "char *""'");
  }
  arg3 = (char *)(buf3);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        SN_GAMS_add_NM_to_gdx(arg1,arg2,arg3);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return NULL;
}


SWIGINTERN PyObject *_wrap_SN_GAMS_add_NV_to_gdx(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SN_GAMS_gdx *arg1 = (SN_GAMS_gdx *) 0 ;
  double *arg2 = (double *) 0 ;
  char *arg3 = (char *) 0 ;
  unsigned int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:SN_GAMS_add_NV_to_gdx",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMS_gdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_GAMS_add_NV_to_gdx" "', argument " "1"" of type '" "SN_GAMS_gdx *""'"); 
  }
  arg1 = (SN_GAMS_gdx *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SN_GAMS_add_NV_to_gdx" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = (double *)(argp2);
  res3 = SWIG_AsCharPtrAndSize(obj2, &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SN_GAMS_add_NV_to_gdx" "', argument " "3"" of type '" "char *""'");
  }
  arg3 = (char *)(buf3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SN_GAMS_add_NV_to_gdx" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = (unsigned int)(val4);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        SN_GAMS_add_NV_to_gdx(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return resultobj;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return NULL;
}


SWIGINTERN PyObject *_wrap_SN_GAMS_add_NV_from_gdx(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SN_GAMS_gdx *arg1 = (SN_GAMS_gdx *) 0 ;
  double *arg2 = (double *) 0 ;
  char *arg3 = (char *) 0 ;
  unsigned int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:SN_GAMS_add_NV_from_gdx",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SN_GAMS_gdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SN_GAMS_add_NV_from_gdx" "', argument " "1"" of type '" "SN_GAMS_gdx *""'"); 
  }
  arg1 = (SN_GAMS_gdx *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SN_GAMS_add_NV_from_gdx" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = (double *)(argp2);
  res3 = SWIG_AsCharPtrAndSize(obj2, &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SN_GAMS_add_NV_from_gdx" "', argument " "3"" of type '" "char *""'");
  }
  arg3 = (char *)(buf3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SN_GAMS_add_NV_from_gdx" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = (unsigned int)(val4);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        SN_GAMS_add_NV_from_gdx(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return resultobj;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return NULL;
}


SWIGINTERN PyObject *_wrap_GlobalFrictionContactProblem_dimension_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GlobalFrictionContactProblem *arg1 = (struct GlobalFrictionContactProblem *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:GlobalFrictionContactProblem_dimension_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GlobalFrictionContactProblem_dimension_set" "', argument " "1"" of type '" "struct GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (struct GlobalFrictionContactProblem *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GlobalFrictionContactProblem_dimension_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->dimension = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GlobalFrictionContactProblem_dimension_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GlobalFrictionContactProblem *arg1 = (struct GlobalFrictionContactProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:GlobalFrictionContactProblem_dimension_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GlobalFrictionContactProblem_dimension_get" "', argument " "1"" of type '" "struct GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (struct GlobalFrictionContactProblem *)(argp1);
  result = (int) ((arg1)->dimension);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GlobalFrictionContactProblem_numberOfContacts_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GlobalFrictionContactProblem *arg1 = (struct GlobalFrictionContactProblem *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:GlobalFrictionContactProblem_numberOfContacts_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GlobalFrictionContactProblem_numberOfContacts_set" "', argument " "1"" of type '" "struct GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (struct GlobalFrictionContactProblem *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GlobalFrictionContactProblem_numberOfContacts_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->numberOfContacts = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GlobalFrictionContactProblem_numberOfContacts_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GlobalFrictionContactProblem *arg1 = (struct GlobalFrictionContactProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:GlobalFrictionContactProblem_numberOfContacts_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GlobalFrictionContactProblem_numberOfContacts_get" "', argument " "1"" of type '" "struct GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (struct GlobalFrictionContactProblem *)(argp1);
  result = (int) ((arg1)->numberOfContacts);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GlobalFrictionContactProblem_M_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GlobalFrictionContactProblem *arg1 = (struct GlobalFrictionContactProblem *) 0 ;
  NumericsMatrix *arg2 = (NumericsMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array_2 = NULL ;
  int array_ctrl_2 = 0 ;
  PyArrayObject *array_i_2 = NULL ;
  int array_i_ctrl_2 = 0 ;
  PyArrayObject *array_p_2 = NULL ;
  int array_p_ctrl_2 = 0 ;
  int alloc_ctrl_2 = 0 ;
  NumericsMatrix *nummat2 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:GlobalFrictionContactProblem_M_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GlobalFrictionContactProblem_M_set" "', argument " "1"" of type '" "struct GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (struct GlobalFrictionContactProblem *)(argp1);
  {
    arg2 = NM_convert_from_python(obj1, &nummat2, &array_2, &array_ctrl_2, &array_i_2, &array_i_ctrl_2, &array_p_2, &array_p_ctrl_2, &alloc_ctrl_2);
    
    
    
    
    
    if (!arg2) {
      SWIG_fail; 
    }
  }
  {
    //  %typemap(memberin) (NumericsMatrix*)
    // perform a deep copy
    if (!arg1->M) {
      arg1->M = NM_create(arg2->storageType, arg2->size0, arg2->size1); 
    }
    NM_copy(arg2, arg1->M);
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_GlobalFrictionContactProblem_M_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GlobalFrictionContactProblem *arg1 = (struct GlobalFrictionContactProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  NumericsMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:GlobalFrictionContactProblem_M_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GlobalFrictionContactProblem_M_get" "', argument " "1"" of type '" "struct GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (struct GlobalFrictionContactProblem *)(argp1);
  result = (NumericsMatrix *) ((arg1)->M);
  {
    if (strcmp("GlobalFrictionContactProblem_M_get", "new_NumericsMatrix"))
    {
      resultobj = NM_to_python(result);
      
      
      
      if (!resultobj) SWIG_fail;
    }
    else
    {
      resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NumericsMatrix, SWIG_POINTER_NEW |  0 );
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GlobalFrictionContactProblem_H_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GlobalFrictionContactProblem *arg1 = (struct GlobalFrictionContactProblem *) 0 ;
  NumericsMatrix *arg2 = (NumericsMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array_2 = NULL ;
  int array_ctrl_2 = 0 ;
  PyArrayObject *array_i_2 = NULL ;
  int array_i_ctrl_2 = 0 ;
  PyArrayObject *array_p_2 = NULL ;
  int array_p_ctrl_2 = 0 ;
  int alloc_ctrl_2 = 0 ;
  NumericsMatrix *nummat2 = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:GlobalFrictionContactProblem_H_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GlobalFrictionContactProblem_H_set" "', argument " "1"" of type '" "struct GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (struct GlobalFrictionContactProblem *)(argp1);
  {
    arg2 = NM_convert_from_python(obj1, &nummat2, &array_2, &array_ctrl_2, &array_i_2, &array_i_ctrl_2, &array_p_2, &array_p_ctrl_2, &alloc_ctrl_2);
    
    
    
    
    
    if (!arg2) {
      SWIG_fail; 
    }
  }
  {
    //  %typemap(memberin) (NumericsMatrix*)
    // perform a deep copy
    if (!arg1->H) {
      arg1->H = NM_create(arg2->storageType, arg2->size0, arg2->size1); 
    }
    NM_copy(arg2, arg1->H);
  }
  resultobj = SWIG_Py_Void();
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (NumericsMatrix*)
    if(array_ctrl_2 && array_2) {
      Py_DECREF(array_2); 
    };
    if(array_i_ctrl_2 && array_i_2) {
      Py_DECREF(array_i_2); 
    };
    if(array_p_ctrl_2 && array_p_2) {
      Py_DECREF(array_p_2); 
    };
    
    if (nummat2)
    {
      if (!NM_clean(nummat2, alloc_ctrl_2)) {
        return NULL; 
      }
      NM_free(nummat2);
      free(nummat2);
    }
    
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_GlobalFrictionContactProblem_H_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GlobalFrictionContactProblem *arg1 = (struct GlobalFrictionContactProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  NumericsMatrix *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:GlobalFrictionContactProblem_H_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GlobalFrictionContactProblem_H_get" "', argument " "1"" of type '" "struct GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (struct GlobalFrictionContactProblem *)(argp1);
  result = (NumericsMatrix *) ((arg1)->H);
  {
    if (strcmp("GlobalFrictionContactProblem_H_get", "new_NumericsMatrix"))
    {
      resultobj = NM_to_python(result);
      
      
      
      if (!resultobj) SWIG_fail;
    }
    else
    {
      resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_NumericsMatrix, SWIG_POINTER_NEW |  0 );
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GlobalFrictionContactProblem_q_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GlobalFrictionContactProblem *arg1 = (struct GlobalFrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:GlobalFrictionContactProblem_q_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GlobalFrictionContactProblem_q_set" "', argument " "1"" of type '" "struct GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (struct GlobalFrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    // Still some dark magic :( --xhub
    char msg[1024];
    assert(arg1);
    if (!arg1->M)
    {
      SWIG_exception_fail(SWIG_RuntimeError, "M is not initialized, it sould be done first!");
    }
    
    int size = arg1->M->size0;
    if (size !=  array_size(array2, 0))
    {
      snprintf(msg, sizeof(msg), "Size of q is %ld, but the size of M is %d! Both should be equal!\n", array_size(array2, 0), size);
      SWIG_exception_fail(SWIG_RuntimeError, msg);
    }
    
    if (!arg1->q) {
      arg1->q = (double*)malloc(size * sizeof(double)); 
    }
    memcpy(arg1->q, arg2, size * sizeof(double));
    
  }
  resultobj = SWIG_Py_Void();
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_GlobalFrictionContactProblem_q_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GlobalFrictionContactProblem *arg1 = (struct GlobalFrictionContactProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:GlobalFrictionContactProblem_q_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GlobalFrictionContactProblem_q_get" "', argument " "1"" of type '" "struct GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (struct GlobalFrictionContactProblem *)(argp1);
  result = (double *) ((arg1)->q);
  {
    if (!arg1->M) {
      SWIG_exception_fail(SWIG_RuntimeError, "M is not present, don't known the size"); 
    }
    
    if (result)
    {
      PyObject *obj;
      C_to_target_lang1(obj, arg1->M->size0, result, SWIG_fail);
      resultobj = obj;
    }
    else
    SWIG_fail;
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GlobalFrictionContactProblem_b_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GlobalFrictionContactProblem *arg1 = (struct GlobalFrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:GlobalFrictionContactProblem_b_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GlobalFrictionContactProblem_b_set" "', argument " "1"" of type '" "struct GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (struct GlobalFrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    // Still some dark magic :( --xhub
    char msg[1024];
    assert(arg1);
    if (!arg1->H)
    {
      SWIG_exception_fail(SWIG_RuntimeError, "H is not initialized, it sould be done first!");
    }
    
    int size = arg1->H->size1;
    if (size !=  array_size((PyArrayObject*)array2, 0))
    {
      snprintf(msg, sizeof(msg), "Size of b is %ld, but the size of H is %d! Both should be equal!\n", array_size((PyArrayObject*)array2, 0), size);
      SWIG_exception_fail(SWIG_RuntimeError, msg);
    }
    
    if (!arg1->b) {
      arg1->b = (double*)malloc(size * sizeof(double)); 
    }
    memcpy(arg1->b, arg2, size * sizeof(double));
    
  }
  resultobj = SWIG_Py_Void();
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_GlobalFrictionContactProblem_b_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GlobalFrictionContactProblem *arg1 = (struct GlobalFrictionContactProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:GlobalFrictionContactProblem_b_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GlobalFrictionContactProblem_b_get" "', argument " "1"" of type '" "struct GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (struct GlobalFrictionContactProblem *)(argp1);
  result = (double *) ((arg1)->b);
  {
    if (!arg1->H) {
      SWIG_exception_fail(SWIG_RuntimeError, "H is not present, don't known the size"); 
    }
    
    if (result)
    {
      PyObject *obj;
      C_to_target_lang1(obj, arg1->H->size1, result, SWIG_fail);
      resultobj = obj;
    }
    else
    SWIG_fail;
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GlobalFrictionContactProblem_mu_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GlobalFrictionContactProblem *arg1 = (struct GlobalFrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:GlobalFrictionContactProblem_mu_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GlobalFrictionContactProblem_mu_set" "', argument " "1"" of type '" "struct GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (struct GlobalFrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    // Still some dark magic :( --xhub
    if (arg1->numberOfContacts <= 0)
    {
      SWIG_exception(SWIG_RuntimeError, "numberOfContacts is not set, it sould be done first!");
      SWIG_fail;
    }
    
    if (arg1->numberOfContacts !=  array_size(array2, 0))
    {
      char msg[1024];
      snprintf(msg, sizeof(msg), "Size of mu is %ld, but the number of contacts is %d! Both should be equal!\n", array_size(array2, 0), arg1->numberOfContacts);
      SWIG_exception_fail(SWIG_ValueError, msg);
    }
    
    if (!arg1->mu) {
      arg1->mu = (double*)malloc(arg1->numberOfContacts * sizeof(double)); 
    }
    memcpy(arg1->mu, arg2, arg1->numberOfContacts * sizeof(double));
    
  }
  resultobj = SWIG_Py_Void();
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_GlobalFrictionContactProblem_mu_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GlobalFrictionContactProblem *arg1 = (struct GlobalFrictionContactProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:GlobalFrictionContactProblem_mu_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GlobalFrictionContactProblem_mu_get" "', argument " "1"" of type '" "struct GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (struct GlobalFrictionContactProblem *)(argp1);
  result = (double *) ((arg1)->mu);
  {
    if (arg1->numberOfContacts <= 0) {
      SWIG_exception_fail(SWIG_RuntimeError, "numberOfContacts is not set"); 
    }
    
    if (result)
    {
      PyObject *obj;
      C_to_target_lang1(obj, arg1->numberOfContacts, result, SWIG_fail);
      resultobj = obj;
    }
    else
    SWIG_fail;
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GlobalFrictionContactProblem_env_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GlobalFrictionContactProblem *arg1 = (struct GlobalFrictionContactProblem *) 0 ;
  void *arg2 = (void *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:GlobalFrictionContactProblem_env_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GlobalFrictionContactProblem_env_set" "', argument " "1"" of type '" "struct GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (struct GlobalFrictionContactProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1,SWIG_as_voidptrptr(&arg2), 0, SWIG_POINTER_DISOWN);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GlobalFrictionContactProblem_env_set" "', argument " "2"" of type '" "void *""'"); 
  }
  if (arg1) (arg1)->env = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GlobalFrictionContactProblem_env_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GlobalFrictionContactProblem *arg1 = (struct GlobalFrictionContactProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  void *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:GlobalFrictionContactProblem_env_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GlobalFrictionContactProblem_env_get" "', argument " "1"" of type '" "struct GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (struct GlobalFrictionContactProblem *)(argp1);
  result = (void *) ((arg1)->env);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_GlobalFrictionContactProblem__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GlobalFrictionContactProblem *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_GlobalFrictionContactProblem")) SWIG_fail;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct GlobalFrictionContactProblem *)new_GlobalFrictionContactProblem__SWIG_0();
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GlobalFrictionContactProblem, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_GlobalFrictionContactProblem__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  PyObject * obj0 = 0 ;
  struct GlobalFrictionContactProblem *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_GlobalFrictionContactProblem",&obj0)) SWIG_fail;
  arg1 = obj0;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct GlobalFrictionContactProblem *)new_GlobalFrictionContactProblem__SWIG_1(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GlobalFrictionContactProblem, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_GlobalFrictionContactProblem__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  PyObject *arg4 = (PyObject *) 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  struct GlobalFrictionContactProblem *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:new_GlobalFrictionContactProblem",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  arg1 = obj0;
  arg2 = obj1;
  arg3 = obj2;
  arg4 = obj3;
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (struct GlobalFrictionContactProblem *)new_GlobalFrictionContactProblem__SWIG_2(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GlobalFrictionContactProblem, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_GlobalFrictionContactProblem(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  Py_ssize_t ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = args ? PyObject_Length(args) : 0;
  for (ii = 0; (ii < 4) && (ii < argc); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_GlobalFrictionContactProblem__SWIG_0(self, args);
  }
  if (argc == 1) {
    int _v;
    _v = (argv[0] != 0);
    if (_v) {
      return _wrap_new_GlobalFrictionContactProblem__SWIG_1(self, args);
    }
  }
  if (argc == 4) {
    int _v;
    _v = (argv[0] != 0);
    if (_v) {
      _v = (argv[1] != 0);
      if (_v) {
        _v = (argv[2] != 0);
        if (_v) {
          _v = (argv[3] != 0);
          if (_v) {
            return _wrap_new_GlobalFrictionContactProblem__SWIG_2(self, args);
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_GlobalFrictionContactProblem'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    GlobalFrictionContactProblem::GlobalFrictionContactProblem()\n"
    "    GlobalFrictionContactProblem::GlobalFrictionContactProblem(PyObject *)\n"
    "    GlobalFrictionContactProblem::GlobalFrictionContactProblem(PyObject *,PyObject *,PyObject *,PyObject *)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_GlobalFrictionContactProblem(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct GlobalFrictionContactProblem *arg1 = (struct GlobalFrictionContactProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_GlobalFrictionContactProblem",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_GlobalFrictionContactProblem" "', argument " "1"" of type '" "struct GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (struct GlobalFrictionContactProblem *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        delete_GlobalFrictionContactProblem(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *GlobalFrictionContactProblem_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_GlobalFrictionContactProblem, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_globalFrictionContact_display(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  GlobalFrictionContactProblem *arg1 = (GlobalFrictionContactProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:globalFrictionContact_display",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "globalFrictionContact_display" "', argument " "1"" of type '" "GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (GlobalFrictionContactProblem *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        globalFrictionContact_display(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_globalFrictionContact_printInFile(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  GlobalFrictionContactProblem *arg1 = (GlobalFrictionContactProblem *) 0 ;
  FILE *arg2 = (FILE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:globalFrictionContact_printInFile",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "globalFrictionContact_printInFile" "', argument " "1"" of type '" "GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (GlobalFrictionContactProblem *)(argp1);
  {
    // %typemap(in) (FILE *file)
    int alloc = 1;
    char* cstr;
    int res = SWIG_AsCharPtrAndSize(obj1, &cstr, NULL, &alloc);
    if (!SWIG_IsOK(res)) {
      SWIG_Error(SWIG_ArgError(res), "in method unknown', argument " "1"" of type '" "char *""'");
    }
    arg2 = fopen(cstr, "r");
    if (!arg2)
    {
      SWIG_Error(SWIG_IOError, format_msg_concat("in method '" "globalFrictionContact_printInFile" "' cannot fopen file", cstr));
      if (alloc == SWIG_NEWOBJ) free(cstr);
      SWIG_fail;
    }
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)globalFrictionContact_printInFile(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_globalFrictionContact_newFromFile(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  GlobalFrictionContactProblem *arg1 = (GlobalFrictionContactProblem *) 0 ;
  FILE *arg2 = (FILE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:globalFrictionContact_newFromFile",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "globalFrictionContact_newFromFile" "', argument " "1"" of type '" "GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (GlobalFrictionContactProblem *)(argp1);
  {
    // %typemap(in) (FILE *file)
    int alloc = 1;
    char* cstr;
    int res = SWIG_AsCharPtrAndSize(obj1, &cstr, NULL, &alloc);
    if (!SWIG_IsOK(res)) {
      SWIG_Error(SWIG_ArgError(res), "in method unknown', argument " "1"" of type '" "char *""'");
    }
    arg2 = fopen(cstr, "r");
    if (!arg2)
    {
      SWIG_Error(SWIG_IOError, format_msg_concat("in method '" "globalFrictionContact_newFromFile" "' cannot fopen file", cstr));
      if (alloc == SWIG_NEWOBJ) free(cstr);
      SWIG_fail;
    }
    
  }
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)globalFrictionContact_newFromFile(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return resultobj;
fail:
  {
    // %typemap(freearg) (FILE *file)
    if(arg2)
    {
      fclose(arg2);
    }
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_globalFrictionContact_null(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  GlobalFrictionContactProblem *arg1 = (GlobalFrictionContactProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:globalFrictionContact_null",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "globalFrictionContact_null" "', argument " "1"" of type '" "GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (GlobalFrictionContactProblem *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        globalFrictionContact_null(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_freeGlobalFrictionContactProblem(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  GlobalFrictionContactProblem *arg1 = (GlobalFrictionContactProblem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:freeGlobalFrictionContactProblem",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "freeGlobalFrictionContactProblem" "', argument " "1"" of type '" "GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (GlobalFrictionContactProblem *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        freeGlobalFrictionContactProblem(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_gfc3d_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:gfc3d_setDefaultSolverOptions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gfc3d_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "gfc3d_setDefaultSolverOptions" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)gfc3d_setDefaultSolverOptions(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_gfc3d_set_internalsolver_tolerance(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  GlobalFrictionContactProblem *arg1 = (GlobalFrictionContactProblem *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  SolverOptions *arg3 = (SolverOptions *) 0 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:gfc3d_set_internalsolver_tolerance",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gfc3d_set_internalsolver_tolerance" "', argument " "1"" of type '" "GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (GlobalFrictionContactProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gfc3d_set_internalsolver_tolerance" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "gfc3d_set_internalsolver_tolerance" "', argument " "3"" of type '" "SolverOptions *""'"); 
  }
  arg3 = (SolverOptions *)(argp3);
  ecode4 = SWIG_AsVal_double(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "gfc3d_set_internalsolver_tolerance" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        gfc3d_set_internalsolver_tolerance(arg1,arg2,arg3,arg4);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_gfc3d_checkTrivialCaseGlobal(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  SolverOptions *arg6 = (SolverOptions *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  PyArrayObject *array4 = NULL ;
  int is_new_object4 = 0 ;
  PyArrayObject *array5 = NULL ;
  int is_new_object5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOO:gfc3d_checkTrivialCaseGlobal",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "gfc3d_checkTrivialCaseGlobal" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  {
    array4 = obj_to_sn_vector(obj3, &is_new_object4);
    
    if (!array4)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array4))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg4 = (double *) array_data(array4);
    
  }
  {
    array5 = obj_to_sn_vector(obj4, &is_new_object5);
    
    if (!array5)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array5))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg5 = (double *) array_data(array5);
    
  }
  res6 = SWIG_ConvertPtr(obj5, &argp6,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "gfc3d_checkTrivialCaseGlobal" "', argument " "6"" of type '" "SolverOptions *""'"); 
  }
  arg6 = (SolverOptions *)(argp6);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)gfc3d_checkTrivialCaseGlobal(arg1,arg2,arg3,arg4,arg5,arg6);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  {
    if(is_new_object5 && array5) {
      Py_DECREF(array5); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  {
    if(is_new_object5 && array5) {
      Py_DECREF(array5); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_gfc3d_nsgs_wr(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  GlobalFrictionContactProblem *arg1 = (GlobalFrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  int *arg5 = (int *) 0 ;
  SolverOptions *arg6 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  PyArrayObject *array4 = NULL ;
  int is_new_object4 = 0 ;
  int temp_info5 = -1 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg5 = &temp_info5;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:gfc3d_nsgs_wr",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gfc3d_nsgs_wr" "', argument " "1"" of type '" "GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (GlobalFrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  {
    array4 = obj_to_sn_vector(obj3, &is_new_object4);
    
    if (!array4)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array4))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg4 = (double *) array_data(array4);
    
  }
  res6 = SWIG_ConvertPtr(obj4, &argp6,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "gfc3d_nsgs_wr" "', argument " "6"" of type '" "SolverOptions *""'"); 
  }
  arg6 = (SolverOptions *)(argp6);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        gfc3d_nsgs_wr(arg1,arg2,arg3,arg4,arg5,arg6);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg5);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_gfc3d_nsgs_wr_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:gfc3d_nsgs_wr_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gfc3d_nsgs_wr_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)gfc3d_nsgs_wr_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_gfc3d_admm_wr(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  GlobalFrictionContactProblem *arg1 = (GlobalFrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  int *arg5 = (int *) 0 ;
  SolverOptions *arg6 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  PyArrayObject *array4 = NULL ;
  int is_new_object4 = 0 ;
  int temp_info5 = -1 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg5 = &temp_info5;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:gfc3d_admm_wr",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gfc3d_admm_wr" "', argument " "1"" of type '" "GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (GlobalFrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  {
    array4 = obj_to_sn_vector(obj3, &is_new_object4);
    
    if (!array4)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array4))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg4 = (double *) array_data(array4);
    
  }
  res6 = SWIG_ConvertPtr(obj4, &argp6,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "gfc3d_admm_wr" "', argument " "6"" of type '" "SolverOptions *""'"); 
  }
  arg6 = (SolverOptions *)(argp6);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        gfc3d_admm_wr(arg1,arg2,arg3,arg4,arg5,arg6);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg5);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_gfc3d_admm_wr_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:gfc3d_admm_wr_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gfc3d_admm_wr_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)gfc3d_admm_wr_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_gfc3d_nonsmooth_Newton_AlartCurnier_wr_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:gfc3d_nonsmooth_Newton_AlartCurnier_wr_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gfc3d_nonsmooth_Newton_AlartCurnier_wr_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)gfc3d_nonsmooth_Newton_AlartCurnier_wr_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_gfc3d_nonsmooth_Newton_AlartCurnier_wr(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  GlobalFrictionContactProblem *arg1 = (GlobalFrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  int *arg5 = (int *) 0 ;
  SolverOptions *arg6 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  PyArrayObject *array4 = NULL ;
  int is_new_object4 = 0 ;
  int temp_info5 = -1 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg5 = &temp_info5;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:gfc3d_nonsmooth_Newton_AlartCurnier_wr",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gfc3d_nonsmooth_Newton_AlartCurnier_wr" "', argument " "1"" of type '" "GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (GlobalFrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  {
    array4 = obj_to_sn_vector(obj3, &is_new_object4);
    
    if (!array4)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array4))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg4 = (double *) array_data(array4);
    
  }
  res6 = SWIG_ConvertPtr(obj4, &argp6,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "gfc3d_nonsmooth_Newton_AlartCurnier_wr" "', argument " "6"" of type '" "SolverOptions *""'"); 
  }
  arg6 = (SolverOptions *)(argp6);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        gfc3d_nonsmooth_Newton_AlartCurnier_wr(arg1,arg2,arg3,arg4,arg5,arg6);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg5);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_gfc3d_proximal_wr(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  GlobalFrictionContactProblem *arg1 = (GlobalFrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  int *arg5 = (int *) 0 ;
  SolverOptions *arg6 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  PyArrayObject *array4 = NULL ;
  int is_new_object4 = 0 ;
  int temp_info5 = -1 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg5 = &temp_info5;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:gfc3d_proximal_wr",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gfc3d_proximal_wr" "', argument " "1"" of type '" "GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (GlobalFrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  {
    array4 = obj_to_sn_vector(obj3, &is_new_object4);
    
    if (!array4)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array4))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg4 = (double *) array_data(array4);
    
  }
  res6 = SWIG_ConvertPtr(obj4, &argp6,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "gfc3d_proximal_wr" "', argument " "6"" of type '" "SolverOptions *""'"); 
  }
  arg6 = (SolverOptions *)(argp6);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        gfc3d_proximal_wr(arg1,arg2,arg3,arg4,arg5,arg6);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg5);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_gfc3d_proximal_wr_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:gfc3d_proximal_wr_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gfc3d_proximal_wr_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)gfc3d_proximal_wr_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_gfc3d_DeSaxceFixedPoint_wr(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  GlobalFrictionContactProblem *arg1 = (GlobalFrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  int *arg5 = (int *) 0 ;
  SolverOptions *arg6 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  PyArrayObject *array4 = NULL ;
  int is_new_object4 = 0 ;
  int temp_info5 = -1 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg5 = &temp_info5;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:gfc3d_DeSaxceFixedPoint_wr",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gfc3d_DeSaxceFixedPoint_wr" "', argument " "1"" of type '" "GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (GlobalFrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  {
    array4 = obj_to_sn_vector(obj3, &is_new_object4);
    
    if (!array4)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array4))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg4 = (double *) array_data(array4);
    
  }
  res6 = SWIG_ConvertPtr(obj4, &argp6,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "gfc3d_DeSaxceFixedPoint_wr" "', argument " "6"" of type '" "SolverOptions *""'"); 
  }
  arg6 = (SolverOptions *)(argp6);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        gfc3d_DeSaxceFixedPoint_wr(arg1,arg2,arg3,arg4,arg5,arg6);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg5);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_gfc3d_DeSaxceFixedPoint_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:gfc3d_DeSaxceFixedPoint_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gfc3d_DeSaxceFixedPoint_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)gfc3d_DeSaxceFixedPoint_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_gfc3d_TrescaFixedPoint_wr(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  GlobalFrictionContactProblem *arg1 = (GlobalFrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  int *arg5 = (int *) 0 ;
  SolverOptions *arg6 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  PyArrayObject *array4 = NULL ;
  int is_new_object4 = 0 ;
  int temp_info5 = -1 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg5 = &temp_info5;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:gfc3d_TrescaFixedPoint_wr",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gfc3d_TrescaFixedPoint_wr" "', argument " "1"" of type '" "GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (GlobalFrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  {
    array4 = obj_to_sn_vector(obj3, &is_new_object4);
    
    if (!array4)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array4))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg4 = (double *) array_data(array4);
    
  }
  res6 = SWIG_ConvertPtr(obj4, &argp6,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "gfc3d_TrescaFixedPoint_wr" "', argument " "6"" of type '" "SolverOptions *""'"); 
  }
  arg6 = (SolverOptions *)(argp6);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        gfc3d_TrescaFixedPoint_wr(arg1,arg2,arg3,arg4,arg5,arg6);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg5);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_gfc3d_TrescaFixedPoint_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:gfc3d_TrescaFixedPoint_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gfc3d_TrescaFixedPoint_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)gfc3d_TrescaFixedPoint_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_gfc3d_nsgs_velocity_wr(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  GlobalFrictionContactProblem *arg1 = (GlobalFrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  int *arg5 = (int *) 0 ;
  SolverOptions *arg6 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  PyArrayObject *array4 = NULL ;
  int is_new_object4 = 0 ;
  int temp_info5 = -1 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg5 = &temp_info5;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:gfc3d_nsgs_velocity_wr",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gfc3d_nsgs_velocity_wr" "', argument " "1"" of type '" "GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (GlobalFrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  {
    array4 = obj_to_sn_vector(obj3, &is_new_object4);
    
    if (!array4)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array4))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg4 = (double *) array_data(array4);
    
  }
  res6 = SWIG_ConvertPtr(obj4, &argp6,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "gfc3d_nsgs_velocity_wr" "', argument " "6"" of type '" "SolverOptions *""'"); 
  }
  arg6 = (SolverOptions *)(argp6);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        gfc3d_nsgs_velocity_wr(arg1,arg2,arg3,arg4,arg5,arg6);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg5);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_gfc3d_nsgs_velocity_wr_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:gfc3d_nsgs_velocity_wr_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gfc3d_nsgs_velocity_wr_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)gfc3d_nsgs_velocity_wr_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_gfc3d_nsgs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  GlobalFrictionContactProblem *arg1 = (GlobalFrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  int *arg5 = (int *) 0 ;
  SolverOptions *arg6 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  PyArrayObject *array4 = NULL ;
  int is_new_object4 = 0 ;
  int temp_info5 = -1 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg5 = &temp_info5;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:gfc3d_nsgs",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gfc3d_nsgs" "', argument " "1"" of type '" "GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (GlobalFrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  {
    array4 = obj_to_sn_vector(obj3, &is_new_object4);
    
    if (!array4)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array4))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg4 = (double *) array_data(array4);
    
  }
  res6 = SWIG_ConvertPtr(obj4, &argp6,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "gfc3d_nsgs" "', argument " "6"" of type '" "SolverOptions *""'"); 
  }
  arg6 = (SolverOptions *)(argp6);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        gfc3d_nsgs(arg1,arg2,arg3,arg4,arg5,arg6);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg5);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_gfc3d_ACLMFixedPoint(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  GlobalFrictionContactProblem *arg1 = (GlobalFrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  int *arg5 = (int *) 0 ;
  SolverOptions *arg6 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  PyArrayObject *array4 = NULL ;
  int is_new_object4 = 0 ;
  int temp_info5 = -1 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg5 = &temp_info5;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:gfc3d_ACLMFixedPoint",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gfc3d_ACLMFixedPoint" "', argument " "1"" of type '" "GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (GlobalFrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  {
    array4 = obj_to_sn_vector(obj3, &is_new_object4);
    
    if (!array4)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array4))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg4 = (double *) array_data(array4);
    
  }
  res6 = SWIG_ConvertPtr(obj4, &argp6,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "gfc3d_ACLMFixedPoint" "', argument " "6"" of type '" "SolverOptions *""'"); 
  }
  arg6 = (SolverOptions *)(argp6);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        gfc3d_ACLMFixedPoint(arg1,arg2,arg3,arg4,arg5,arg6);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg5);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_gfc3d_ACLMFixedPoint_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:gfc3d_ACLMFixedPoint_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gfc3d_ACLMFixedPoint_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)gfc3d_ACLMFixedPoint_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_gfc3d_AVI_gams_path(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  GlobalFrictionContactProblem *arg1 = (GlobalFrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:gfc3d_AVI_gams_path",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gfc3d_AVI_gams_path" "', argument " "1"" of type '" "GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (GlobalFrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "gfc3d_AVI_gams_path" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        gfc3d_AVI_gams_path(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_gfc3d_AVI_gams_pathvi(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  GlobalFrictionContactProblem *arg1 = (GlobalFrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int *arg4 = (int *) 0 ;
  SolverOptions *arg5 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  int temp_info4 = -1 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg4 = &temp_info4;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOO:gfc3d_AVI_gams_pathvi",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gfc3d_AVI_gams_pathvi" "', argument " "1"" of type '" "GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (GlobalFrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  res5 = SWIG_ConvertPtr(obj3, &argp5,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "gfc3d_AVI_gams_pathvi" "', argument " "5"" of type '" "SolverOptions *""'"); 
  }
  arg5 = (SolverOptions *)(argp5);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        gfc3d_AVI_gams_pathvi(arg1,arg2,arg3,arg4,arg5);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg4);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_gfc3d_nonsmooth_Newton_AlartCurnier(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  GlobalFrictionContactProblem *arg1 = (GlobalFrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  int *arg5 = (int *) 0 ;
  SolverOptions *arg6 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  PyArrayObject *array4 = NULL ;
  int is_new_object4 = 0 ;
  int temp_info5 = -1 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg5 = &temp_info5;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:gfc3d_nonsmooth_Newton_AlartCurnier",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gfc3d_nonsmooth_Newton_AlartCurnier" "', argument " "1"" of type '" "GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (GlobalFrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  {
    array4 = obj_to_sn_vector(obj3, &is_new_object4);
    
    if (!array4)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array4))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg4 = (double *) array_data(array4);
    
  }
  res6 = SWIG_ConvertPtr(obj4, &argp6,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "gfc3d_nonsmooth_Newton_AlartCurnier" "', argument " "6"" of type '" "SolverOptions *""'"); 
  }
  arg6 = (SolverOptions *)(argp6);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        gfc3d_nonsmooth_Newton_AlartCurnier(arg1,arg2,arg3,arg4,arg5,arg6);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg5);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_gfc3d_VI_ExtraGradient(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  GlobalFrictionContactProblem *arg1 = (GlobalFrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  int *arg5 = (int *) 0 ;
  SolverOptions *arg6 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  PyArrayObject *array4 = NULL ;
  int is_new_object4 = 0 ;
  int temp_info5 = -1 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg5 = &temp_info5;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:gfc3d_VI_ExtraGradient",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gfc3d_VI_ExtraGradient" "', argument " "1"" of type '" "GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (GlobalFrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  {
    array4 = obj_to_sn_vector(obj3, &is_new_object4);
    
    if (!array4)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array4))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg4 = (double *) array_data(array4);
    
  }
  res6 = SWIG_ConvertPtr(obj4, &argp6,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "gfc3d_VI_ExtraGradient" "', argument " "6"" of type '" "SolverOptions *""'"); 
  }
  arg6 = (SolverOptions *)(argp6);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        gfc3d_VI_ExtraGradient(arg1,arg2,arg3,arg4,arg5,arg6);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg5);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_gfc3d_VI_ExtraGradient_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:gfc3d_VI_ExtraGradient_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gfc3d_VI_ExtraGradient_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)gfc3d_VI_ExtraGradient_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_gfc3d_VI_FixedPointProjection(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  GlobalFrictionContactProblem *arg1 = (GlobalFrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  int *arg5 = (int *) 0 ;
  SolverOptions *arg6 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  PyArrayObject *array4 = NULL ;
  int is_new_object4 = 0 ;
  int temp_info5 = -1 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg5 = &temp_info5;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:gfc3d_VI_FixedPointProjection",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gfc3d_VI_FixedPointProjection" "', argument " "1"" of type '" "GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (GlobalFrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  {
    array4 = obj_to_sn_vector(obj3, &is_new_object4);
    
    if (!array4)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array4))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg4 = (double *) array_data(array4);
    
  }
  res6 = SWIG_ConvertPtr(obj4, &argp6,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "gfc3d_VI_FixedPointProjection" "', argument " "6"" of type '" "SolverOptions *""'"); 
  }
  arg6 = (SolverOptions *)(argp6);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        gfc3d_VI_FixedPointProjection(arg1,arg2,arg3,arg4,arg5,arg6);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg5);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_gfc3d_VI_FixedPointProjection_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:gfc3d_VI_FixedPointProjection_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gfc3d_VI_FixedPointProjection_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)gfc3d_VI_FixedPointProjection_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_gfc3d_ADMM(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  GlobalFrictionContactProblem *arg1 = (GlobalFrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  int *arg5 = (int *) 0 ;
  SolverOptions *arg6 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  PyArrayObject *array4 = NULL ;
  int is_new_object4 = 0 ;
  int temp_info5 = -1 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  
  {
    // a default initialization : solver may stop if *info = 0 (checkTrivialCase)
    // checkTrivialCase => better if directly in solvers, not in driver.
    arg5 = &temp_info5;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:gfc3d_ADMM",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gfc3d_ADMM" "', argument " "1"" of type '" "GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (GlobalFrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  {
    array4 = obj_to_sn_vector(obj3, &is_new_object4);
    
    if (!array4)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array4))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg4 = (double *) array_data(array4);
    
  }
  res6 = SWIG_ConvertPtr(obj4, &argp6,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "gfc3d_ADMM" "', argument " "6"" of type '" "SolverOptions *""'"); 
  }
  arg6 = (SolverOptions *)(argp6);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        gfc3d_ADMM(arg1,arg2,arg3,arg4,arg5,arg6);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  {
    Py_DECREF(resultobj);
    
    resultobj = SWIG_From_int(*arg5);
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_gfc3d_ADMM_init(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  GlobalFrictionContactProblem *arg1 = (GlobalFrictionContactProblem *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:gfc3d_ADMM_init",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gfc3d_ADMM_init" "', argument " "1"" of type '" "GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (GlobalFrictionContactProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gfc3d_ADMM_init" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        gfc3d_ADMM_init(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_gfc3d_ADMM_free(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  GlobalFrictionContactProblem *arg1 = (GlobalFrictionContactProblem *) 0 ;
  SolverOptions *arg2 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:gfc3d_ADMM_free",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gfc3d_ADMM_free" "', argument " "1"" of type '" "GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (GlobalFrictionContactProblem *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gfc3d_ADMM_free" "', argument " "2"" of type '" "SolverOptions *""'"); 
  }
  arg2 = (SolverOptions *)(argp2);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        gfc3d_ADMM_free(arg1,arg2);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_gfc3d_ADMM_setDefaultSolverOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SolverOptions *arg1 = (SolverOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:gfc3d_ADMM_setDefaultSolverOptions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gfc3d_ADMM_setDefaultSolverOptions" "', argument " "1"" of type '" "SolverOptions *""'"); 
  }
  arg1 = (SolverOptions *)(argp1);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)gfc3d_ADMM_setDefaultSolverOptions(arg1);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_gfc3d_compute_error(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  GlobalFrictionContactProblem *arg1 = (GlobalFrictionContactProblem *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double arg5 ;
  SolverOptions *arg6 = (SolverOptions *) 0 ;
  double arg7 ;
  double *arg8 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyArrayObject *array2 = NULL ;
  int is_new_object2 = 0 ;
  PyArrayObject *array3 = NULL ;
  int is_new_object3 = 0 ;
  PyArrayObject *array4 = NULL ;
  int is_new_object4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  double val7 ;
  int ecode7 = 0 ;
  double temp8 ;
  int res8 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  int result;
  
  arg8 = &temp8;
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:gfc3d_compute_error",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GlobalFrictionContactProblem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gfc3d_compute_error" "', argument " "1"" of type '" "GlobalFrictionContactProblem *""'"); 
  }
  arg1 = (GlobalFrictionContactProblem *)(argp1);
  {
    array2 = obj_to_sn_vector(obj1, &is_new_object2);
    
    if (!array2)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array2))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg2 = (double *) array_data(array2);
    
  }
  {
    array3 = obj_to_sn_vector(obj2, &is_new_object3);
    
    if (!array3)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array3))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg3 = (double *) array_data(array3);
    
  }
  {
    array4 = obj_to_sn_vector(obj3, &is_new_object4);
    
    if (!array4)
    {
      SWIG_exception_fail(SWIG_TypeError, "Could not get a SN_ARRAY_TYPE from the python object");
    }
    
    if (CHECK_ARRAY_VECTOR(array4))
    {
      SWIG_exception_fail(SWIG_TypeError, "The given object does not have the right structure. We expect a vector (or list, tuple, ...)");
    }
    
    arg4 = (double *) array_data(array4);
    
  }
  ecode5 = SWIG_AsVal_double(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "gfc3d_compute_error" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = (double)(val5);
  res6 = SWIG_ConvertPtr(obj5, &argp6,SWIGTYPE_p_SolverOptions, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "gfc3d_compute_error" "', argument " "6"" of type '" "SolverOptions *""'"); 
  }
  arg6 = (SolverOptions *)(argp6);
  ecode7 = SWIG_AsVal_double(obj6, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "gfc3d_compute_error" "', argument " "7"" of type '" "double""'");
  } 
  arg7 = (double)(val7);
  {
    /* I'm HERE */
    /* TODO implement setjmp/longjmp here  + SWIG_exception */
    switch (SN_SETJMP_EXTERNAL_START)
    {
    case SN_NO_ERROR:
      {
        result = (int)gfc3d_compute_error(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
        SN_SETJMP_EXTERNAL_STOP
        break;
      }
    case SN_MEMORY_ALLOC_ERROR:
      {
        SWIG_exception(SWIG_MemoryError, format_exception_msg("Out of memory:"));
        break;
      }
    case SN_UNSUPPORTED_LINALG_OP:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("Unsupported linear algebra operation:"));
        break;
      }
    case SN_PROBLEM_NOT_PROCESSABLE:
      {
        SWIG_exception(SWIG_RuntimeError, format_exception_msg("The given problem is not processable:"));
        break;
      }
    default:
      {
        SWIG_exception(SWIG_UnknownError, format_exception_msg("Unknown error! Hopefully more info follow:"));
        break;
      }
    }
    
  }
  resultobj = SWIG_From_int((int)(result));
  if (SWIG_IsTmpObj(res8)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg8)));
  } else {
    int new_flags = SWIG_IsNewObj(res8) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg8), SWIGTYPE_p_double, new_flags));
  }
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return resultobj;
fail:
  {
    if(is_new_object2 && array2) {
      Py_DECREF(array2); 
    };
  }
  {
    if(is_new_object3 && array3) {
      Py_DECREF(array3); 
    };
  }
  {
    if(is_new_object4 && array4) {
      Py_DECREF(array4); 
    };
  }
  return NULL;
}


static PyMethodDef SwigMethods[] = {
	 { (char *)"SWIG_PyInstanceMethod_New", (PyCFunction)SWIG_PyInstanceMethod_New, METH_O, NULL},
	 { (char *)"NM_clean_cs", _wrap_NM_clean_cs, METH_VARARGS, NULL},
	 { (char *)"NM_clean", _wrap_NM_clean, METH_VARARGS, NULL},
	 { (char *)"sane_pyseq_check", _wrap_sane_pyseq_check, METH_VARARGS, NULL},
	 { (char *)"_sn_check_nnz", _wrap__sn_check_nnz, METH_VARARGS, NULL},
	 { (char *)"_sn_check_shape", _wrap__sn_check_shape, METH_VARARGS, NULL},
	 { (char *)"is_Pyobject_scipy_sparse_matrix", _wrap_is_Pyobject_scipy_sparse_matrix, METH_VARARGS, NULL},
	 { (char *)"linearComplementarity_driver", _wrap_linearComplementarity_driver, METH_VARARGS, NULL},
	 { (char *)"mlcp_driver", _wrap_mlcp_driver, METH_VARARGS, NULL},
	 { (char *)"fc2d_driver", _wrap_fc2d_driver, METH_VARARGS, NULL},
	 { (char *)"fc3d_driver", _wrap_fc3d_driver, METH_VARARGS, NULL},
	 { (char *)"gfc3d_driver", _wrap_gfc3d_driver, METH_VARARGS, NULL},
	 { (char *)"variationalInequality_driver", _wrap_variationalInequality_driver, METH_VARARGS, NULL},
	 { (char *)"avi_driver", _wrap_avi_driver, METH_VARARGS, NULL},
	 { (char *)"mcp_driver", _wrap_mcp_driver, METH_VARARGS, NULL},
	 { (char *)"mcp_driver2", _wrap_mcp_driver2, METH_VARARGS, NULL},
	 { (char *)"ncp_driver", _wrap_ncp_driver, METH_VARARGS, NULL},
	 { (char *)"soclcp_driver", _wrap_soclcp_driver, METH_VARARGS, NULL},
	 { (char *)"fc3d_LmgcDriver", _wrap_fc3d_LmgcDriver, METH_VARARGS, NULL},
	 { (char *)"gfc3d_LmgcDriver", _wrap_gfc3d_LmgcDriver, METH_VARARGS, NULL},
	 { (char *)"relay_driver", _wrap_relay_driver, METH_VARARGS, NULL},
	 { (char *)"Callback_env_set", _wrap_Callback_env_set, METH_VARARGS, NULL},
	 { (char *)"Callback_env_get", _wrap_Callback_env_get, METH_VARARGS, NULL},
	 { (char *)"Callback_collectStatsIteration_set", _wrap_Callback_collectStatsIteration_set, METH_VARARGS, NULL},
	 { (char *)"Callback_collectStatsIteration_get", _wrap_Callback_collectStatsIteration_get, METH_VARARGS, NULL},
	 { (char *)"new_Callback", _wrap_new_Callback, METH_VARARGS, NULL},
	 { (char *)"delete_Callback", _wrap_delete_Callback, METH_VARARGS, NULL},
	 { (char *)"Callback_swigregister", Callback_swigregister, METH_VARARGS, NULL},
	 { (char *)"SolverOptions_solverId_set", _wrap_SolverOptions_solverId_set, METH_VARARGS, NULL},
	 { (char *)"SolverOptions_solverId_get", _wrap_SolverOptions_solverId_get, METH_VARARGS, NULL},
	 { (char *)"SolverOptions_isSet_set", _wrap_SolverOptions_isSet_set, METH_VARARGS, NULL},
	 { (char *)"SolverOptions_isSet_get", _wrap_SolverOptions_isSet_get, METH_VARARGS, NULL},
	 { (char *)"SolverOptions_iSize_set", _wrap_SolverOptions_iSize_set, METH_VARARGS, NULL},
	 { (char *)"SolverOptions_iSize_get", _wrap_SolverOptions_iSize_get, METH_VARARGS, NULL},
	 { (char *)"SolverOptions_iparam_set", _wrap_SolverOptions_iparam_set, METH_VARARGS, NULL},
	 { (char *)"SolverOptions_iparam_get", _wrap_SolverOptions_iparam_get, METH_VARARGS, NULL},
	 { (char *)"SolverOptions_dSize_set", _wrap_SolverOptions_dSize_set, METH_VARARGS, NULL},
	 { (char *)"SolverOptions_dSize_get", _wrap_SolverOptions_dSize_get, METH_VARARGS, NULL},
	 { (char *)"SolverOptions_dparam_set", _wrap_SolverOptions_dparam_set, METH_VARARGS, NULL},
	 { (char *)"SolverOptions_dparam_get", _wrap_SolverOptions_dparam_get, METH_VARARGS, NULL},
	 { (char *)"SolverOptions_filterOn_set", _wrap_SolverOptions_filterOn_set, METH_VARARGS, NULL},
	 { (char *)"SolverOptions_filterOn_get", _wrap_SolverOptions_filterOn_get, METH_VARARGS, NULL},
	 { (char *)"SolverOptions_dWorkSize_set", _wrap_SolverOptions_dWorkSize_set, METH_VARARGS, NULL},
	 { (char *)"SolverOptions_dWorkSize_get", _wrap_SolverOptions_dWorkSize_get, METH_VARARGS, NULL},
	 { (char *)"SolverOptions_dWork_set", _wrap_SolverOptions_dWork_set, METH_VARARGS, NULL},
	 { (char *)"SolverOptions_dWork_get", _wrap_SolverOptions_dWork_get, METH_VARARGS, NULL},
	 { (char *)"SolverOptions_iWorkSize_set", _wrap_SolverOptions_iWorkSize_set, METH_VARARGS, NULL},
	 { (char *)"SolverOptions_iWorkSize_get", _wrap_SolverOptions_iWorkSize_get, METH_VARARGS, NULL},
	 { (char *)"SolverOptions_iWork_set", _wrap_SolverOptions_iWork_set, METH_VARARGS, NULL},
	 { (char *)"SolverOptions_iWork_get", _wrap_SolverOptions_iWork_get, METH_VARARGS, NULL},
	 { (char *)"SolverOptions_numberOfInternalSolvers_set", _wrap_SolverOptions_numberOfInternalSolvers_set, METH_VARARGS, NULL},
	 { (char *)"SolverOptions_numberOfInternalSolvers_get", _wrap_SolverOptions_numberOfInternalSolvers_get, METH_VARARGS, NULL},
	 { (char *)"SolverOptions_internalSolvers_set", _wrap_SolverOptions_internalSolvers_set, METH_VARARGS, NULL},
	 { (char *)"SolverOptions_internalSolvers_get", _wrap_SolverOptions_internalSolvers_get, METH_VARARGS, NULL},
	 { (char *)"SolverOptions_callback_set", _wrap_SolverOptions_callback_set, METH_VARARGS, NULL},
	 { (char *)"SolverOptions_callback_get", _wrap_SolverOptions_callback_get, METH_VARARGS, NULL},
	 { (char *)"SolverOptions_solverParameters_set", _wrap_SolverOptions_solverParameters_set, METH_VARARGS, NULL},
	 { (char *)"SolverOptions_solverParameters_get", _wrap_SolverOptions_solverParameters_get, METH_VARARGS, NULL},
	 { (char *)"SolverOptions_solverData_set", _wrap_SolverOptions_solverData_set, METH_VARARGS, NULL},
	 { (char *)"SolverOptions_solverData_get", _wrap_SolverOptions_solverData_get, METH_VARARGS, NULL},
	 { (char *)"new_SolverOptions", _wrap_new_SolverOptions, METH_VARARGS, NULL},
	 { (char *)"delete_SolverOptions", _wrap_delete_SolverOptions, METH_VARARGS, NULL},
	 { (char *)"SolverOptions_swigregister", SolverOptions_swigregister, METH_VARARGS, NULL},
	 { (char *)"solver_options_print", _wrap_solver_options_print, METH_VARARGS, NULL},
	 { (char *)"solver_options_delete", _wrap_solver_options_delete, METH_VARARGS, NULL},
	 { (char *)"solver_options_nullify", _wrap_solver_options_nullify, METH_VARARGS, NULL},
	 { (char *)"solver_options_fill", _wrap_solver_options_fill, METH_VARARGS, NULL},
	 { (char *)"solver_options_set", _wrap_solver_options_set, METH_VARARGS, NULL},
	 { (char *)"solver_options_name_to_id", _wrap_solver_options_name_to_id, METH_VARARGS, NULL},
	 { (char *)"solver_options_id_to_name", _wrap_solver_options_id_to_name, METH_VARARGS, NULL},
	 { (char *)"ns_problem_id_to_name", _wrap_ns_problem_id_to_name, METH_VARARGS, NULL},
	 { (char *)"solver_options_free_solver_specific_data", _wrap_solver_options_free_solver_specific_data, METH_VARARGS, NULL},
	 { (char *)"solver_options_copy", _wrap_solver_options_copy, METH_VARARGS, NULL},
	 { (char *)"solver_options_get_internal_solver", _wrap_solver_options_get_internal_solver, METH_VARARGS, NULL},
	 { (char *)"numerics_set_verbose", _wrap_numerics_set_verbose, METH_VARARGS, NULL},
	 { (char *)"numerics_error", _wrap_numerics_error, METH_VARARGS, NULL},
	 { (char *)"numerics_error_nonfatal", _wrap_numerics_error_nonfatal, METH_VARARGS, NULL},
	 { (char *)"numerics_warning", _wrap_numerics_warning, METH_VARARGS, NULL},
	 { (char *)"numerics_printf", _wrap_numerics_printf, METH_VARARGS, NULL},
	 { (char *)"numerics_printf_verbose", _wrap_numerics_printf_verbose, METH_VARARGS, NULL},
	 { (char *)"isqrt", _wrap_isqrt, METH_VARARGS, NULL},
	 { (char *)"compiled_in_debug_mode", _wrap_compiled_in_debug_mode, METH_VARARGS, NULL},
	 { (char *)"set_cstruct", _wrap_set_cstruct, METH_VARARGS, NULL},
	 { (char *)"CSparseMatrix_lu_factors_n_set", _wrap_CSparseMatrix_lu_factors_n_set, METH_VARARGS, NULL},
	 { (char *)"CSparseMatrix_lu_factors_n_get", _wrap_CSparseMatrix_lu_factors_n_get, METH_VARARGS, NULL},
	 { (char *)"CSparseMatrix_lu_factors_S_set", _wrap_CSparseMatrix_lu_factors_S_set, METH_VARARGS, NULL},
	 { (char *)"CSparseMatrix_lu_factors_S_get", _wrap_CSparseMatrix_lu_factors_S_get, METH_VARARGS, NULL},
	 { (char *)"CSparseMatrix_lu_factors_N_set", _wrap_CSparseMatrix_lu_factors_N_set, METH_VARARGS, NULL},
	 { (char *)"CSparseMatrix_lu_factors_N_get", _wrap_CSparseMatrix_lu_factors_N_get, METH_VARARGS, NULL},
	 { (char *)"new_CSparseMatrix_lu_factors", _wrap_new_CSparseMatrix_lu_factors, METH_VARARGS, NULL},
	 { (char *)"delete_CSparseMatrix_lu_factors", _wrap_delete_CSparseMatrix_lu_factors, METH_VARARGS, NULL},
	 { (char *)"CSparseMatrix_lu_factors_swigregister", CSparseMatrix_lu_factors_swigregister, METH_VARARGS, NULL},
	 { (char *)"CSparsematrix_lu_factorization", _wrap_CSparsematrix_lu_factorization, METH_VARARGS, NULL},
	 { (char *)"CSparseMatrix_solve", _wrap_CSparseMatrix_solve, METH_VARARGS, NULL},
	 { (char *)"CSparseMatrix_free_lu_factors", _wrap_CSparseMatrix_free_lu_factors, METH_VARARGS, NULL},
	 { (char *)"CSparseMatrix_aaxpby", _wrap_CSparseMatrix_aaxpby, METH_VARARGS, NULL},
	 { (char *)"CSparseMatrix_alloc_for_copy", _wrap_CSparseMatrix_alloc_for_copy, METH_VARARGS, NULL},
	 { (char *)"CSparseMatrix_to_dense", _wrap_CSparseMatrix_to_dense, METH_VARARGS, NULL},
	 { (char *)"CSparseMatrix_print_in_file", _wrap_CSparseMatrix_print_in_file, METH_VARARGS, NULL},
	 { (char *)"CSparseMatrix_new_from_file", _wrap_CSparseMatrix_new_from_file, METH_VARARGS, NULL},
	 { (char *)"CSparseMatrix_zentry", _wrap_CSparseMatrix_zentry, METH_VARARGS, NULL},
	 { (char *)"CSparseMatrix_check_triplet", _wrap_CSparseMatrix_check_triplet, METH_VARARGS, NULL},
	 { (char *)"CSparseMatrix_check_csc", _wrap_CSparseMatrix_check_csc, METH_VARARGS, NULL},
	 { (char *)"CSparseMatrix_spfree_on_stack", _wrap_CSparseMatrix_spfree_on_stack, METH_VARARGS, NULL},
	 { (char *)"CSparseMatrix_copy", _wrap_CSparseMatrix_copy, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrix_nbblocks_set", _wrap_SparseBlockStructuredMatrix_nbblocks_set, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrix_nbblocks_get", _wrap_SparseBlockStructuredMatrix_nbblocks_get, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrix_block_set", _wrap_SparseBlockStructuredMatrix_block_set, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrix_block_get", _wrap_SparseBlockStructuredMatrix_block_get, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrix_blocknumber0_set", _wrap_SparseBlockStructuredMatrix_blocknumber0_set, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrix_blocknumber0_get", _wrap_SparseBlockStructuredMatrix_blocknumber0_get, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrix_blocknumber1_set", _wrap_SparseBlockStructuredMatrix_blocknumber1_set, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrix_blocknumber1_get", _wrap_SparseBlockStructuredMatrix_blocknumber1_get, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrix_blocksize0_set", _wrap_SparseBlockStructuredMatrix_blocksize0_set, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrix_blocksize0_get", _wrap_SparseBlockStructuredMatrix_blocksize0_get, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrix_blocksize1_set", _wrap_SparseBlockStructuredMatrix_blocksize1_set, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrix_blocksize1_get", _wrap_SparseBlockStructuredMatrix_blocksize1_get, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrix_filled1_set", _wrap_SparseBlockStructuredMatrix_filled1_set, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrix_filled1_get", _wrap_SparseBlockStructuredMatrix_filled1_get, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrix_filled2_set", _wrap_SparseBlockStructuredMatrix_filled2_set, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrix_filled2_get", _wrap_SparseBlockStructuredMatrix_filled2_get, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrix_index1_data_set", _wrap_SparseBlockStructuredMatrix_index1_data_set, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrix_index1_data_get", _wrap_SparseBlockStructuredMatrix_index1_data_get, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrix_index2_data_set", _wrap_SparseBlockStructuredMatrix_index2_data_set, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrix_index2_data_get", _wrap_SparseBlockStructuredMatrix_index2_data_get, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrix_diagonal_blocks_set", _wrap_SparseBlockStructuredMatrix_diagonal_blocks_set, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrix_diagonal_blocks_get", _wrap_SparseBlockStructuredMatrix_diagonal_blocks_get, METH_VARARGS, NULL},
	 { (char *)"delete_SparseBlockStructuredMatrix", _wrap_delete_SparseBlockStructuredMatrix, METH_VARARGS, NULL},
	 { (char *)"new_SparseBlockStructuredMatrix", _wrap_new_SparseBlockStructuredMatrix, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrix_swigregister", SparseBlockStructuredMatrix_swigregister, METH_VARARGS, NULL},
	 { (char *)"SparseBlockCoordinateMatrix_nbblocks_set", _wrap_SparseBlockCoordinateMatrix_nbblocks_set, METH_VARARGS, NULL},
	 { (char *)"SparseBlockCoordinateMatrix_nbblocks_get", _wrap_SparseBlockCoordinateMatrix_nbblocks_get, METH_VARARGS, NULL},
	 { (char *)"SparseBlockCoordinateMatrix_blocknumber0_set", _wrap_SparseBlockCoordinateMatrix_blocknumber0_set, METH_VARARGS, NULL},
	 { (char *)"SparseBlockCoordinateMatrix_blocknumber0_get", _wrap_SparseBlockCoordinateMatrix_blocknumber0_get, METH_VARARGS, NULL},
	 { (char *)"SparseBlockCoordinateMatrix_blocknumber1_set", _wrap_SparseBlockCoordinateMatrix_blocknumber1_set, METH_VARARGS, NULL},
	 { (char *)"SparseBlockCoordinateMatrix_blocknumber1_get", _wrap_SparseBlockCoordinateMatrix_blocknumber1_get, METH_VARARGS, NULL},
	 { (char *)"SparseBlockCoordinateMatrix_block_set", _wrap_SparseBlockCoordinateMatrix_block_set, METH_VARARGS, NULL},
	 { (char *)"SparseBlockCoordinateMatrix_block_get", _wrap_SparseBlockCoordinateMatrix_block_get, METH_VARARGS, NULL},
	 { (char *)"SparseBlockCoordinateMatrix_blocksize0_set", _wrap_SparseBlockCoordinateMatrix_blocksize0_set, METH_VARARGS, NULL},
	 { (char *)"SparseBlockCoordinateMatrix_blocksize0_get", _wrap_SparseBlockCoordinateMatrix_blocksize0_get, METH_VARARGS, NULL},
	 { (char *)"SparseBlockCoordinateMatrix_blocksize1_set", _wrap_SparseBlockCoordinateMatrix_blocksize1_set, METH_VARARGS, NULL},
	 { (char *)"SparseBlockCoordinateMatrix_blocksize1_get", _wrap_SparseBlockCoordinateMatrix_blocksize1_get, METH_VARARGS, NULL},
	 { (char *)"SparseBlockCoordinateMatrix_row_set", _wrap_SparseBlockCoordinateMatrix_row_set, METH_VARARGS, NULL},
	 { (char *)"SparseBlockCoordinateMatrix_row_get", _wrap_SparseBlockCoordinateMatrix_row_get, METH_VARARGS, NULL},
	 { (char *)"SparseBlockCoordinateMatrix_column_set", _wrap_SparseBlockCoordinateMatrix_column_set, METH_VARARGS, NULL},
	 { (char *)"SparseBlockCoordinateMatrix_column_get", _wrap_SparseBlockCoordinateMatrix_column_get, METH_VARARGS, NULL},
	 { (char *)"new_SparseBlockCoordinateMatrix", _wrap_new_SparseBlockCoordinateMatrix, METH_VARARGS, NULL},
	 { (char *)"delete_SparseBlockCoordinateMatrix", _wrap_delete_SparseBlockCoordinateMatrix, METH_VARARGS, NULL},
	 { (char *)"SparseBlockCoordinateMatrix_swigregister", SparseBlockCoordinateMatrix_swigregister, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrixPred_nbbldiag_set", _wrap_SparseBlockStructuredMatrixPred_nbbldiag_set, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrixPred_nbbldiag_get", _wrap_SparseBlockStructuredMatrixPred_nbbldiag_get, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrixPred_indic_set", _wrap_SparseBlockStructuredMatrixPred_indic_set, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrixPred_indic_get", _wrap_SparseBlockStructuredMatrixPred_indic_get, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrixPred_indicop_set", _wrap_SparseBlockStructuredMatrixPred_indicop_set, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrixPred_indicop_get", _wrap_SparseBlockStructuredMatrixPred_indicop_get, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrixPred_submatlcp_set", _wrap_SparseBlockStructuredMatrixPred_submatlcp_set, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrixPred_submatlcp_get", _wrap_SparseBlockStructuredMatrixPred_submatlcp_get, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrixPred_submatlcpop_set", _wrap_SparseBlockStructuredMatrixPred_submatlcpop_set, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrixPred_submatlcpop_get", _wrap_SparseBlockStructuredMatrixPred_submatlcpop_get, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrixPred_ipiv_set", _wrap_SparseBlockStructuredMatrixPred_ipiv_set, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrixPred_ipiv_get", _wrap_SparseBlockStructuredMatrixPred_ipiv_get, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrixPred_sizesublcp_set", _wrap_SparseBlockStructuredMatrixPred_sizesublcp_set, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrixPred_sizesublcp_get", _wrap_SparseBlockStructuredMatrixPred_sizesublcp_get, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrixPred_sizesublcpop_set", _wrap_SparseBlockStructuredMatrixPred_sizesublcpop_set, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrixPred_sizesublcpop_get", _wrap_SparseBlockStructuredMatrixPred_sizesublcpop_get, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrixPred_subq_set", _wrap_SparseBlockStructuredMatrixPred_subq_set, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrixPred_subq_get", _wrap_SparseBlockStructuredMatrixPred_subq_get, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrixPred_bufz_set", _wrap_SparseBlockStructuredMatrixPred_bufz_set, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrixPred_bufz_get", _wrap_SparseBlockStructuredMatrixPred_bufz_get, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrixPred_newz_set", _wrap_SparseBlockStructuredMatrixPred_newz_set, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrixPred_newz_get", _wrap_SparseBlockStructuredMatrixPred_newz_get, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrixPred_workspace_set", _wrap_SparseBlockStructuredMatrixPred_workspace_set, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrixPred_workspace_get", _wrap_SparseBlockStructuredMatrixPred_workspace_get, METH_VARARGS, NULL},
	 { (char *)"new_SparseBlockStructuredMatrixPred", _wrap_new_SparseBlockStructuredMatrixPred, METH_VARARGS, NULL},
	 { (char *)"delete_SparseBlockStructuredMatrixPred", _wrap_delete_SparseBlockStructuredMatrixPred, METH_VARARGS, NULL},
	 { (char *)"SparseBlockStructuredMatrixPred_swigregister", SparseBlockStructuredMatrixPred_swigregister, METH_VARARGS, NULL},
	 { (char *)"SBM_index_by_column_filled3_set", _wrap_SBM_index_by_column_filled3_set, METH_VARARGS, NULL},
	 { (char *)"SBM_index_by_column_filled3_get", _wrap_SBM_index_by_column_filled3_get, METH_VARARGS, NULL},
	 { (char *)"SBM_index_by_column_filled4_set", _wrap_SBM_index_by_column_filled4_set, METH_VARARGS, NULL},
	 { (char *)"SBM_index_by_column_filled4_get", _wrap_SBM_index_by_column_filled4_get, METH_VARARGS, NULL},
	 { (char *)"SBM_index_by_column_index3_data_set", _wrap_SBM_index_by_column_index3_data_set, METH_VARARGS, NULL},
	 { (char *)"SBM_index_by_column_index3_data_get", _wrap_SBM_index_by_column_index3_data_get, METH_VARARGS, NULL},
	 { (char *)"SBM_index_by_column_index4_data_set", _wrap_SBM_index_by_column_index4_data_set, METH_VARARGS, NULL},
	 { (char *)"SBM_index_by_column_index4_data_get", _wrap_SBM_index_by_column_index4_data_get, METH_VARARGS, NULL},
	 { (char *)"SBM_index_by_column_blockMap_set", _wrap_SBM_index_by_column_blockMap_set, METH_VARARGS, NULL},
	 { (char *)"SBM_index_by_column_blockMap_get", _wrap_SBM_index_by_column_blockMap_get, METH_VARARGS, NULL},
	 { (char *)"new_SBM_index_by_column", _wrap_new_SBM_index_by_column, METH_VARARGS, NULL},
	 { (char *)"delete_SBM_index_by_column", _wrap_delete_SBM_index_by_column, METH_VARARGS, NULL},
	 { (char *)"SBM_index_by_column_swigregister", SBM_index_by_column_swigregister, METH_VARARGS, NULL},
	 { (char *)"SBM_new", _wrap_SBM_new, METH_VARARGS, NULL},
	 { (char *)"SBM_null", _wrap_SBM_null, METH_VARARGS, NULL},
	 { (char *)"SBM_gemv", _wrap_SBM_gemv, METH_VARARGS, NULL},
	 { (char *)"SBM_gemv_3x3", _wrap_SBM_gemv_3x3, METH_VARARGS, NULL},
	 { (char *)"SBM_gemm_without_allocation", _wrap_SBM_gemm_without_allocation, METH_VARARGS, NULL},
	 { (char *)"SBM_multiply", _wrap_SBM_multiply, METH_VARARGS, NULL},
	 { (char *)"SBM_zero_matrix_for_multiply", _wrap_SBM_zero_matrix_for_multiply, METH_VARARGS, NULL},
	 { (char *)"SBM_add", _wrap_SBM_add, METH_VARARGS, NULL},
	 { (char *)"SBM_add_without_allocation", _wrap_SBM_add_without_allocation, METH_VARARGS, NULL},
	 { (char *)"SBM_row_prod", _wrap_SBM_row_prod, METH_VARARGS, NULL},
	 { (char *)"SBM_row_prod_no_diag", _wrap_SBM_row_prod_no_diag, METH_VARARGS, NULL},
	 { (char *)"SBM_row_prod_no_diag_3x3", _wrap_SBM_row_prod_no_diag_3x3, METH_VARARGS, NULL},
	 { (char *)"SBM_row_prod_no_diag_1x1", _wrap_SBM_row_prod_no_diag_1x1, METH_VARARGS, NULL},
	 { (char *)"SBM_extract_component_3x3", _wrap_SBM_extract_component_3x3, METH_VARARGS, NULL},
	 { (char *)"SBM_free", _wrap_SBM_free, METH_VARARGS, NULL},
	 { (char *)"SBMfree", _wrap_SBMfree, METH_VARARGS, NULL},
	 { (char *)"SBM_print", _wrap_SBM_print, METH_VARARGS, NULL},
	 { (char *)"SBM_write_in_file", _wrap_SBM_write_in_file, METH_VARARGS, NULL},
	 { (char *)"SBM_read_in_file", _wrap_SBM_read_in_file, METH_VARARGS, NULL},
	 { (char *)"SBM_new_from_file", _wrap_SBM_new_from_file, METH_VARARGS, NULL},
	 { (char *)"SBM_write_in_fileForScilab", _wrap_SBM_write_in_fileForScilab, METH_VARARGS, NULL},
	 { (char *)"SBM_write_in_filename", _wrap_SBM_write_in_filename, METH_VARARGS, NULL},
	 { (char *)"SBM_read_in_filename", _wrap_SBM_read_in_filename, METH_VARARGS, NULL},
	 { (char *)"SBM_free_pred", _wrap_SBM_free_pred, METH_VARARGS, NULL},
	 { (char *)"SBM_diagonal_block_indices", _wrap_SBM_diagonal_block_indices, METH_VARARGS, NULL},
	 { (char *)"SBM_diagonal_block_index", _wrap_SBM_diagonal_block_index, METH_VARARGS, NULL},
	 { (char *)"SBM_zentry", _wrap_SBM_zentry, METH_VARARGS, NULL},
	 { (char *)"SBM_get_value", _wrap_SBM_get_value, METH_VARARGS, NULL},
	 { (char *)"SBM_copy", _wrap_SBM_copy, METH_VARARGS, NULL},
	 { (char *)"SBM_transpose", _wrap_SBM_transpose, METH_VARARGS, NULL},
	 { (char *)"SBM_inverse_diagonal_block_matrix_in_place", _wrap_SBM_inverse_diagonal_block_matrix_in_place, METH_VARARGS, NULL},
	 { (char *)"SBM_to_dense", _wrap_SBM_to_dense, METH_VARARGS, NULL},
	 { (char *)"SBM_to_sparse", _wrap_SBM_to_sparse, METH_VARARGS, NULL},
	 { (char *)"SBM_to_sparse_init_memory", _wrap_SBM_to_sparse_init_memory, METH_VARARGS, NULL},
	 { (char *)"SBM_row_permutation", _wrap_SBM_row_permutation, METH_VARARGS, NULL},
	 { (char *)"SBM_column_permutation", _wrap_SBM_column_permutation, METH_VARARGS, NULL},
	 { (char *)"SBCM_null", _wrap_SBCM_null, METH_VARARGS, NULL},
	 { (char *)"SBCM_new", _wrap_SBCM_new, METH_VARARGS, NULL},
	 { (char *)"SBCM_new_3x3", _wrap_SBCM_new_3x3, METH_VARARGS, NULL},
	 { (char *)"SBCM_free_3x3", _wrap_SBCM_free_3x3, METH_VARARGS, NULL},
	 { (char *)"SBCM_to_SBM", _wrap_SBCM_to_SBM, METH_VARARGS, NULL},
	 { (char *)"SBM_free_from_SBCM", _wrap_SBM_free_from_SBCM, METH_VARARGS, NULL},
	 { (char *)"SBM_from_csparse", _wrap_SBM_from_csparse, METH_VARARGS, NULL},
	 { (char *)"NumericsMatrixInternalData_iWorkSize_set", _wrap_NumericsMatrixInternalData_iWorkSize_set, METH_VARARGS, NULL},
	 { (char *)"NumericsMatrixInternalData_iWorkSize_get", _wrap_NumericsMatrixInternalData_iWorkSize_get, METH_VARARGS, NULL},
	 { (char *)"NumericsMatrixInternalData_iWork_set", _wrap_NumericsMatrixInternalData_iWork_set, METH_VARARGS, NULL},
	 { (char *)"NumericsMatrixInternalData_iWork_get", _wrap_NumericsMatrixInternalData_iWork_get, METH_VARARGS, NULL},
	 { (char *)"NumericsMatrixInternalData_sizeof_elt_set", _wrap_NumericsMatrixInternalData_sizeof_elt_set, METH_VARARGS, NULL},
	 { (char *)"NumericsMatrixInternalData_sizeof_elt_get", _wrap_NumericsMatrixInternalData_sizeof_elt_get, METH_VARARGS, NULL},
	 { (char *)"NumericsMatrixInternalData_dWorkSize_set", _wrap_NumericsMatrixInternalData_dWorkSize_set, METH_VARARGS, NULL},
	 { (char *)"NumericsMatrixInternalData_dWorkSize_get", _wrap_NumericsMatrixInternalData_dWorkSize_get, METH_VARARGS, NULL},
	 { (char *)"NumericsMatrixInternalData_dWork_set", _wrap_NumericsMatrixInternalData_dWork_set, METH_VARARGS, NULL},
	 { (char *)"NumericsMatrixInternalData_dWork_get", _wrap_NumericsMatrixInternalData_dWork_get, METH_VARARGS, NULL},
	 { (char *)"NumericsMatrixInternalData_isLUfactorized_set", _wrap_NumericsMatrixInternalData_isLUfactorized_set, METH_VARARGS, NULL},
	 { (char *)"NumericsMatrixInternalData_isLUfactorized_get", _wrap_NumericsMatrixInternalData_isLUfactorized_get, METH_VARARGS, NULL},
	 { (char *)"NumericsMatrixInternalData_isInversed_set", _wrap_NumericsMatrixInternalData_isInversed_set, METH_VARARGS, NULL},
	 { (char *)"NumericsMatrixInternalData_isInversed_get", _wrap_NumericsMatrixInternalData_isInversed_get, METH_VARARGS, NULL},
	 { (char *)"new_NumericsMatrixInternalData", _wrap_new_NumericsMatrixInternalData, METH_VARARGS, NULL},
	 { (char *)"delete_NumericsMatrixInternalData", _wrap_delete_NumericsMatrixInternalData, METH_VARARGS, NULL},
	 { (char *)"NumericsMatrixInternalData_swigregister", NumericsMatrixInternalData_swigregister, METH_VARARGS, NULL},
	 { (char *)"NumericsMatrix_storageType_set", _wrap_NumericsMatrix_storageType_set, METH_VARARGS, NULL},
	 { (char *)"NumericsMatrix_storageType_get", _wrap_NumericsMatrix_storageType_get, METH_VARARGS, NULL},
	 { (char *)"NumericsMatrix_size0_set", _wrap_NumericsMatrix_size0_set, METH_VARARGS, NULL},
	 { (char *)"NumericsMatrix_size0_get", _wrap_NumericsMatrix_size0_get, METH_VARARGS, NULL},
	 { (char *)"NumericsMatrix_size1_set", _wrap_NumericsMatrix_size1_set, METH_VARARGS, NULL},
	 { (char *)"NumericsMatrix_size1_get", _wrap_NumericsMatrix_size1_get, METH_VARARGS, NULL},
	 { (char *)"NumericsMatrix_matrix0_set", _wrap_NumericsMatrix_matrix0_set, METH_VARARGS, NULL},
	 { (char *)"NumericsMatrix_matrix0_get", _wrap_NumericsMatrix_matrix0_get, METH_VARARGS, NULL},
	 { (char *)"NumericsMatrix_matrix1_set", _wrap_NumericsMatrix_matrix1_set, METH_VARARGS, NULL},
	 { (char *)"NumericsMatrix_matrix1_get", _wrap_NumericsMatrix_matrix1_get, METH_VARARGS, NULL},
	 { (char *)"NumericsMatrix_matrix2_set", _wrap_NumericsMatrix_matrix2_set, METH_VARARGS, NULL},
	 { (char *)"NumericsMatrix_matrix2_get", _wrap_NumericsMatrix_matrix2_get, METH_VARARGS, NULL},
	 { (char *)"NumericsMatrix_internalData_set", _wrap_NumericsMatrix_internalData_set, METH_VARARGS, NULL},
	 { (char *)"NumericsMatrix_internalData_get", _wrap_NumericsMatrix_internalData_get, METH_VARARGS, NULL},
	 { (char *)"new_NumericsMatrix", _wrap_new_NumericsMatrix, METH_VARARGS, NULL},
	 { (char *)"NumericsMatrix_set_matrix0", _wrap_NumericsMatrix_set_matrix0, METH_VARARGS, NULL},
	 { (char *)"NumericsMatrix_get_matrix0", _wrap_NumericsMatrix_get_matrix0, METH_VARARGS, NULL},
	 { (char *)"NumericsMatrix___setitem__", _wrap_NumericsMatrix___setitem__, METH_VARARGS, NULL},
	 { (char *)"NumericsMatrix___getitem__", _wrap_NumericsMatrix___getitem__, METH_VARARGS, NULL},
	 { (char *)"NumericsMatrix___len__", _wrap_NumericsMatrix___len__, METH_VARARGS, NULL},
	 { (char *)"delete_NumericsMatrix", _wrap_delete_NumericsMatrix, METH_VARARGS, NULL},
	 { (char *)"NumericsMatrix_swigregister", NumericsMatrix_swigregister, METH_VARARGS, NULL},
	 { (char *)"NM_new", _wrap_NM_new, METH_VARARGS, NULL},
	 { (char *)"NM_eye", _wrap_NM_eye, METH_VARARGS, NULL},
	 { (char *)"NM_create", _wrap_NM_create, METH_VARARGS, NULL},
	 { (char *)"NM_create_from_data", _wrap_NM_create_from_data, METH_VARARGS, NULL},
	 { (char *)"NM_create_from_filename", _wrap_NM_create_from_filename, METH_VARARGS, NULL},
	 { (char *)"NM_create_from_file", _wrap_NM_create_from_file, METH_VARARGS, NULL},
	 { (char *)"NM_copy", _wrap_NM_copy, METH_VARARGS, NULL},
	 { (char *)"NM_copy_to_sparse", _wrap_NM_copy_to_sparse, METH_VARARGS, NULL},
	 { (char *)"NM_duplicate", _wrap_NM_duplicate, METH_VARARGS, NULL},
	 { (char *)"numericsSparseMatrix", _wrap_numericsSparseMatrix, METH_VARARGS, NULL},
	 { (char *)"NM_triplet", _wrap_NM_triplet, METH_VARARGS, NULL},
	 { (char *)"NM_csc", _wrap_NM_csc, METH_VARARGS, NULL},
	 { (char *)"NM_csc_trans", _wrap_NM_csc_trans, METH_VARARGS, NULL},
	 { (char *)"NM_csr", _wrap_NM_csr, METH_VARARGS, NULL},
	 { (char *)"NM_fill", _wrap_NM_fill, METH_VARARGS, NULL},
	 { (char *)"NM_new_SBM", _wrap_NM_new_SBM, METH_VARARGS, NULL},
	 { (char *)"NM_transpose", _wrap_NM_transpose, METH_VARARGS, NULL},
	 { (char *)"NM_null", _wrap_NM_null, METH_VARARGS, NULL},
	 { (char *)"NM_update_size", _wrap_NM_update_size, METH_VARARGS, NULL},
	 { (char *)"NM_csc_alloc", _wrap_NM_csc_alloc, METH_VARARGS, NULL},
	 { (char *)"NM_csc_empty_alloc", _wrap_NM_csc_empty_alloc, METH_VARARGS, NULL},
	 { (char *)"NM_triplet_alloc", _wrap_NM_triplet_alloc, METH_VARARGS, NULL},
	 { (char *)"NM_csr_alloc", _wrap_NM_csr_alloc, METH_VARARGS, NULL},
	 { (char *)"NM_free", _wrap_NM_free, METH_VARARGS, NULL},
	 { (char *)"NM_zentry", _wrap_NM_zentry, METH_VARARGS, NULL},
	 { (char *)"NM_get_value", _wrap_NM_get_value, METH_VARARGS, NULL},
	 { (char *)"NM_equal", _wrap_NM_equal, METH_VARARGS, NULL},
	 { (char *)"NM_compare", _wrap_NM_compare, METH_VARARGS, NULL},
	 { (char *)"NM_nnz", _wrap_NM_nnz, METH_VARARGS, NULL},
	 { (char *)"NM_extract_diag_block", _wrap_NM_extract_diag_block, METH_VARARGS, NULL},
	 { (char *)"NM_extract_diag_block3", _wrap_NM_extract_diag_block3, METH_VARARGS, NULL},
	 { (char *)"NM_copy_diag_block3", _wrap_NM_copy_diag_block3, METH_VARARGS, NULL},
	 { (char *)"NM_prod_mv_3x3", _wrap_NM_prod_mv_3x3, METH_VARARGS, NULL},
	 { (char *)"NM_row_prod", _wrap_NM_row_prod, METH_VARARGS, NULL},
	 { (char *)"NM_row_prod_no_diag", _wrap_NM_row_prod_no_diag, METH_VARARGS, NULL},
	 { (char *)"NM_row_prod_no_diag3", _wrap_NM_row_prod_no_diag3, METH_VARARGS, NULL},
	 { (char *)"NM_row_prod_no_diag1x1", _wrap_NM_row_prod_no_diag1x1, METH_VARARGS, NULL},
	 { (char *)"NM_gemv", _wrap_NM_gemv, METH_VARARGS, NULL},
	 { (char *)"NM_gemm", _wrap_NM_gemm, METH_VARARGS, NULL},
	 { (char *)"NM_multiply", _wrap_NM_multiply, METH_VARARGS, NULL},
	 { (char *)"NM_tgemv", _wrap_NM_tgemv, METH_VARARGS, NULL},
	 { (char *)"NM_dense_to_sparse", _wrap_NM_dense_to_sparse, METH_VARARGS, NULL},
	 { (char *)"NM_to_dense", _wrap_NM_to_dense, METH_VARARGS, NULL},
	 { (char *)"NM_dense_display_matlab", _wrap_NM_dense_display_matlab, METH_VARARGS, NULL},
	 { (char *)"NM_dense_display", _wrap_NM_dense_display, METH_VARARGS, NULL},
	 { (char *)"NM_vector_display", _wrap_NM_vector_display, METH_VARARGS, NULL},
	 { (char *)"NM_display", _wrap_NM_display, METH_VARARGS, NULL},
	 { (char *)"NM_display_row_by_row", _wrap_NM_display_row_by_row, METH_VARARGS, NULL},
	 { (char *)"NM_write_in_filename", _wrap_NM_write_in_filename, METH_VARARGS, NULL},
	 { (char *)"NM_read_in_filename", _wrap_NM_read_in_filename, METH_VARARGS, NULL},
	 { (char *)"NM_write_in_file", _wrap_NM_write_in_file, METH_VARARGS, NULL},
	 { (char *)"NM_read_in_file", _wrap_NM_read_in_file, METH_VARARGS, NULL},
	 { (char *)"NM_new_from_file", _wrap_NM_new_from_file, METH_VARARGS, NULL},
	 { (char *)"NM_new_from_filename", _wrap_NM_new_from_filename, METH_VARARGS, NULL},
	 { (char *)"NM_write_in_file_scilab", _wrap_NM_write_in_file_scilab, METH_VARARGS, NULL},
	 { (char *)"NM_write_in_file_python", _wrap_NM_write_in_file_python, METH_VARARGS, NULL},
	 { (char *)"NM_read_in_file_scilab", _wrap_NM_read_in_file_scilab, METH_VARARGS, NULL},
	 { (char *)"NM_clearDense", _wrap_NM_clearDense, METH_VARARGS, NULL},
	 { (char *)"NM_clearSparseBlock", _wrap_NM_clearSparseBlock, METH_VARARGS, NULL},
	 { (char *)"NM_clearSparse", _wrap_NM_clearSparse, METH_VARARGS, NULL},
	 { (char *)"NM_clearTriplet", _wrap_NM_clearTriplet, METH_VARARGS, NULL},
	 { (char *)"NM_clearCSC", _wrap_NM_clearCSC, METH_VARARGS, NULL},
	 { (char *)"NM_clearCSCTranspose", _wrap_NM_clearCSCTranspose, METH_VARARGS, NULL},
	 { (char *)"NM_clearCSR", _wrap_NM_clearCSR, METH_VARARGS, NULL},
	 { (char *)"NM_clearSparseStorage", _wrap_NM_clearSparseStorage, METH_VARARGS, NULL},
	 { (char *)"NM_gesv_expert", _wrap_NM_gesv_expert, METH_VARARGS, NULL},
	 { (char *)"NM_gesv_expert_multiple_rhs", _wrap_NM_gesv_expert_multiple_rhs, METH_VARARGS, NULL},
	 { (char *)"NM_inv", _wrap_NM_inv, METH_VARARGS, NULL},
	 { (char *)"NM_inverse_diagonal_block_matrix_in_place", _wrap_NM_inverse_diagonal_block_matrix_in_place, METH_VARARGS, NULL},
	 { (char *)"NM_gesv", _wrap_NM_gesv, METH_VARARGS, NULL},
	 { (char *)"NM_setSparseSolver", _wrap_NM_setSparseSolver, METH_VARARGS, NULL},
	 { (char *)"NM_internalData", _wrap_NM_internalData, METH_VARARGS, NULL},
	 { (char *)"NM_internalData_new", _wrap_NM_internalData_new, METH_VARARGS, NULL},
	 { (char *)"NM_internalData_copy", _wrap_NM_internalData_copy, METH_VARARGS, NULL},
	 { (char *)"NM_iWork", _wrap_NM_iWork, METH_VARARGS, NULL},
	 { (char *)"NM_dWork", _wrap_NM_dWork, METH_VARARGS, NULL},
	 { (char *)"NM_add_to_diag3", _wrap_NM_add_to_diag3, METH_VARARGS, NULL},
	 { (char *)"NM_add", _wrap_NM_add, METH_VARARGS, NULL},
	 { (char *)"NM_assert", _wrap_NM_assert, METH_VARARGS, NULL},
	 { (char *)"NM_check", _wrap_NM_check, METH_VARARGS, NULL},
	 { (char *)"NM_norm_1", _wrap_NM_norm_1, METH_VARARGS, NULL},
	 { (char *)"NM_norm_inf", _wrap_NM_norm_inf, METH_VARARGS, NULL},
	 { (char *)"NM_is_symmetric", _wrap_NM_is_symmetric, METH_VARARGS, NULL},
	 { (char *)"NM_symmetry_discrepancy", _wrap_NM_symmetry_discrepancy, METH_VARARGS, NULL},
	 { (char *)"linalg_data_t_id_set", _wrap_linalg_data_t_id_set, METH_VARARGS, NULL},
	 { (char *)"linalg_data_t_id_get", _wrap_linalg_data_t_id_get, METH_VARARGS, NULL},
	 { (char *)"linalg_data_t_free_fn_set", _wrap_linalg_data_t_free_fn_set, METH_VARARGS, NULL},
	 { (char *)"linalg_data_t_free_fn_get", _wrap_linalg_data_t_free_fn_get, METH_VARARGS, NULL},
	 { (char *)"new_linalg_data_t", _wrap_new_linalg_data_t, METH_VARARGS, NULL},
	 { (char *)"delete_linalg_data_t", _wrap_delete_linalg_data_t, METH_VARARGS, NULL},
	 { (char *)"linalg_data_t_swigregister", linalg_data_t_swigregister, METH_VARARGS, NULL},
	 { (char *)"NSM_linear_solver_params_solver_set", _wrap_NSM_linear_solver_params_solver_set, METH_VARARGS, NULL},
	 { (char *)"NSM_linear_solver_params_solver_get", _wrap_NSM_linear_solver_params_solver_get, METH_VARARGS, NULL},
	 { (char *)"NSM_linear_solver_params_solver_data_set", _wrap_NSM_linear_solver_params_solver_data_set, METH_VARARGS, NULL},
	 { (char *)"NSM_linear_solver_params_solver_data_get", _wrap_NSM_linear_solver_params_solver_data_get, METH_VARARGS, NULL},
	 { (char *)"NSM_linear_solver_params_solver_free_hook_set", _wrap_NSM_linear_solver_params_solver_free_hook_set, METH_VARARGS, NULL},
	 { (char *)"NSM_linear_solver_params_solver_free_hook_get", _wrap_NSM_linear_solver_params_solver_free_hook_get, METH_VARARGS, NULL},
	 { (char *)"NSM_linear_solver_params_iWork_set", _wrap_NSM_linear_solver_params_iWork_set, METH_VARARGS, NULL},
	 { (char *)"NSM_linear_solver_params_iWork_get", _wrap_NSM_linear_solver_params_iWork_get, METH_VARARGS, NULL},
	 { (char *)"NSM_linear_solver_params_iWorkSize_set", _wrap_NSM_linear_solver_params_iWorkSize_set, METH_VARARGS, NULL},
	 { (char *)"NSM_linear_solver_params_iWorkSize_get", _wrap_NSM_linear_solver_params_iWorkSize_get, METH_VARARGS, NULL},
	 { (char *)"NSM_linear_solver_params_dWork_set", _wrap_NSM_linear_solver_params_dWork_set, METH_VARARGS, NULL},
	 { (char *)"NSM_linear_solver_params_dWork_get", _wrap_NSM_linear_solver_params_dWork_get, METH_VARARGS, NULL},
	 { (char *)"NSM_linear_solver_params_dWorkSize_set", _wrap_NSM_linear_solver_params_dWorkSize_set, METH_VARARGS, NULL},
	 { (char *)"NSM_linear_solver_params_dWorkSize_get", _wrap_NSM_linear_solver_params_dWorkSize_get, METH_VARARGS, NULL},
	 { (char *)"NSM_linear_solver_params_linalg_data_set", _wrap_NSM_linear_solver_params_linalg_data_set, METH_VARARGS, NULL},
	 { (char *)"NSM_linear_solver_params_linalg_data_get", _wrap_NSM_linear_solver_params_linalg_data_get, METH_VARARGS, NULL},
	 { (char *)"new_NSM_linear_solver_params", _wrap_new_NSM_linear_solver_params, METH_VARARGS, NULL},
	 { (char *)"delete_NSM_linear_solver_params", _wrap_delete_NSM_linear_solver_params, METH_VARARGS, NULL},
	 { (char *)"NSM_linear_solver_params_swigregister", NSM_linear_solver_params_swigregister, METH_VARARGS, NULL},
	 { (char *)"NumericsSparseMatrix_triplet_set", _wrap_NumericsSparseMatrix_triplet_set, METH_VARARGS, NULL},
	 { (char *)"NumericsSparseMatrix_triplet_get", _wrap_NumericsSparseMatrix_triplet_get, METH_VARARGS, NULL},
	 { (char *)"NumericsSparseMatrix_csc_set", _wrap_NumericsSparseMatrix_csc_set, METH_VARARGS, NULL},
	 { (char *)"NumericsSparseMatrix_csc_get", _wrap_NumericsSparseMatrix_csc_get, METH_VARARGS, NULL},
	 { (char *)"NumericsSparseMatrix_trans_csc_set", _wrap_NumericsSparseMatrix_trans_csc_set, METH_VARARGS, NULL},
	 { (char *)"NumericsSparseMatrix_trans_csc_get", _wrap_NumericsSparseMatrix_trans_csc_get, METH_VARARGS, NULL},
	 { (char *)"NumericsSparseMatrix_csr_set", _wrap_NumericsSparseMatrix_csr_set, METH_VARARGS, NULL},
	 { (char *)"NumericsSparseMatrix_csr_get", _wrap_NumericsSparseMatrix_csr_get, METH_VARARGS, NULL},
	 { (char *)"NumericsSparseMatrix_diag_indx_set", _wrap_NumericsSparseMatrix_diag_indx_set, METH_VARARGS, NULL},
	 { (char *)"NumericsSparseMatrix_diag_indx_get", _wrap_NumericsSparseMatrix_diag_indx_get, METH_VARARGS, NULL},
	 { (char *)"NumericsSparseMatrix_origin_set", _wrap_NumericsSparseMatrix_origin_set, METH_VARARGS, NULL},
	 { (char *)"NumericsSparseMatrix_origin_get", _wrap_NumericsSparseMatrix_origin_get, METH_VARARGS, NULL},
	 { (char *)"NumericsSparseMatrix_linearSolverParams_set", _wrap_NumericsSparseMatrix_linearSolverParams_set, METH_VARARGS, NULL},
	 { (char *)"NumericsSparseMatrix_linearSolverParams_get", _wrap_NumericsSparseMatrix_linearSolverParams_get, METH_VARARGS, NULL},
	 { (char *)"new_NumericsSparseMatrix", _wrap_new_NumericsSparseMatrix, METH_VARARGS, NULL},
	 { (char *)"delete_NumericsSparseMatrix", _wrap_delete_NumericsSparseMatrix, METH_VARARGS, NULL},
	 { (char *)"NumericsSparseMatrix_swigregister", NumericsSparseMatrix_swigregister, METH_VARARGS, NULL},
	 { (char *)"NSM_null", _wrap_NSM_null, METH_VARARGS, NULL},
	 { (char *)"NSM_new", _wrap_NSM_new, METH_VARARGS, NULL},
	 { (char *)"NSM_triplet_eye", _wrap_NSM_triplet_eye, METH_VARARGS, NULL},
	 { (char *)"NSM_free", _wrap_NSM_free, METH_VARARGS, NULL},
	 { (char *)"NSM_free_p", _wrap_NSM_free_p, METH_VARARGS, NULL},
	 { (char *)"NSM_data", _wrap_NSM_data, METH_VARARGS, NULL},
	 { (char *)"NSM_solver_data", _wrap_NSM_solver_data, METH_VARARGS, NULL},
	 { (char *)"NSM_workspace", _wrap_NSM_workspace, METH_VARARGS, NULL},
	 { (char *)"NSM_nnz", _wrap_NSM_nnz, METH_VARARGS, NULL},
	 { (char *)"NSM_diag_indices", _wrap_NSM_diag_indices, METH_VARARGS, NULL},
	 { (char *)"NSM_extract_block", _wrap_NSM_extract_block, METH_VARARGS, NULL},
	 { (char *)"NSM_linearSolverParams_free", _wrap_NSM_linearSolverParams_free, METH_VARARGS, NULL},
	 { (char *)"NSM_linearSolverParams_new", _wrap_NSM_linearSolverParams_new, METH_VARARGS, NULL},
	 { (char *)"NSM_linearSolverParams", _wrap_NSM_linearSolverParams, METH_VARARGS, NULL},
	 { (char *)"NSM_fix_csc", _wrap_NSM_fix_csc, METH_VARARGS, NULL},
	 { (char *)"NSM_origin", _wrap_NSM_origin, METH_VARARGS, NULL},
	 { (char *)"NSM_get_origin", _wrap_NSM_get_origin, METH_VARARGS, NULL},
	 { (char *)"NSM_write_in_file", _wrap_NSM_write_in_file, METH_VARARGS, NULL},
	 { (char *)"NSM_new_from_file", _wrap_NSM_new_from_file, METH_VARARGS, NULL},
	 { (char *)"NSM_to_dense", _wrap_NSM_to_dense, METH_VARARGS, NULL},
	 { (char *)"MLCP_isStorageType1_set", _wrap_MLCP_isStorageType1_set, METH_VARARGS, NULL},
	 { (char *)"MLCP_isStorageType1_get", _wrap_MLCP_isStorageType1_get, METH_VARARGS, NULL},
	 { (char *)"MLCP_isStorageType2_set", _wrap_MLCP_isStorageType2_set, METH_VARARGS, NULL},
	 { (char *)"MLCP_isStorageType2_get", _wrap_MLCP_isStorageType2_get, METH_VARARGS, NULL},
	 { (char *)"MLCP_n_set", _wrap_MLCP_n_set, METH_VARARGS, NULL},
	 { (char *)"MLCP_n_get", _wrap_MLCP_n_get, METH_VARARGS, NULL},
	 { (char *)"MLCP_m_set", _wrap_MLCP_m_set, METH_VARARGS, NULL},
	 { (char *)"MLCP_m_get", _wrap_MLCP_m_get, METH_VARARGS, NULL},
	 { (char *)"MLCP_blocksRows_set", _wrap_MLCP_blocksRows_set, METH_VARARGS, NULL},
	 { (char *)"MLCP_blocksRows_get", _wrap_MLCP_blocksRows_get, METH_VARARGS, NULL},
	 { (char *)"MLCP_blocksIsComp_set", _wrap_MLCP_blocksIsComp_set, METH_VARARGS, NULL},
	 { (char *)"MLCP_blocksIsComp_get", _wrap_MLCP_blocksIsComp_get, METH_VARARGS, NULL},
	 { (char *)"MLCP_M_set", _wrap_MLCP_M_set, METH_VARARGS, NULL},
	 { (char *)"MLCP_M_get", _wrap_MLCP_M_get, METH_VARARGS, NULL},
	 { (char *)"MLCP_q_set", _wrap_MLCP_q_set, METH_VARARGS, NULL},
	 { (char *)"MLCP_q_get", _wrap_MLCP_q_get, METH_VARARGS, NULL},
	 { (char *)"MLCP_A_set", _wrap_MLCP_A_set, METH_VARARGS, NULL},
	 { (char *)"MLCP_A_get", _wrap_MLCP_A_get, METH_VARARGS, NULL},
	 { (char *)"MLCP_B_set", _wrap_MLCP_B_set, METH_VARARGS, NULL},
	 { (char *)"MLCP_B_get", _wrap_MLCP_B_get, METH_VARARGS, NULL},
	 { (char *)"MLCP_C_set", _wrap_MLCP_C_set, METH_VARARGS, NULL},
	 { (char *)"MLCP_C_get", _wrap_MLCP_C_get, METH_VARARGS, NULL},
	 { (char *)"MLCP_D_set", _wrap_MLCP_D_set, METH_VARARGS, NULL},
	 { (char *)"MLCP_D_get", _wrap_MLCP_D_get, METH_VARARGS, NULL},
	 { (char *)"MLCP_a_set", _wrap_MLCP_a_set, METH_VARARGS, NULL},
	 { (char *)"MLCP_a_get", _wrap_MLCP_a_get, METH_VARARGS, NULL},
	 { (char *)"MLCP_b_set", _wrap_MLCP_b_set, METH_VARARGS, NULL},
	 { (char *)"MLCP_b_get", _wrap_MLCP_b_get, METH_VARARGS, NULL},
	 { (char *)"new_MLCP", _wrap_new_MLCP, METH_VARARGS, NULL},
	 { (char *)"delete_MLCP", _wrap_delete_MLCP, METH_VARARGS, NULL},
	 { (char *)"MLCP_swigregister", MLCP_swigregister, METH_VARARGS, NULL},
	 { (char *)"mixedLinearComplementarity_display", _wrap_mixedLinearComplementarity_display, METH_VARARGS, NULL},
	 { (char *)"mixedLinearComplementarity_printInFile", _wrap_mixedLinearComplementarity_printInFile, METH_VARARGS, NULL},
	 { (char *)"mixedLinearComplementarity_newFromFile", _wrap_mixedLinearComplementarity_newFromFile, METH_VARARGS, NULL},
	 { (char *)"mixedLinearComplementarity_newFromFileOld", _wrap_mixedLinearComplementarity_newFromFileOld, METH_VARARGS, NULL},
	 { (char *)"mixedLinearComplementarity_newFromFilename", _wrap_mixedLinearComplementarity_newFromFilename, METH_VARARGS, NULL},
	 { (char *)"freeMixedLinearComplementarityProblem", _wrap_freeMixedLinearComplementarityProblem, METH_VARARGS, NULL},
	 { (char *)"newMLCP", _wrap_newMLCP, METH_VARARGS, NULL},
	 { (char *)"mlcp_driver_init", _wrap_mlcp_driver_init, METH_VARARGS, NULL},
	 { (char *)"mlcp_driver_reset", _wrap_mlcp_driver_reset, METH_VARARGS, NULL},
	 { (char *)"mlcp_alloc_working_memory", _wrap_mlcp_alloc_working_memory, METH_VARARGS, NULL},
	 { (char *)"mlcp_free_working_memory", _wrap_mlcp_free_working_memory, METH_VARARGS, NULL},
	 { (char *)"mlcp_driver_get_iwork", _wrap_mlcp_driver_get_iwork, METH_VARARGS, NULL},
	 { (char *)"mlcp_driver_get_dwork", _wrap_mlcp_driver_get_dwork, METH_VARARGS, NULL},
	 { (char *)"mlcp_pgs", _wrap_mlcp_pgs, METH_VARARGS, NULL},
	 { (char *)"mlcp_rpgs", _wrap_mlcp_rpgs, METH_VARARGS, NULL},
	 { (char *)"mlcp_psor", _wrap_mlcp_psor, METH_VARARGS, NULL},
	 { (char *)"mlcp_rpsor", _wrap_mlcp_rpsor, METH_VARARGS, NULL},
	 { (char *)"mlcp_path", _wrap_mlcp_path, METH_VARARGS, NULL},
	 { (char *)"mlcp_enum", _wrap_mlcp_enum, METH_VARARGS, NULL},
	 { (char *)"mlcp_direct", _wrap_mlcp_direct, METH_VARARGS, NULL},
	 { (char *)"mlcp_direct_enum", _wrap_mlcp_direct_enum, METH_VARARGS, NULL},
	 { (char *)"mlcp_direct_simplex", _wrap_mlcp_direct_simplex, METH_VARARGS, NULL},
	 { (char *)"mlcp_direct_path", _wrap_mlcp_direct_path, METH_VARARGS, NULL},
	 { (char *)"mlcp_simplex", _wrap_mlcp_simplex, METH_VARARGS, NULL},
	 { (char *)"mlcp_FB", _wrap_mlcp_FB, METH_VARARGS, NULL},
	 { (char *)"mlcp_direct_FB", _wrap_mlcp_direct_FB, METH_VARARGS, NULL},
	 { (char *)"mlcp_pgs_SBM", _wrap_mlcp_pgs_SBM, METH_VARARGS, NULL},
	 { (char *)"mixedLinearComplementarity_pgs_SBM_setDefaultSolverOptions", _wrap_mixedLinearComplementarity_pgs_SBM_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"mlcp_compute_error", _wrap_mlcp_compute_error, METH_VARARGS, NULL},
	 { (char *)"mixedLinearComplementarity_default_setDefaultSolverOptions", _wrap_mixedLinearComplementarity_default_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"mixedLinearComplementarity_deleteDefaultSolverOptions", _wrap_mixedLinearComplementarity_deleteDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"mixedLinearComplementarity_setDefaultSolverOptions", _wrap_mixedLinearComplementarity_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"mixedLinearComplementarity_directEnum_setDefaultSolverOptions", _wrap_mixedLinearComplementarity_directEnum_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"mixedLinearComplementarity_directFB_setDefaultSolverOptions", _wrap_mixedLinearComplementarity_directFB_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"mixedLinearComplementarity_directPath_setDefaultSolverOptions", _wrap_mixedLinearComplementarity_directPath_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"mixedLinearComplementarity_directPathEnum_setDefaultSolverOptions", _wrap_mixedLinearComplementarity_directPathEnum_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"mixedLinearComplementarity_directSimplex_setDefaultSolverOptions", _wrap_mixedLinearComplementarity_directSimplex_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"mixedLinearComplementarity_enum_setDefaultSolverOptions", _wrap_mixedLinearComplementarity_enum_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"mixedLinearComplementarity_fb_setDefaultSolverOptions", _wrap_mixedLinearComplementarity_fb_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"mixedLinearComplementarity_path_setDefaultSolverOptions", _wrap_mixedLinearComplementarity_path_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"mixedLinearComplementarity_pathEnum_setDefaultSolverOptions", _wrap_mixedLinearComplementarity_pathEnum_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"mixedLinearComplementarity_pgs_setDefaultSolverOptions", _wrap_mixedLinearComplementarity_pgs_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"mixedLinearComplementarity_rpgs_setDefaultSolverOptions", _wrap_mixedLinearComplementarity_rpgs_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"mixedLinearComplementarity_simplex_setDefaultSolverOptions", _wrap_mixedLinearComplementarity_simplex_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"mixedLinearComplementarity_rpsor_setDefaultSolverOptions", _wrap_mixedLinearComplementarity_rpsor_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"mixedLinearComplementarity_psor_setDefaultSolverOptions", _wrap_mixedLinearComplementarity_psor_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"LCP_size_set", _wrap_LCP_size_set, METH_VARARGS, NULL},
	 { (char *)"LCP_size_get", _wrap_LCP_size_get, METH_VARARGS, NULL},
	 { (char *)"LCP_M_set", _wrap_LCP_M_set, METH_VARARGS, NULL},
	 { (char *)"LCP_M_get", _wrap_LCP_M_get, METH_VARARGS, NULL},
	 { (char *)"LCP_q_set", _wrap_LCP_q_set, METH_VARARGS, NULL},
	 { (char *)"LCP_q_get", _wrap_LCP_q_get, METH_VARARGS, NULL},
	 { (char *)"new_LCP", _wrap_new_LCP, METH_VARARGS, NULL},
	 { (char *)"delete_LCP", _wrap_delete_LCP, METH_VARARGS, NULL},
	 { (char *)"LCP_swigregister", LCP_swigregister, METH_VARARGS, NULL},
	 { (char *)"linearComplementarity_display", _wrap_linearComplementarity_display, METH_VARARGS, NULL},
	 { (char *)"linearComplementarity_printInFile", _wrap_linearComplementarity_printInFile, METH_VARARGS, NULL},
	 { (char *)"linearComplementarity_newFromFile", _wrap_linearComplementarity_newFromFile, METH_VARARGS, NULL},
	 { (char *)"linearComplementarity_newFromFilename", _wrap_linearComplementarity_newFromFilename, METH_VARARGS, NULL},
	 { (char *)"freeLinearComplementarityProblem", _wrap_freeLinearComplementarityProblem, METH_VARARGS, NULL},
	 { (char *)"newLCP", _wrap_newLCP, METH_VARARGS, NULL},
	 { (char *)"linearComplementarity_setDefaultSolverOptions", _wrap_linearComplementarity_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"lcp_qp", _wrap_lcp_qp, METH_VARARGS, NULL},
	 { (char *)"linearComplementarity_qp_setDefaultSolverOptions", _wrap_linearComplementarity_qp_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"lcp_cpg", _wrap_lcp_cpg, METH_VARARGS, NULL},
	 { (char *)"linearComplementarity_cpg_setDefaultSolverOptions", _wrap_linearComplementarity_cpg_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"lcp_pgs", _wrap_lcp_pgs, METH_VARARGS, NULL},
	 { (char *)"linearComplementarity_pgs_setDefaultSolverOptions", _wrap_linearComplementarity_pgs_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"lcp_rpgs", _wrap_lcp_rpgs, METH_VARARGS, NULL},
	 { (char *)"linearComplementarity_rpgs_setDefaultSolverOptions", _wrap_linearComplementarity_rpgs_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"lcp_psor", _wrap_lcp_psor, METH_VARARGS, NULL},
	 { (char *)"linearComplementarity_psor_setDefaultSolverOptions", _wrap_linearComplementarity_psor_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"lcp_nsqp", _wrap_lcp_nsqp, METH_VARARGS, NULL},
	 { (char *)"linearComplementarity_nsqp_setDefaultSolverOptions", _wrap_linearComplementarity_nsqp_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"lcp_latin", _wrap_lcp_latin, METH_VARARGS, NULL},
	 { (char *)"linearComplementarity_latin_setDefaultSolverOptions", _wrap_linearComplementarity_latin_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"lcp_latin_w", _wrap_lcp_latin_w, METH_VARARGS, NULL},
	 { (char *)"linearComplementarity_latin_w_setDefaultSolverOptions", _wrap_linearComplementarity_latin_w_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"lcp_lexicolemke", _wrap_lcp_lexicolemke, METH_VARARGS, NULL},
	 { (char *)"linearComplementarity_lexicolemke_setDefaultSolverOptions", _wrap_linearComplementarity_lexicolemke_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"lcp_newton_min", _wrap_lcp_newton_min, METH_VARARGS, NULL},
	 { (char *)"linearComplementarity_newton_min_setDefaultSolverOptions", _wrap_linearComplementarity_newton_min_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"lcp_newton_FB", _wrap_lcp_newton_FB, METH_VARARGS, NULL},
	 { (char *)"lcp_newton_minFB", _wrap_lcp_newton_minFB, METH_VARARGS, NULL},
	 { (char *)"lcp_path", _wrap_lcp_path, METH_VARARGS, NULL},
	 { (char *)"lcp_enum", _wrap_lcp_enum, METH_VARARGS, NULL},
	 { (char *)"lcp_enum_init", _wrap_lcp_enum_init, METH_VARARGS, NULL},
	 { (char *)"lcp_enum_reset", _wrap_lcp_enum_reset, METH_VARARGS, NULL},
	 { (char *)"linearComplementarity_enum_setDefaultSolverOptions", _wrap_linearComplementarity_enum_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"lcp_avi_caoferris", _wrap_lcp_avi_caoferris, METH_VARARGS, NULL},
	 { (char *)"lcp_pivot", _wrap_lcp_pivot, METH_VARARGS, NULL},
	 { (char *)"lcp_pivot_covering_vector", _wrap_lcp_pivot_covering_vector, METH_VARARGS, NULL},
	 { (char *)"lcp_pivot_lumod", _wrap_lcp_pivot_lumod, METH_VARARGS, NULL},
	 { (char *)"lcp_pivot_lumod_covering_vector", _wrap_lcp_pivot_lumod_covering_vector, METH_VARARGS, NULL},
	 { (char *)"lcp_pathsearch", _wrap_lcp_pathsearch, METH_VARARGS, NULL},
	 { (char *)"lcp_gams", _wrap_lcp_gams, METH_VARARGS, NULL},
	 { (char *)"lcp_nsgs_SBM", _wrap_lcp_nsgs_SBM, METH_VARARGS, NULL},
	 { (char *)"linearComplementarity_nsgs_SBM_setDefaultSolverOptions", _wrap_linearComplementarity_nsgs_SBM_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"lcp_nsgs_SBM_buildLocalProblem", _wrap_lcp_nsgs_SBM_buildLocalProblem, METH_VARARGS, NULL},
	 { (char *)"lcp_compute_error", _wrap_lcp_compute_error, METH_VARARGS, NULL},
	 { (char *)"lcp_driver_DenseMatrix", _wrap_lcp_driver_DenseMatrix, METH_VARARGS, NULL},
	 { (char *)"lcp_ConvexQP_ProjectedGradient", _wrap_lcp_ConvexQP_ProjectedGradient, METH_VARARGS, NULL},
	 { (char *)"linearComplementarity_ConvexQP_ProjectedGradient_setDefaultSolverOptions", _wrap_linearComplementarity_ConvexQP_ProjectedGradient_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"AVI_size_set", _wrap_AVI_size_set, METH_VARARGS, NULL},
	 { (char *)"AVI_size_get", _wrap_AVI_size_get, METH_VARARGS, NULL},
	 { (char *)"AVI_M_set", _wrap_AVI_M_set, METH_VARARGS, NULL},
	 { (char *)"AVI_M_get", _wrap_AVI_M_get, METH_VARARGS, NULL},
	 { (char *)"AVI_q_set", _wrap_AVI_q_set, METH_VARARGS, NULL},
	 { (char *)"AVI_q_get", _wrap_AVI_q_get, METH_VARARGS, NULL},
	 { (char *)"AVI_d_set", _wrap_AVI_d_set, METH_VARARGS, NULL},
	 { (char *)"AVI_d_get", _wrap_AVI_d_get, METH_VARARGS, NULL},
	 { (char *)"AVI_poly_set", _wrap_AVI_poly_set, METH_VARARGS, NULL},
	 { (char *)"AVI_poly_get", _wrap_AVI_poly_get, METH_VARARGS, NULL},
	 { (char *)"AVI_lb_set", _wrap_AVI_lb_set, METH_VARARGS, NULL},
	 { (char *)"AVI_lb_get", _wrap_AVI_lb_get, METH_VARARGS, NULL},
	 { (char *)"AVI_ub_set", _wrap_AVI_ub_set, METH_VARARGS, NULL},
	 { (char *)"AVI_ub_get", _wrap_AVI_ub_get, METH_VARARGS, NULL},
	 { (char *)"AVI_cones_set", _wrap_AVI_cones_set, METH_VARARGS, NULL},
	 { (char *)"AVI_cones_get", _wrap_AVI_cones_get, METH_VARARGS, NULL},
	 { (char *)"new_AVI", _wrap_new_AVI, METH_VARARGS, NULL},
	 { (char *)"AVI_set_polyhedron", _wrap_AVI_set_polyhedron, METH_VARARGS, NULL},
	 { (char *)"delete_AVI", _wrap_delete_AVI, METH_VARARGS, NULL},
	 { (char *)"AVI_swigregister", AVI_swigregister, METH_VARARGS, NULL},
	 { (char *)"AVI_display", _wrap_AVI_display, METH_VARARGS, NULL},
	 { (char *)"AVI_printInFile", _wrap_AVI_printInFile, METH_VARARGS, NULL},
	 { (char *)"AVI_newFromFile", _wrap_AVI_newFromFile, METH_VARARGS, NULL},
	 { (char *)"AVI_newFromFilename", _wrap_AVI_newFromFilename, METH_VARARGS, NULL},
	 { (char *)"freeAVI", _wrap_freeAVI, METH_VARARGS, NULL},
	 { (char *)"newAVI", _wrap_newAVI, METH_VARARGS, NULL},
	 { (char *)"avi_caoferris", _wrap_avi_caoferris, METH_VARARGS, NULL},
	 { (char *)"avi_pathavi", _wrap_avi_pathavi, METH_VARARGS, NULL},
	 { (char *)"mixedLinearComplementarityProblemFromFile", _wrap_mixedLinearComplementarityProblemFromFile, METH_VARARGS, NULL},
	 { (char *)"MCP_sizeEqualities_set", _wrap_MCP_sizeEqualities_set, METH_VARARGS, NULL},
	 { (char *)"MCP_sizeEqualities_get", _wrap_MCP_sizeEqualities_get, METH_VARARGS, NULL},
	 { (char *)"MCP_sizeInequalities_set", _wrap_MCP_sizeInequalities_set, METH_VARARGS, NULL},
	 { (char *)"MCP_sizeInequalities_get", _wrap_MCP_sizeInequalities_get, METH_VARARGS, NULL},
	 { (char *)"MCP_computeFmcp_set", _wrap_MCP_computeFmcp_set, METH_VARARGS, NULL},
	 { (char *)"MCP_computeFmcp_get", _wrap_MCP_computeFmcp_get, METH_VARARGS, NULL},
	 { (char *)"MCP_computeNablaFmcp_set", _wrap_MCP_computeNablaFmcp_set, METH_VARARGS, NULL},
	 { (char *)"MCP_computeNablaFmcp_get", _wrap_MCP_computeNablaFmcp_get, METH_VARARGS, NULL},
	 { (char *)"MCP_Fmcp_set", _wrap_MCP_Fmcp_set, METH_VARARGS, NULL},
	 { (char *)"MCP_Fmcp_get", _wrap_MCP_Fmcp_get, METH_VARARGS, NULL},
	 { (char *)"MCP_nablaFmcp_set", _wrap_MCP_nablaFmcp_set, METH_VARARGS, NULL},
	 { (char *)"MCP_nablaFmcp_get", _wrap_MCP_nablaFmcp_get, METH_VARARGS, NULL},
	 { (char *)"MCP_set_computeFmcp", _wrap_MCP_set_computeFmcp, METH_VARARGS, NULL},
	 { (char *)"MCP_set_computeNablaFmcp", _wrap_MCP_set_computeNablaFmcp, METH_VARARGS, NULL},
	 { (char *)"MCP_test_call_to_callback", _wrap_MCP_test_call_to_callback, METH_VARARGS, NULL},
	 { (char *)"new_MCP", _wrap_new_MCP, METH_VARARGS, NULL},
	 { (char *)"delete_MCP", _wrap_delete_MCP, METH_VARARGS, NULL},
	 { (char *)"MCP_swigregister", MCP_swigregister, METH_VARARGS, NULL},
	 { (char *)"MixedComplementarityProblem2_n1_set", _wrap_MixedComplementarityProblem2_n1_set, METH_VARARGS, NULL},
	 { (char *)"MixedComplementarityProblem2_n1_get", _wrap_MixedComplementarityProblem2_n1_get, METH_VARARGS, NULL},
	 { (char *)"MixedComplementarityProblem2_n2_set", _wrap_MixedComplementarityProblem2_n2_set, METH_VARARGS, NULL},
	 { (char *)"MixedComplementarityProblem2_n2_get", _wrap_MixedComplementarityProblem2_n2_get, METH_VARARGS, NULL},
	 { (char *)"MixedComplementarityProblem2_compute_Fmcp_set", _wrap_MixedComplementarityProblem2_compute_Fmcp_set, METH_VARARGS, NULL},
	 { (char *)"MixedComplementarityProblem2_compute_Fmcp_get", _wrap_MixedComplementarityProblem2_compute_Fmcp_get, METH_VARARGS, NULL},
	 { (char *)"MixedComplementarityProblem2_compute_nabla_Fmcp_set", _wrap_MixedComplementarityProblem2_compute_nabla_Fmcp_set, METH_VARARGS, NULL},
	 { (char *)"MixedComplementarityProblem2_compute_nabla_Fmcp_get", _wrap_MixedComplementarityProblem2_compute_nabla_Fmcp_get, METH_VARARGS, NULL},
	 { (char *)"MixedComplementarityProblem2_nabla_Fmcp_set", _wrap_MixedComplementarityProblem2_nabla_Fmcp_set, METH_VARARGS, NULL},
	 { (char *)"MixedComplementarityProblem2_nabla_Fmcp_get", _wrap_MixedComplementarityProblem2_nabla_Fmcp_get, METH_VARARGS, NULL},
	 { (char *)"MixedComplementarityProblem2_env_set", _wrap_MixedComplementarityProblem2_env_set, METH_VARARGS, NULL},
	 { (char *)"MixedComplementarityProblem2_env_get", _wrap_MixedComplementarityProblem2_env_get, METH_VARARGS, NULL},
	 { (char *)"MixedComplementarityProblem2_call_compute_F", _wrap_MixedComplementarityProblem2_call_compute_F, METH_VARARGS, NULL},
	 { (char *)"MixedComplementarityProblem2_call_compute_nabla_F", _wrap_MixedComplementarityProblem2_call_compute_nabla_F, METH_VARARGS, NULL},
	 { (char *)"new_MixedComplementarityProblem2", _wrap_new_MixedComplementarityProblem2, METH_VARARGS, NULL},
	 { (char *)"MixedComplementarityProblem2_set_compute_F_and_nabla_F_as_C_functions", _wrap_MixedComplementarityProblem2_set_compute_F_and_nabla_F_as_C_functions, METH_VARARGS, NULL},
	 { (char *)"MixedComplementarityProblem2_get_env_as_long", _wrap_MixedComplementarityProblem2_get_env_as_long, METH_VARARGS, NULL},
	 { (char *)"delete_MixedComplementarityProblem2", _wrap_delete_MixedComplementarityProblem2, METH_VARARGS, NULL},
	 { (char *)"MixedComplementarityProblem2_swigregister", MixedComplementarityProblem2_swigregister, METH_VARARGS, NULL},
	 { (char *)"freeMixedComplementarityProblem", _wrap_freeMixedComplementarityProblem, METH_VARARGS, NULL},
	 { (char *)"freeMCP", _wrap_freeMCP, METH_VARARGS, NULL},
	 { (char *)"newMCP", _wrap_newMCP, METH_VARARGS, NULL},
	 { (char *)"mcp_driver_init", _wrap_mcp_driver_init, METH_VARARGS, NULL},
	 { (char *)"mcp_driver_reset", _wrap_mcp_driver_reset, METH_VARARGS, NULL},
	 { (char *)"mixedComplementarity_setDefaultSolverOptions", _wrap_mixedComplementarity_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"mixedComplementarity_default_setDefaultSolverOptions", _wrap_mixedComplementarity_default_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"mcp_FischerBurmeister", _wrap_mcp_FischerBurmeister, METH_VARARGS, NULL},
	 { (char *)"mcp_newton_FBLSA", _wrap_mcp_newton_FBLSA, METH_VARARGS, NULL},
	 { (char *)"mcp_newton_minFBLSA", _wrap_mcp_newton_minFBLSA, METH_VARARGS, NULL},
	 { (char *)"mixedComplementarity_FB_setDefaultSolverOptions", _wrap_mixedComplementarity_FB_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"NCP_n_set", _wrap_NCP_n_set, METH_VARARGS, NULL},
	 { (char *)"NCP_n_get", _wrap_NCP_n_get, METH_VARARGS, NULL},
	 { (char *)"NCP_compute_F_set", _wrap_NCP_compute_F_set, METH_VARARGS, NULL},
	 { (char *)"NCP_compute_F_get", _wrap_NCP_compute_F_get, METH_VARARGS, NULL},
	 { (char *)"NCP_compute_nabla_F_set", _wrap_NCP_compute_nabla_F_set, METH_VARARGS, NULL},
	 { (char *)"NCP_compute_nabla_F_get", _wrap_NCP_compute_nabla_F_get, METH_VARARGS, NULL},
	 { (char *)"NCP_nabla_F_set", _wrap_NCP_nabla_F_set, METH_VARARGS, NULL},
	 { (char *)"NCP_nabla_F_get", _wrap_NCP_nabla_F_get, METH_VARARGS, NULL},
	 { (char *)"NCP_env_set", _wrap_NCP_env_set, METH_VARARGS, NULL},
	 { (char *)"NCP_env_get", _wrap_NCP_env_get, METH_VARARGS, NULL},
	 { (char *)"NCP_call_compute_F", _wrap_NCP_call_compute_F, METH_VARARGS, NULL},
	 { (char *)"NCP_call_compute_nabla_F", _wrap_NCP_call_compute_nabla_F, METH_VARARGS, NULL},
	 { (char *)"new_NCP", _wrap_new_NCP, METH_VARARGS, NULL},
	 { (char *)"NCP_set_compute_F_and_nabla_F_as_C_functions", _wrap_NCP_set_compute_F_and_nabla_F_as_C_functions, METH_VARARGS, NULL},
	 { (char *)"NCP_get_env_as_long", _wrap_NCP_get_env_as_long, METH_VARARGS, NULL},
	 { (char *)"delete_NCP", _wrap_delete_NCP, METH_VARARGS, NULL},
	 { (char *)"NCP_swigregister", NCP_swigregister, METH_VARARGS, NULL},
	 { (char *)"freeNCP", _wrap_freeNCP, METH_VARARGS, NULL},
	 { (char *)"newNCP", _wrap_newNCP, METH_VARARGS, NULL},
	 { (char *)"ncp_compute_error", _wrap_ncp_compute_error, METH_VARARGS, NULL},
	 { (char *)"ncp_newton_FBLSA", _wrap_ncp_newton_FBLSA, METH_VARARGS, NULL},
	 { (char *)"ncp_newton_minFBLSA", _wrap_ncp_newton_minFBLSA, METH_VARARGS, NULL},
	 { (char *)"ncp_pathsearch", _wrap_ncp_pathsearch, METH_VARARGS, NULL},
	 { (char *)"ncp_path", _wrap_ncp_path, METH_VARARGS, NULL},
	 { (char *)"VI_size_set", _wrap_VI_size_set, METH_VARARGS, NULL},
	 { (char *)"VI_size_get", _wrap_VI_size_get, METH_VARARGS, NULL},
	 { (char *)"VI_env_set", _wrap_VI_env_set, METH_VARARGS, NULL},
	 { (char *)"VI_env_get", _wrap_VI_env_get, METH_VARARGS, NULL},
	 { (char *)"VI_F_set", _wrap_VI_F_set, METH_VARARGS, NULL},
	 { (char *)"VI_F_get", _wrap_VI_F_get, METH_VARARGS, NULL},
	 { (char *)"VI_compute_nabla_F_set", _wrap_VI_compute_nabla_F_set, METH_VARARGS, NULL},
	 { (char *)"VI_compute_nabla_F_get", _wrap_VI_compute_nabla_F_get, METH_VARARGS, NULL},
	 { (char *)"VI_ProjectionOnX_set", _wrap_VI_ProjectionOnX_set, METH_VARARGS, NULL},
	 { (char *)"VI_ProjectionOnX_get", _wrap_VI_ProjectionOnX_get, METH_VARARGS, NULL},
	 { (char *)"VI_normVI_set", _wrap_VI_normVI_set, METH_VARARGS, NULL},
	 { (char *)"VI_normVI_get", _wrap_VI_normVI_get, METH_VARARGS, NULL},
	 { (char *)"VI_istheNormVIset_set", _wrap_VI_istheNormVIset_set, METH_VARARGS, NULL},
	 { (char *)"VI_istheNormVIset_get", _wrap_VI_istheNormVIset_get, METH_VARARGS, NULL},
	 { (char *)"VI_set_set", _wrap_VI_set_set, METH_VARARGS, NULL},
	 { (char *)"VI_set_get", _wrap_VI_set_get, METH_VARARGS, NULL},
	 { (char *)"VI_nabla_F_set", _wrap_VI_nabla_F_set, METH_VARARGS, NULL},
	 { (char *)"VI_nabla_F_get", _wrap_VI_nabla_F_get, METH_VARARGS, NULL},
	 { (char *)"VI_call_compute_F", _wrap_VI_call_compute_F, METH_VARARGS, NULL},
	 { (char *)"VI_call_compute_nabla_F", _wrap_VI_call_compute_nabla_F, METH_VARARGS, NULL},
	 { (char *)"new_VI", _wrap_new_VI, METH_VARARGS, NULL},
	 { (char *)"VI_set_compute_nabla_F", _wrap_VI_set_compute_nabla_F, METH_VARARGS, NULL},
	 { (char *)"VI_set_box_constraints", _wrap_VI_set_box_constraints, METH_VARARGS, NULL},
	 { (char *)"VI_set_compute_F_and_nabla_F_as_C_functions", _wrap_VI_set_compute_F_and_nabla_F_as_C_functions, METH_VARARGS, NULL},
	 { (char *)"VI_get_env_as_long", _wrap_VI_get_env_as_long, METH_VARARGS, NULL},
	 { (char *)"delete_VI", _wrap_delete_VI, METH_VARARGS, NULL},
	 { (char *)"VI_swigregister", VI_swigregister, METH_VARARGS, NULL},
	 { (char *)"variationalInequality_display", _wrap_variationalInequality_display, METH_VARARGS, NULL},
	 { (char *)"variationalInequality_printInFile", _wrap_variationalInequality_printInFile, METH_VARARGS, NULL},
	 { (char *)"variationalInequality_newFromFile", _wrap_variationalInequality_newFromFile, METH_VARARGS, NULL},
	 { (char *)"freeVariationalInequalityProblem", _wrap_freeVariationalInequalityProblem, METH_VARARGS, NULL},
	 { (char *)"variationalInequality_clear", _wrap_variationalInequality_clear, METH_VARARGS, NULL},
	 { (char *)"variationalInequality_new", _wrap_variationalInequality_new, METH_VARARGS, NULL},
	 { (char *)"newVI", _wrap_newVI, METH_VARARGS, NULL},
	 { (char *)"VI_get_env", _wrap_VI_get_env, METH_VARARGS, NULL},
	 { (char *)"variationalInequality_setDefaultSolverOptions", _wrap_variationalInequality_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"variationalInequality_ExtraGradient", _wrap_variationalInequality_ExtraGradient, METH_VARARGS, NULL},
	 { (char *)"variationalInequality_ExtraGradient_setDefaultSolverOptions", _wrap_variationalInequality_ExtraGradient_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"variationalInequality_FixedPointProjection", _wrap_variationalInequality_FixedPointProjection, METH_VARARGS, NULL},
	 { (char *)"variationalInequality_FixedPointProjection_setDefaultSolverOptions", _wrap_variationalInequality_FixedPointProjection_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"variationalInequality_HyperplaneProjection", _wrap_variationalInequality_HyperplaneProjection, METH_VARARGS, NULL},
	 { (char *)"variationalInequality_HyperplaneProjection_setDefaultSolverOptions", _wrap_variationalInequality_HyperplaneProjection_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"variationalInequality_box_newton_QiLSA", _wrap_variationalInequality_box_newton_QiLSA, METH_VARARGS, NULL},
	 { (char *)"vi_box_AVI_LSA", _wrap_vi_box_AVI_LSA, METH_VARARGS, NULL},
	 { (char *)"vi_box_AVI_extra_SolverOptions", _wrap_vi_box_AVI_extra_SolverOptions, METH_VARARGS, NULL},
	 { (char *)"vi_box_AVI_free_solverData", _wrap_vi_box_AVI_free_solverData, METH_VARARGS, NULL},
	 { (char *)"vi_get_set", _wrap_vi_get_set, METH_VARARGS, NULL},
	 { (char *)"vi_box_path", _wrap_vi_box_path, METH_VARARGS, NULL},
	 { (char *)"variationalInequality_common_setDefaultSolverOptions", _wrap_variationalInequality_common_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"checkTrivialCase_vi", _wrap_checkTrivialCase_vi, METH_VARARGS, NULL},
	 { (char *)"ConvexQP_size_set", _wrap_ConvexQP_size_set, METH_VARARGS, NULL},
	 { (char *)"ConvexQP_size_get", _wrap_ConvexQP_size_get, METH_VARARGS, NULL},
	 { (char *)"ConvexQP_m_set", _wrap_ConvexQP_m_set, METH_VARARGS, NULL},
	 { (char *)"ConvexQP_m_get", _wrap_ConvexQP_m_get, METH_VARARGS, NULL},
	 { (char *)"ConvexQP_env_set", _wrap_ConvexQP_env_set, METH_VARARGS, NULL},
	 { (char *)"ConvexQP_env_get", _wrap_ConvexQP_env_get, METH_VARARGS, NULL},
	 { (char *)"ConvexQP_M_set", _wrap_ConvexQP_M_set, METH_VARARGS, NULL},
	 { (char *)"ConvexQP_M_get", _wrap_ConvexQP_M_get, METH_VARARGS, NULL},
	 { (char *)"ConvexQP_q_set", _wrap_ConvexQP_q_set, METH_VARARGS, NULL},
	 { (char *)"ConvexQP_q_get", _wrap_ConvexQP_q_get, METH_VARARGS, NULL},
	 { (char *)"ConvexQP_A_set", _wrap_ConvexQP_A_set, METH_VARARGS, NULL},
	 { (char *)"ConvexQP_A_get", _wrap_ConvexQP_A_get, METH_VARARGS, NULL},
	 { (char *)"ConvexQP_b_set", _wrap_ConvexQP_b_set, METH_VARARGS, NULL},
	 { (char *)"ConvexQP_b_get", _wrap_ConvexQP_b_get, METH_VARARGS, NULL},
	 { (char *)"ConvexQP_ProjectionOnC_set", _wrap_ConvexQP_ProjectionOnC_set, METH_VARARGS, NULL},
	 { (char *)"ConvexQP_ProjectionOnC_get", _wrap_ConvexQP_ProjectionOnC_get, METH_VARARGS, NULL},
	 { (char *)"ConvexQP_normConvexQP_set", _wrap_ConvexQP_normConvexQP_set, METH_VARARGS, NULL},
	 { (char *)"ConvexQP_normConvexQP_get", _wrap_ConvexQP_normConvexQP_get, METH_VARARGS, NULL},
	 { (char *)"ConvexQP_istheNormConvexQPset_set", _wrap_ConvexQP_istheNormConvexQPset_set, METH_VARARGS, NULL},
	 { (char *)"ConvexQP_istheNormConvexQPset_get", _wrap_ConvexQP_istheNormConvexQPset_get, METH_VARARGS, NULL},
	 { (char *)"ConvexQP_set_set", _wrap_ConvexQP_set_set, METH_VARARGS, NULL},
	 { (char *)"ConvexQP_set_get", _wrap_ConvexQP_set_get, METH_VARARGS, NULL},
	 { (char *)"new_ConvexQP", _wrap_new_ConvexQP, METH_VARARGS, NULL},
	 { (char *)"delete_ConvexQP", _wrap_delete_ConvexQP, METH_VARARGS, NULL},
	 { (char *)"ConvexQP_swigregister", ConvexQP_swigregister, METH_VARARGS, NULL},
	 { (char *)"convexQP_display", _wrap_convexQP_display, METH_VARARGS, NULL},
	 { (char *)"convexQP_printInFile", _wrap_convexQP_printInFile, METH_VARARGS, NULL},
	 { (char *)"convexQP_newFromFile", _wrap_convexQP_newFromFile, METH_VARARGS, NULL},
	 { (char *)"convexQP_free", _wrap_convexQP_free, METH_VARARGS, NULL},
	 { (char *)"convexQP_clear", _wrap_convexQP_clear, METH_VARARGS, NULL},
	 { (char *)"convexQP_new", _wrap_convexQP_new, METH_VARARGS, NULL},
	 { (char *)"convexQP_get_env", _wrap_convexQP_get_env, METH_VARARGS, NULL},
	 { (char *)"convexQP_ProjectedGradient", _wrap_convexQP_ProjectedGradient, METH_VARARGS, NULL},
	 { (char *)"convexQP_ProjectedGradient_setDefaultSolverOptions", _wrap_convexQP_ProjectedGradient_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"convexQP_VI_solver", _wrap_convexQP_VI_solver, METH_VARARGS, NULL},
	 { (char *)"convexQP_VI_solver_setDefaultSolverOptions", _wrap_convexQP_VI_solver_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"convexQP_ADMM", _wrap_convexQP_ADMM, METH_VARARGS, NULL},
	 { (char *)"convexQP_ADMM_setDefaultSolverOptions", _wrap_convexQP_ADMM_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"convexQP_ADMM_init", _wrap_convexQP_ADMM_init, METH_VARARGS, NULL},
	 { (char *)"convexQP_ADMM_free", _wrap_convexQP_ADMM_free, METH_VARARGS, NULL},
	 { (char *)"SecondOrderConeLinearComplementarityProblem_n_set", _wrap_SecondOrderConeLinearComplementarityProblem_n_set, METH_VARARGS, NULL},
	 { (char *)"SecondOrderConeLinearComplementarityProblem_n_get", _wrap_SecondOrderConeLinearComplementarityProblem_n_get, METH_VARARGS, NULL},
	 { (char *)"SecondOrderConeLinearComplementarityProblem_nc_set", _wrap_SecondOrderConeLinearComplementarityProblem_nc_set, METH_VARARGS, NULL},
	 { (char *)"SecondOrderConeLinearComplementarityProblem_nc_get", _wrap_SecondOrderConeLinearComplementarityProblem_nc_get, METH_VARARGS, NULL},
	 { (char *)"SecondOrderConeLinearComplementarityProblem_M_set", _wrap_SecondOrderConeLinearComplementarityProblem_M_set, METH_VARARGS, NULL},
	 { (char *)"SecondOrderConeLinearComplementarityProblem_M_get", _wrap_SecondOrderConeLinearComplementarityProblem_M_get, METH_VARARGS, NULL},
	 { (char *)"SecondOrderConeLinearComplementarityProblem_q_set", _wrap_SecondOrderConeLinearComplementarityProblem_q_set, METH_VARARGS, NULL},
	 { (char *)"SecondOrderConeLinearComplementarityProblem_q_get", _wrap_SecondOrderConeLinearComplementarityProblem_q_get, METH_VARARGS, NULL},
	 { (char *)"SecondOrderConeLinearComplementarityProblem_coneIndex_set", _wrap_SecondOrderConeLinearComplementarityProblem_coneIndex_set, METH_VARARGS, NULL},
	 { (char *)"SecondOrderConeLinearComplementarityProblem_coneIndex_get", _wrap_SecondOrderConeLinearComplementarityProblem_coneIndex_get, METH_VARARGS, NULL},
	 { (char *)"SecondOrderConeLinearComplementarityProblem_tau_set", _wrap_SecondOrderConeLinearComplementarityProblem_tau_set, METH_VARARGS, NULL},
	 { (char *)"SecondOrderConeLinearComplementarityProblem_tau_get", _wrap_SecondOrderConeLinearComplementarityProblem_tau_get, METH_VARARGS, NULL},
	 { (char *)"new_SecondOrderConeLinearComplementarityProblem", _wrap_new_SecondOrderConeLinearComplementarityProblem, METH_VARARGS, NULL},
	 { (char *)"delete_SecondOrderConeLinearComplementarityProblem", _wrap_delete_SecondOrderConeLinearComplementarityProblem, METH_VARARGS, NULL},
	 { (char *)"SecondOrderConeLinearComplementarityProblem_swigregister", SecondOrderConeLinearComplementarityProblem_swigregister, METH_VARARGS, NULL},
	 { (char *)"secondOrderConeLinearComplementarityProblem_display", _wrap_secondOrderConeLinearComplementarityProblem_display, METH_VARARGS, NULL},
	 { (char *)"secondOrderConeLinearComplementarityProblem_printInFile", _wrap_secondOrderConeLinearComplementarityProblem_printInFile, METH_VARARGS, NULL},
	 { (char *)"secondOrderConeLinearComplementarityProblem_printInFilename", _wrap_secondOrderConeLinearComplementarityProblem_printInFilename, METH_VARARGS, NULL},
	 { (char *)"secondOrderConeLinearComplementarityProblem_newFromFile", _wrap_secondOrderConeLinearComplementarityProblem_newFromFile, METH_VARARGS, NULL},
	 { (char *)"secondOrderConeLinearComplementarityProblem_newFromFilename", _wrap_secondOrderConeLinearComplementarityProblem_newFromFilename, METH_VARARGS, NULL},
	 { (char *)"freeSecondOrderConeLinearComplementarityProblem", _wrap_freeSecondOrderConeLinearComplementarityProblem, METH_VARARGS, NULL},
	 { (char *)"secondOrderConeLinearComplementarityProblem_new", _wrap_secondOrderConeLinearComplementarityProblem_new, METH_VARARGS, NULL},
	 { (char *)"soclcp_setDefaultSolverOptions", _wrap_soclcp_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"soclcp_nsgs", _wrap_soclcp_nsgs, METH_VARARGS, NULL},
	 { (char *)"soclcp_nsgs_fillMLocal", _wrap_soclcp_nsgs_fillMLocal, METH_VARARGS, NULL},
	 { (char *)"soclcp_nsgs_computeqLocal", _wrap_soclcp_nsgs_computeqLocal, METH_VARARGS, NULL},
	 { (char *)"soclcp_nsgs_setDefaultSolverOptions", _wrap_soclcp_nsgs_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"soclcp_VI_FixedPointProjection", _wrap_soclcp_VI_FixedPointProjection, METH_VARARGS, NULL},
	 { (char *)"soclcp_VI_FixedPointProjection_setDefaultSolverOptions", _wrap_soclcp_VI_FixedPointProjection_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"soclcp_VI_ExtraGradient", _wrap_soclcp_VI_ExtraGradient, METH_VARARGS, NULL},
	 { (char *)"soclcp_VI_ExtraGradient_setDefaultSolverOptions", _wrap_soclcp_VI_ExtraGradient_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"soclcp_checkTrivialCase", _wrap_soclcp_checkTrivialCase, METH_VARARGS, NULL},
	 { (char *)"FrictionContactProblem_dimension_set", _wrap_FrictionContactProblem_dimension_set, METH_VARARGS, NULL},
	 { (char *)"FrictionContactProblem_dimension_get", _wrap_FrictionContactProblem_dimension_get, METH_VARARGS, NULL},
	 { (char *)"FrictionContactProblem_numberOfContacts_set", _wrap_FrictionContactProblem_numberOfContacts_set, METH_VARARGS, NULL},
	 { (char *)"FrictionContactProblem_numberOfContacts_get", _wrap_FrictionContactProblem_numberOfContacts_get, METH_VARARGS, NULL},
	 { (char *)"FrictionContactProblem_M_set", _wrap_FrictionContactProblem_M_set, METH_VARARGS, NULL},
	 { (char *)"FrictionContactProblem_M_get", _wrap_FrictionContactProblem_M_get, METH_VARARGS, NULL},
	 { (char *)"FrictionContactProblem_q_set", _wrap_FrictionContactProblem_q_set, METH_VARARGS, NULL},
	 { (char *)"FrictionContactProblem_q_get", _wrap_FrictionContactProblem_q_get, METH_VARARGS, NULL},
	 { (char *)"FrictionContactProblem_mu_set", _wrap_FrictionContactProblem_mu_set, METH_VARARGS, NULL},
	 { (char *)"FrictionContactProblem_mu_get", _wrap_FrictionContactProblem_mu_get, METH_VARARGS, NULL},
	 { (char *)"new_FrictionContactProblem", _wrap_new_FrictionContactProblem, METH_VARARGS, NULL},
	 { (char *)"delete_FrictionContactProblem", _wrap_delete_FrictionContactProblem, METH_VARARGS, NULL},
	 { (char *)"FrictionContactProblem_swigregister", FrictionContactProblem_swigregister, METH_VARARGS, NULL},
	 { (char *)"SplittedFrictionContactProblem_fc3d_set", _wrap_SplittedFrictionContactProblem_fc3d_set, METH_VARARGS, NULL},
	 { (char *)"SplittedFrictionContactProblem_fc3d_get", _wrap_SplittedFrictionContactProblem_fc3d_get, METH_VARARGS, NULL},
	 { (char *)"SplittedFrictionContactProblem_M_nn_set", _wrap_SplittedFrictionContactProblem_M_nn_set, METH_VARARGS, NULL},
	 { (char *)"SplittedFrictionContactProblem_M_nn_get", _wrap_SplittedFrictionContactProblem_M_nn_get, METH_VARARGS, NULL},
	 { (char *)"SplittedFrictionContactProblem_M_tn_set", _wrap_SplittedFrictionContactProblem_M_tn_set, METH_VARARGS, NULL},
	 { (char *)"SplittedFrictionContactProblem_M_tn_get", _wrap_SplittedFrictionContactProblem_M_tn_get, METH_VARARGS, NULL},
	 { (char *)"SplittedFrictionContactProblem_M_nt_set", _wrap_SplittedFrictionContactProblem_M_nt_set, METH_VARARGS, NULL},
	 { (char *)"SplittedFrictionContactProblem_M_nt_get", _wrap_SplittedFrictionContactProblem_M_nt_get, METH_VARARGS, NULL},
	 { (char *)"SplittedFrictionContactProblem_M_tt_set", _wrap_SplittedFrictionContactProblem_M_tt_set, METH_VARARGS, NULL},
	 { (char *)"SplittedFrictionContactProblem_M_tt_get", _wrap_SplittedFrictionContactProblem_M_tt_get, METH_VARARGS, NULL},
	 { (char *)"SplittedFrictionContactProblem_q_n_set", _wrap_SplittedFrictionContactProblem_q_n_set, METH_VARARGS, NULL},
	 { (char *)"SplittedFrictionContactProblem_q_n_get", _wrap_SplittedFrictionContactProblem_q_n_get, METH_VARARGS, NULL},
	 { (char *)"SplittedFrictionContactProblem_q_t_set", _wrap_SplittedFrictionContactProblem_q_t_set, METH_VARARGS, NULL},
	 { (char *)"SplittedFrictionContactProblem_q_t_get", _wrap_SplittedFrictionContactProblem_q_t_get, METH_VARARGS, NULL},
	 { (char *)"new_SplittedFrictionContactProblem", _wrap_new_SplittedFrictionContactProblem, METH_VARARGS, NULL},
	 { (char *)"delete_SplittedFrictionContactProblem", _wrap_delete_SplittedFrictionContactProblem, METH_VARARGS, NULL},
	 { (char *)"SplittedFrictionContactProblem_swigregister", SplittedFrictionContactProblem_swigregister, METH_VARARGS, NULL},
	 { (char *)"frictionContactProblem_new_with_data", _wrap_frictionContactProblem_new_with_data, METH_VARARGS, NULL},
	 { (char *)"frictionContactProblem_free", _wrap_frictionContactProblem_free, METH_VARARGS, NULL},
	 { (char *)"frictionContact_display", _wrap_frictionContact_display, METH_VARARGS, NULL},
	 { (char *)"frictionContact_printInFile", _wrap_frictionContact_printInFile, METH_VARARGS, NULL},
	 { (char *)"frictionContact_printInFilename", _wrap_frictionContact_printInFilename, METH_VARARGS, NULL},
	 { (char *)"frictionContact_newFromFile", _wrap_frictionContact_newFromFile, METH_VARARGS, NULL},
	 { (char *)"frictionContact_newFromFilename", _wrap_frictionContact_newFromFilename, METH_VARARGS, NULL},
	 { (char *)"createSplittedFrictionContactProblem", _wrap_createSplittedFrictionContactProblem, METH_VARARGS, NULL},
	 { (char *)"frictionContactProblem_compute_statistics", _wrap_frictionContactProblem_compute_statistics, METH_VARARGS, NULL},
	 { (char *)"compute_rho_split_spectral_norm_cond", _wrap_compute_rho_split_spectral_norm_cond, METH_VARARGS, NULL},
	 { (char *)"compute_rho_split_spectral_norm", _wrap_compute_rho_split_spectral_norm, METH_VARARGS, NULL},
	 { (char *)"compute_rho_spectral_norm", _wrap_compute_rho_spectral_norm, METH_VARARGS, NULL},
	 { (char *)"computeAlartCurnierSTD", _wrap_computeAlartCurnierSTD, METH_VARARGS, NULL},
	 { (char *)"computeAlartCurnierJeanMoreau", _wrap_computeAlartCurnierJeanMoreau, METH_VARARGS, NULL},
	 { (char *)"AlartCurnierParams_computeACFun3x3_set", _wrap_AlartCurnierParams_computeACFun3x3_set, METH_VARARGS, NULL},
	 { (char *)"AlartCurnierParams_computeACFun3x3_get", _wrap_AlartCurnierParams_computeACFun3x3_get, METH_VARARGS, NULL},
	 { (char *)"new_AlartCurnierParams", _wrap_new_AlartCurnierParams, METH_VARARGS, NULL},
	 { (char *)"delete_AlartCurnierParams", _wrap_delete_AlartCurnierParams, METH_VARARGS, NULL},
	 { (char *)"AlartCurnierParams_swigregister", AlartCurnierParams_swigregister, METH_VARARGS, NULL},
	 { (char *)"nonsmoothEqnAlartCurnierFun", _wrap_nonsmoothEqnAlartCurnierFun, METH_VARARGS, NULL},
	 { (char *)"fc3d_nonsmooth_Newton_AlartCurnier", _wrap_fc3d_nonsmooth_Newton_AlartCurnier, METH_VARARGS, NULL},
	 { (char *)"fc3d_nonsmooth_Newton_AlartCurnier_setDefaultSolverOptions", _wrap_fc3d_nonsmooth_Newton_AlartCurnier_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"fc3d_AlartCurnierFunction", _wrap_fc3d_AlartCurnierFunction, METH_VARARGS, NULL},
	 { (char *)"fc3d_nonsmooth_Newton_FischerBurmeister", _wrap_fc3d_nonsmooth_Newton_FischerBurmeister, METH_VARARGS, NULL},
	 { (char *)"fc3d_FischerBurmeisterFunction", _wrap_fc3d_FischerBurmeisterFunction, METH_VARARGS, NULL},
	 { (char *)"fc3d_nonsmooth_Newton_FischerBurmeister_setDefaultSolverOptions", _wrap_fc3d_nonsmooth_Newton_FischerBurmeister_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"fc3d_nonsmooth_Newton_FischerBurmeister_compute_error", _wrap_fc3d_nonsmooth_Newton_FischerBurmeister_compute_error, METH_VARARGS, NULL},
	 { (char *)"fc3d_nonsmooth_Newton_NaturalMap", _wrap_fc3d_nonsmooth_Newton_NaturalMap, METH_VARARGS, NULL},
	 { (char *)"fc3d_NaturalMapFunction", _wrap_fc3d_NaturalMapFunction, METH_VARARGS, NULL},
	 { (char *)"fc3d_nonsmooth_Newton_NaturalMap_setDefaultSolverOptions", _wrap_fc3d_nonsmooth_Newton_NaturalMap_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"fc3d_nonsmooth_Newton_NaturalMap_compute_error", _wrap_fc3d_nonsmooth_Newton_NaturalMap_compute_error, METH_VARARGS, NULL},
	 { (char *)"fc3d_AlartCurnierFunctionGenerated", _wrap_fc3d_AlartCurnierFunctionGenerated, METH_VARARGS, NULL},
	 { (char *)"fc3d_AlartCurnierJeanMoreauFunctionGenerated", _wrap_fc3d_AlartCurnierJeanMoreauFunctionGenerated, METH_VARARGS, NULL},
	 { (char *)"fc3d_FischerBurmeisterFABGenerated", _wrap_fc3d_FischerBurmeisterFABGenerated, METH_VARARGS, NULL},
	 { (char *)"fc3d_FischerBurmeisterFGenerated", _wrap_fc3d_FischerBurmeisterFGenerated, METH_VARARGS, NULL},
	 { (char *)"fc3d_FischerBurmeisterABGenerated", _wrap_fc3d_FischerBurmeisterABGenerated, METH_VARARGS, NULL},
	 { (char *)"fc3d_FischerBurmeisterFunctionGenerated", _wrap_fc3d_FischerBurmeisterFunctionGenerated, METH_VARARGS, NULL},
	 { (char *)"fc3d_FischerBurmeisterFMeritGenerated", _wrap_fc3d_FischerBurmeisterFMeritGenerated, METH_VARARGS, NULL},
	 { (char *)"fc3d_FischerBurmeisterGradFMeritGenerated", _wrap_fc3d_FischerBurmeisterGradFMeritGenerated, METH_VARARGS, NULL},
	 { (char *)"fc3d_FischerBurmeisterGradMeritFunctionGenerated", _wrap_fc3d_FischerBurmeisterGradMeritFunctionGenerated, METH_VARARGS, NULL},
	 { (char *)"fc3d_NaturalMapFunctionGenerated", _wrap_fc3d_NaturalMapFunctionGenerated, METH_VARARGS, NULL},
	 { (char *)"fc3d_setDefaultSolverOptions", _wrap_fc3d_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"fc3d_nsgs", _wrap_fc3d_nsgs, METH_VARARGS, NULL},
	 { (char *)"fc3d_nsgs_initialize_local_solver", _wrap_fc3d_nsgs_initialize_local_solver, METH_VARARGS, NULL},
	 { (char *)"fc3d_nsgs_setDefaultSolverOptions", _wrap_fc3d_nsgs_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"fc3d_admm", _wrap_fc3d_admm, METH_VARARGS, NULL},
	 { (char *)"fc3d_admm_init", _wrap_fc3d_admm_init, METH_VARARGS, NULL},
	 { (char *)"fc3d_admm_free", _wrap_fc3d_admm_free, METH_VARARGS, NULL},
	 { (char *)"fc3d_admm_setDefaultSolverOptions", _wrap_fc3d_admm_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"fc3d_nsgs_velocity", _wrap_fc3d_nsgs_velocity, METH_VARARGS, NULL},
	 { (char *)"fc3d_nsgs_velocity_setDefaultSolverOptions", _wrap_fc3d_nsgs_velocity_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"fc3d_proximal", _wrap_fc3d_proximal, METH_VARARGS, NULL},
	 { (char *)"fc3d_proximal_setDefaultSolverOptions", _wrap_fc3d_proximal_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"fc3d_set_internalsolver_tolerance", _wrap_fc3d_set_internalsolver_tolerance, METH_VARARGS, NULL},
	 { (char *)"fc3d_TrescaFixedPoint", _wrap_fc3d_TrescaFixedPoint, METH_VARARGS, NULL},
	 { (char *)"fc3d_TrescaFixedPoint_setDefaultSolverOptions", _wrap_fc3d_TrescaFixedPoint_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"fc3d_Panagiotopoulos_FixedPoint", _wrap_fc3d_Panagiotopoulos_FixedPoint, METH_VARARGS, NULL},
	 { (char *)"fc3d_Panagiotopoulos_FixedPoint_setDefaultSolverOptions", _wrap_fc3d_Panagiotopoulos_FixedPoint_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"fc3d_SOCLCP_setDefaultSolverOptions", _wrap_fc3d_SOCLCP_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"fc3d_SOCLCP", _wrap_fc3d_SOCLCP, METH_VARARGS, NULL},
	 { (char *)"fc3d_ACLMFixedPoint", _wrap_fc3d_ACLMFixedPoint, METH_VARARGS, NULL},
	 { (char *)"fc3d_ACLMFixedPoint_setDefaultSolverOptions", _wrap_fc3d_ACLMFixedPoint_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"fc3d_ConvexQP_ProjectedGradient_Cylinder", _wrap_fc3d_ConvexQP_ProjectedGradient_Cylinder, METH_VARARGS, NULL},
	 { (char *)"fc3d_ConvexQP_ProjectedGradient_Cylinder_setDefaultSolverOptions", _wrap_fc3d_ConvexQP_ProjectedGradient_Cylinder_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"fc3d_DeSaxceFixedPoint", _wrap_fc3d_DeSaxceFixedPoint, METH_VARARGS, NULL},
	 { (char *)"fc3d_DeSaxceFixedPoint_setDefaultSolverOptions", _wrap_fc3d_DeSaxceFixedPoint_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"fc3d_fixedPointProjection", _wrap_fc3d_fixedPointProjection, METH_VARARGS, NULL},
	 { (char *)"fc3d_fixedPointProjection_setDefaultSolverOptions", _wrap_fc3d_fixedPointProjection_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"fc3d_VI_FixedPointProjection", _wrap_fc3d_VI_FixedPointProjection, METH_VARARGS, NULL},
	 { (char *)"fc3d_VI_FixedPointProjection_Cylinder", _wrap_fc3d_VI_FixedPointProjection_Cylinder, METH_VARARGS, NULL},
	 { (char *)"fc3d_VI_FixedPointProjection_setDefaultSolverOptions", _wrap_fc3d_VI_FixedPointProjection_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"fc3d_VI_FixedPointProjection_Cylinder_setDefaultSolverOptions", _wrap_fc3d_VI_FixedPointProjection_Cylinder_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"fc3d_ExtraGradient", _wrap_fc3d_ExtraGradient, METH_VARARGS, NULL},
	 { (char *)"fc3d_ExtraGradient_setDefaultSolverOptions", _wrap_fc3d_ExtraGradient_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"fc3d_VI_ExtraGradient", _wrap_fc3d_VI_ExtraGradient, METH_VARARGS, NULL},
	 { (char *)"fc3d_VI_ExtraGradient_setDefaultSolverOptions", _wrap_fc3d_VI_ExtraGradient_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"fc3d_HyperplaneProjection", _wrap_fc3d_HyperplaneProjection, METH_VARARGS, NULL},
	 { (char *)"fc3d_AVI_gams_path", _wrap_fc3d_AVI_gams_path, METH_VARARGS, NULL},
	 { (char *)"fc3d_AVI_gams_pathvi", _wrap_fc3d_AVI_gams_pathvi, METH_VARARGS, NULL},
	 { (char *)"fc3d_lcp_gams_path", _wrap_fc3d_lcp_gams_path, METH_VARARGS, NULL},
	 { (char *)"fc3d_lcp_gams_pathvi", _wrap_fc3d_lcp_gams_pathvi, METH_VARARGS, NULL},
	 { (char *)"fc3d_HyperplaneProjection_setDefaultSolverOptions", _wrap_fc3d_HyperplaneProjection_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"fc3d_checkTrivialCase", _wrap_fc3d_checkTrivialCase, METH_VARARGS, NULL},
	 { (char *)"fc3d_nonsmooth_Newton_AlartCurnier2", _wrap_fc3d_nonsmooth_Newton_AlartCurnier2, METH_VARARGS, NULL},
	 { (char *)"fc3d_unitary_enumerative_free", _wrap_fc3d_unitary_enumerative_free, METH_VARARGS, NULL},
	 { (char *)"fc3d_unitary_enumerative_initialize", _wrap_fc3d_unitary_enumerative_initialize, METH_VARARGS, NULL},
	 { (char *)"fc3d_unitary_enumerative_solve", _wrap_fc3d_unitary_enumerative_solve, METH_VARARGS, NULL},
	 { (char *)"fc3d_unitary_enumerative_solve_sliding", _wrap_fc3d_unitary_enumerative_solve_sliding, METH_VARARGS, NULL},
	 { (char *)"fc3d_unitary_enumerative_test_non_sliding", _wrap_fc3d_unitary_enumerative_test_non_sliding, METH_VARARGS, NULL},
	 { (char *)"fc3d_unitary_enumerative", _wrap_fc3d_unitary_enumerative, METH_VARARGS, NULL},
	 { (char *)"fc3d_unitary_enumerative_setDefaultSolverOptions", _wrap_fc3d_unitary_enumerative_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"fc3d_unitary_enumerative_solve_poly_nu_sliding", _wrap_fc3d_unitary_enumerative_solve_poly_nu_sliding, METH_VARARGS, NULL},
	 { (char *)"fc2d_setDefaultSolverOptions", _wrap_fc2d_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"fc2d_cpg", _wrap_fc2d_cpg, METH_VARARGS, NULL},
	 { (char *)"fc2d_cpg_setDefaultSolverOptions", _wrap_fc2d_cpg_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"fc2d_nsgs", _wrap_fc2d_nsgs, METH_VARARGS, NULL},
	 { (char *)"fc2d_nsgs_setDefaultSolverOptions", _wrap_fc2d_nsgs_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"fc2d_latin", _wrap_fc2d_latin, METH_VARARGS, NULL},
	 { (char *)"fc2d_latin_setDefaultSolverOptions", _wrap_fc2d_latin_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"fc2d_projc", _wrap_fc2d_projc, METH_VARARGS, NULL},
	 { (char *)"fc2d_projf", _wrap_fc2d_projf, METH_VARARGS, NULL},
	 { (char *)"fc2d_sparse_nsgs", _wrap_fc2d_sparse_nsgs, METH_VARARGS, NULL},
	 { (char *)"fc2d_sparse_nsgs_setDefaultSolverOptions", _wrap_fc2d_sparse_nsgs_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"fc2d_lexicolemke", _wrap_fc2d_lexicolemke, METH_VARARGS, NULL},
	 { (char *)"fc2d_lexicolemke_setDefaultSolverOptions", _wrap_fc2d_lexicolemke_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"fc2d_tolcp", _wrap_fc2d_tolcp, METH_VARARGS, NULL},
	 { (char *)"fc2d_enum_setDefaultSolverOptions", _wrap_fc2d_enum_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"fc2d_enum", _wrap_fc2d_enum, METH_VARARGS, NULL},
	 { (char *)"fc3d_compute_error", _wrap_fc3d_compute_error, METH_VARARGS, NULL},
	 { (char *)"fc3d_unitary_compute_and_add_error", _wrap_fc3d_unitary_compute_and_add_error, METH_VARARGS, NULL},
	 { (char *)"fc3d_compute_error_velocity", _wrap_fc3d_compute_error_velocity, METH_VARARGS, NULL},
	 { (char *)"fc3d_Tresca_unitary_compute_and_add_error", _wrap_fc3d_Tresca_unitary_compute_and_add_error, METH_VARARGS, NULL},
	 { (char *)"fc3d_Tresca_compute_error", _wrap_fc3d_Tresca_compute_error, METH_VARARGS, NULL},
	 { (char *)"frictionContactProblemFromFile", _wrap_frictionContactProblemFromFile, METH_VARARGS, NULL},
	 { (char *)"GAMS_opt_bool_name_set", _wrap_GAMS_opt_bool_name_set, METH_VARARGS, NULL},
	 { (char *)"GAMS_opt_bool_name_get", _wrap_GAMS_opt_bool_name_get, METH_VARARGS, NULL},
	 { (char *)"GAMS_opt_bool_value_set", _wrap_GAMS_opt_bool_value_set, METH_VARARGS, NULL},
	 { (char *)"GAMS_opt_bool_value_get", _wrap_GAMS_opt_bool_value_get, METH_VARARGS, NULL},
	 { (char *)"GAMS_opt_bool_type_set", _wrap_GAMS_opt_bool_type_set, METH_VARARGS, NULL},
	 { (char *)"GAMS_opt_bool_type_get", _wrap_GAMS_opt_bool_type_get, METH_VARARGS, NULL},
	 { (char *)"GAMS_opt_bool_next_opt_set", _wrap_GAMS_opt_bool_next_opt_set, METH_VARARGS, NULL},
	 { (char *)"GAMS_opt_bool_next_opt_get", _wrap_GAMS_opt_bool_next_opt_get, METH_VARARGS, NULL},
	 { (char *)"new_GAMS_opt_bool", _wrap_new_GAMS_opt_bool, METH_VARARGS, NULL},
	 { (char *)"delete_GAMS_opt_bool", _wrap_delete_GAMS_opt_bool, METH_VARARGS, NULL},
	 { (char *)"GAMS_opt_bool_swigregister", GAMS_opt_bool_swigregister, METH_VARARGS, NULL},
	 { (char *)"GAMS_opt_int_name_set", _wrap_GAMS_opt_int_name_set, METH_VARARGS, NULL},
	 { (char *)"GAMS_opt_int_name_get", _wrap_GAMS_opt_int_name_get, METH_VARARGS, NULL},
	 { (char *)"GAMS_opt_int_value_set", _wrap_GAMS_opt_int_value_set, METH_VARARGS, NULL},
	 { (char *)"GAMS_opt_int_value_get", _wrap_GAMS_opt_int_value_get, METH_VARARGS, NULL},
	 { (char *)"GAMS_opt_int_type_set", _wrap_GAMS_opt_int_type_set, METH_VARARGS, NULL},
	 { (char *)"GAMS_opt_int_type_get", _wrap_GAMS_opt_int_type_get, METH_VARARGS, NULL},
	 { (char *)"GAMS_opt_int_next_opt_set", _wrap_GAMS_opt_int_next_opt_set, METH_VARARGS, NULL},
	 { (char *)"GAMS_opt_int_next_opt_get", _wrap_GAMS_opt_int_next_opt_get, METH_VARARGS, NULL},
	 { (char *)"new_GAMS_opt_int", _wrap_new_GAMS_opt_int, METH_VARARGS, NULL},
	 { (char *)"delete_GAMS_opt_int", _wrap_delete_GAMS_opt_int, METH_VARARGS, NULL},
	 { (char *)"GAMS_opt_int_swigregister", GAMS_opt_int_swigregister, METH_VARARGS, NULL},
	 { (char *)"GAMS_opt_double_name_set", _wrap_GAMS_opt_double_name_set, METH_VARARGS, NULL},
	 { (char *)"GAMS_opt_double_name_get", _wrap_GAMS_opt_double_name_get, METH_VARARGS, NULL},
	 { (char *)"GAMS_opt_double_value_set", _wrap_GAMS_opt_double_value_set, METH_VARARGS, NULL},
	 { (char *)"GAMS_opt_double_value_get", _wrap_GAMS_opt_double_value_get, METH_VARARGS, NULL},
	 { (char *)"GAMS_opt_double_type_set", _wrap_GAMS_opt_double_type_set, METH_VARARGS, NULL},
	 { (char *)"GAMS_opt_double_type_get", _wrap_GAMS_opt_double_type_get, METH_VARARGS, NULL},
	 { (char *)"GAMS_opt_double_next_opt_set", _wrap_GAMS_opt_double_next_opt_set, METH_VARARGS, NULL},
	 { (char *)"GAMS_opt_double_next_opt_get", _wrap_GAMS_opt_double_next_opt_get, METH_VARARGS, NULL},
	 { (char *)"new_GAMS_opt_double", _wrap_new_GAMS_opt_double, METH_VARARGS, NULL},
	 { (char *)"delete_GAMS_opt_double", _wrap_delete_GAMS_opt_double, METH_VARARGS, NULL},
	 { (char *)"GAMS_opt_double_swigregister", GAMS_opt_double_swigregister, METH_VARARGS, NULL},
	 { (char *)"GAMS_opt_str_name_set", _wrap_GAMS_opt_str_name_set, METH_VARARGS, NULL},
	 { (char *)"GAMS_opt_str_name_get", _wrap_GAMS_opt_str_name_get, METH_VARARGS, NULL},
	 { (char *)"GAMS_opt_str_value_set", _wrap_GAMS_opt_str_value_set, METH_VARARGS, NULL},
	 { (char *)"GAMS_opt_str_value_get", _wrap_GAMS_opt_str_value_get, METH_VARARGS, NULL},
	 { (char *)"GAMS_opt_str_type_set", _wrap_GAMS_opt_str_type_set, METH_VARARGS, NULL},
	 { (char *)"GAMS_opt_str_type_get", _wrap_GAMS_opt_str_type_get, METH_VARARGS, NULL},
	 { (char *)"GAMS_opt_str_next_opt_set", _wrap_GAMS_opt_str_next_opt_set, METH_VARARGS, NULL},
	 { (char *)"GAMS_opt_str_next_opt_get", _wrap_GAMS_opt_str_next_opt_get, METH_VARARGS, NULL},
	 { (char *)"new_GAMS_opt_str", _wrap_new_GAMS_opt_str, METH_VARARGS, NULL},
	 { (char *)"delete_GAMS_opt_str", _wrap_delete_GAMS_opt_str, METH_VARARGS, NULL},
	 { (char *)"GAMS_opt_str_swigregister", GAMS_opt_str_swigregister, METH_VARARGS, NULL},
	 { (char *)"SN_GAMSparams_model_dir_set", _wrap_SN_GAMSparams_model_dir_set, METH_VARARGS, NULL},
	 { (char *)"SN_GAMSparams_model_dir_get", _wrap_SN_GAMSparams_model_dir_get, METH_VARARGS, NULL},
	 { (char *)"SN_GAMSparams_gams_dir_set", _wrap_SN_GAMSparams_gams_dir_set, METH_VARARGS, NULL},
	 { (char *)"SN_GAMSparams_gams_dir_get", _wrap_SN_GAMSparams_gams_dir_get, METH_VARARGS, NULL},
	 { (char *)"SN_GAMSparams_filename_set", _wrap_SN_GAMSparams_filename_set, METH_VARARGS, NULL},
	 { (char *)"SN_GAMSparams_filename_get", _wrap_SN_GAMSparams_filename_get, METH_VARARGS, NULL},
	 { (char *)"SN_GAMSparams_filename_suffix_set", _wrap_SN_GAMSparams_filename_suffix_set, METH_VARARGS, NULL},
	 { (char *)"SN_GAMSparams_filename_suffix_get", _wrap_SN_GAMSparams_filename_suffix_get, METH_VARARGS, NULL},
	 { (char *)"SN_GAMSparams_opt_str_list_set", _wrap_SN_GAMSparams_opt_str_list_set, METH_VARARGS, NULL},
	 { (char *)"SN_GAMSparams_opt_str_list_get", _wrap_SN_GAMSparams_opt_str_list_get, METH_VARARGS, NULL},
	 { (char *)"SN_GAMSparams_opt_bool_list_set", _wrap_SN_GAMSparams_opt_bool_list_set, METH_VARARGS, NULL},
	 { (char *)"SN_GAMSparams_opt_bool_list_get", _wrap_SN_GAMSparams_opt_bool_list_get, METH_VARARGS, NULL},
	 { (char *)"SN_GAMSparams_opt_int_list_set", _wrap_SN_GAMSparams_opt_int_list_set, METH_VARARGS, NULL},
	 { (char *)"SN_GAMSparams_opt_int_list_get", _wrap_SN_GAMSparams_opt_int_list_get, METH_VARARGS, NULL},
	 { (char *)"SN_GAMSparams_opt_double_list_set", _wrap_SN_GAMSparams_opt_double_list_set, METH_VARARGS, NULL},
	 { (char *)"SN_GAMSparams_opt_double_list_get", _wrap_SN_GAMSparams_opt_double_list_get, METH_VARARGS, NULL},
	 { (char *)"new_SN_GAMSparams", _wrap_new_SN_GAMSparams, METH_VARARGS, NULL},
	 { (char *)"SN_GAMSparams_gamsdir_set", _wrap_SN_GAMSparams_gamsdir_set, METH_VARARGS, NULL},
	 { (char *)"SN_GAMSparams_modeldir_set", _wrap_SN_GAMSparams_modeldir_set, METH_VARARGS, NULL},
	 { (char *)"delete_SN_GAMSparams", _wrap_delete_SN_GAMSparams, METH_VARARGS, NULL},
	 { (char *)"SN_GAMSparams_swigregister", SN_GAMSparams_swigregister, METH_VARARGS, NULL},
	 { (char *)"SN_GAMS_NM_gdx_mat_set", _wrap_SN_GAMS_NM_gdx_mat_set, METH_VARARGS, NULL},
	 { (char *)"SN_GAMS_NM_gdx_mat_get", _wrap_SN_GAMS_NM_gdx_mat_get, METH_VARARGS, NULL},
	 { (char *)"SN_GAMS_NM_gdx_name_set", _wrap_SN_GAMS_NM_gdx_name_set, METH_VARARGS, NULL},
	 { (char *)"SN_GAMS_NM_gdx_name_get", _wrap_SN_GAMS_NM_gdx_name_get, METH_VARARGS, NULL},
	 { (char *)"SN_GAMS_NM_gdx_next_set", _wrap_SN_GAMS_NM_gdx_next_set, METH_VARARGS, NULL},
	 { (char *)"SN_GAMS_NM_gdx_next_get", _wrap_SN_GAMS_NM_gdx_next_get, METH_VARARGS, NULL},
	 { (char *)"new_SN_GAMS_NM_gdx", _wrap_new_SN_GAMS_NM_gdx, METH_VARARGS, NULL},
	 { (char *)"delete_SN_GAMS_NM_gdx", _wrap_delete_SN_GAMS_NM_gdx, METH_VARARGS, NULL},
	 { (char *)"SN_GAMS_NM_gdx_swigregister", SN_GAMS_NM_gdx_swigregister, METH_VARARGS, NULL},
	 { (char *)"SN_GAMS_NV_gdx_vec_set", _wrap_SN_GAMS_NV_gdx_vec_set, METH_VARARGS, NULL},
	 { (char *)"SN_GAMS_NV_gdx_vec_get", _wrap_SN_GAMS_NV_gdx_vec_get, METH_VARARGS, NULL},
	 { (char *)"SN_GAMS_NV_gdx_name_set", _wrap_SN_GAMS_NV_gdx_name_set, METH_VARARGS, NULL},
	 { (char *)"SN_GAMS_NV_gdx_name_get", _wrap_SN_GAMS_NV_gdx_name_get, METH_VARARGS, NULL},
	 { (char *)"SN_GAMS_NV_gdx_size_set", _wrap_SN_GAMS_NV_gdx_size_set, METH_VARARGS, NULL},
	 { (char *)"SN_GAMS_NV_gdx_size_get", _wrap_SN_GAMS_NV_gdx_size_get, METH_VARARGS, NULL},
	 { (char *)"SN_GAMS_NV_gdx_next_set", _wrap_SN_GAMS_NV_gdx_next_set, METH_VARARGS, NULL},
	 { (char *)"SN_GAMS_NV_gdx_next_get", _wrap_SN_GAMS_NV_gdx_next_get, METH_VARARGS, NULL},
	 { (char *)"new_SN_GAMS_NV_gdx", _wrap_new_SN_GAMS_NV_gdx, METH_VARARGS, NULL},
	 { (char *)"delete_SN_GAMS_NV_gdx", _wrap_delete_SN_GAMS_NV_gdx, METH_VARARGS, NULL},
	 { (char *)"SN_GAMS_NV_gdx_swigregister", SN_GAMS_NV_gdx_swigregister, METH_VARARGS, NULL},
	 { (char *)"SN_GAMS_gdx_mat_for_gdx_set", _wrap_SN_GAMS_gdx_mat_for_gdx_set, METH_VARARGS, NULL},
	 { (char *)"SN_GAMS_gdx_mat_for_gdx_get", _wrap_SN_GAMS_gdx_mat_for_gdx_get, METH_VARARGS, NULL},
	 { (char *)"SN_GAMS_gdx_vec_for_gdx_set", _wrap_SN_GAMS_gdx_vec_for_gdx_set, METH_VARARGS, NULL},
	 { (char *)"SN_GAMS_gdx_vec_for_gdx_get", _wrap_SN_GAMS_gdx_vec_for_gdx_get, METH_VARARGS, NULL},
	 { (char *)"SN_GAMS_gdx_vec_from_gdx_set", _wrap_SN_GAMS_gdx_vec_from_gdx_set, METH_VARARGS, NULL},
	 { (char *)"SN_GAMS_gdx_vec_from_gdx_get", _wrap_SN_GAMS_gdx_vec_from_gdx_get, METH_VARARGS, NULL},
	 { (char *)"new_SN_GAMS_gdx", _wrap_new_SN_GAMS_gdx, METH_VARARGS, NULL},
	 { (char *)"delete_SN_GAMS_gdx", _wrap_delete_SN_GAMS_gdx, METH_VARARGS, NULL},
	 { (char *)"SN_GAMS_gdx_swigregister", SN_GAMS_gdx_swigregister, METH_VARARGS, NULL},
	 { (char *)"GAMSP_get_filename", _wrap_GAMSP_get_filename, METH_VARARGS, NULL},
	 { (char *)"GAMSP_set_filename", _wrap_GAMSP_set_filename, METH_VARARGS, NULL},
	 { (char *)"GAMSP_get_filename_suffix", _wrap_GAMSP_get_filename_suffix, METH_VARARGS, NULL},
	 { (char *)"GAMSP_set_filename_suffix", _wrap_GAMSP_set_filename_suffix, METH_VARARGS, NULL},
	 { (char *)"SN_free_SN_GAMS_gdx", _wrap_SN_free_SN_GAMS_gdx, METH_VARARGS, NULL},
	 { (char *)"SN_GAMS_add_NM_to_gdx", _wrap_SN_GAMS_add_NM_to_gdx, METH_VARARGS, NULL},
	 { (char *)"SN_GAMS_add_NV_to_gdx", _wrap_SN_GAMS_add_NV_to_gdx, METH_VARARGS, NULL},
	 { (char *)"SN_GAMS_add_NV_from_gdx", _wrap_SN_GAMS_add_NV_from_gdx, METH_VARARGS, NULL},
	 { (char *)"GlobalFrictionContactProblem_dimension_set", _wrap_GlobalFrictionContactProblem_dimension_set, METH_VARARGS, NULL},
	 { (char *)"GlobalFrictionContactProblem_dimension_get", _wrap_GlobalFrictionContactProblem_dimension_get, METH_VARARGS, NULL},
	 { (char *)"GlobalFrictionContactProblem_numberOfContacts_set", _wrap_GlobalFrictionContactProblem_numberOfContacts_set, METH_VARARGS, NULL},
	 { (char *)"GlobalFrictionContactProblem_numberOfContacts_get", _wrap_GlobalFrictionContactProblem_numberOfContacts_get, METH_VARARGS, NULL},
	 { (char *)"GlobalFrictionContactProblem_M_set", _wrap_GlobalFrictionContactProblem_M_set, METH_VARARGS, NULL},
	 { (char *)"GlobalFrictionContactProblem_M_get", _wrap_GlobalFrictionContactProblem_M_get, METH_VARARGS, NULL},
	 { (char *)"GlobalFrictionContactProblem_H_set", _wrap_GlobalFrictionContactProblem_H_set, METH_VARARGS, NULL},
	 { (char *)"GlobalFrictionContactProblem_H_get", _wrap_GlobalFrictionContactProblem_H_get, METH_VARARGS, NULL},
	 { (char *)"GlobalFrictionContactProblem_q_set", _wrap_GlobalFrictionContactProblem_q_set, METH_VARARGS, NULL},
	 { (char *)"GlobalFrictionContactProblem_q_get", _wrap_GlobalFrictionContactProblem_q_get, METH_VARARGS, NULL},
	 { (char *)"GlobalFrictionContactProblem_b_set", _wrap_GlobalFrictionContactProblem_b_set, METH_VARARGS, NULL},
	 { (char *)"GlobalFrictionContactProblem_b_get", _wrap_GlobalFrictionContactProblem_b_get, METH_VARARGS, NULL},
	 { (char *)"GlobalFrictionContactProblem_mu_set", _wrap_GlobalFrictionContactProblem_mu_set, METH_VARARGS, NULL},
	 { (char *)"GlobalFrictionContactProblem_mu_get", _wrap_GlobalFrictionContactProblem_mu_get, METH_VARARGS, NULL},
	 { (char *)"GlobalFrictionContactProblem_env_set", _wrap_GlobalFrictionContactProblem_env_set, METH_VARARGS, NULL},
	 { (char *)"GlobalFrictionContactProblem_env_get", _wrap_GlobalFrictionContactProblem_env_get, METH_VARARGS, NULL},
	 { (char *)"new_GlobalFrictionContactProblem", _wrap_new_GlobalFrictionContactProblem, METH_VARARGS, NULL},
	 { (char *)"delete_GlobalFrictionContactProblem", _wrap_delete_GlobalFrictionContactProblem, METH_VARARGS, NULL},
	 { (char *)"GlobalFrictionContactProblem_swigregister", GlobalFrictionContactProblem_swigregister, METH_VARARGS, NULL},
	 { (char *)"globalFrictionContact_display", _wrap_globalFrictionContact_display, METH_VARARGS, NULL},
	 { (char *)"globalFrictionContact_printInFile", _wrap_globalFrictionContact_printInFile, METH_VARARGS, NULL},
	 { (char *)"globalFrictionContact_newFromFile", _wrap_globalFrictionContact_newFromFile, METH_VARARGS, NULL},
	 { (char *)"globalFrictionContact_null", _wrap_globalFrictionContact_null, METH_VARARGS, NULL},
	 { (char *)"freeGlobalFrictionContactProblem", _wrap_freeGlobalFrictionContactProblem, METH_VARARGS, NULL},
	 { (char *)"gfc3d_setDefaultSolverOptions", _wrap_gfc3d_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"gfc3d_set_internalsolver_tolerance", _wrap_gfc3d_set_internalsolver_tolerance, METH_VARARGS, NULL},
	 { (char *)"gfc3d_checkTrivialCaseGlobal", _wrap_gfc3d_checkTrivialCaseGlobal, METH_VARARGS, NULL},
	 { (char *)"gfc3d_nsgs_wr", _wrap_gfc3d_nsgs_wr, METH_VARARGS, NULL},
	 { (char *)"gfc3d_nsgs_wr_setDefaultSolverOptions", _wrap_gfc3d_nsgs_wr_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"gfc3d_admm_wr", _wrap_gfc3d_admm_wr, METH_VARARGS, NULL},
	 { (char *)"gfc3d_admm_wr_setDefaultSolverOptions", _wrap_gfc3d_admm_wr_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"gfc3d_nonsmooth_Newton_AlartCurnier_wr_setDefaultSolverOptions", _wrap_gfc3d_nonsmooth_Newton_AlartCurnier_wr_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"gfc3d_nonsmooth_Newton_AlartCurnier_wr", _wrap_gfc3d_nonsmooth_Newton_AlartCurnier_wr, METH_VARARGS, NULL},
	 { (char *)"gfc3d_proximal_wr", _wrap_gfc3d_proximal_wr, METH_VARARGS, NULL},
	 { (char *)"gfc3d_proximal_wr_setDefaultSolverOptions", _wrap_gfc3d_proximal_wr_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"gfc3d_DeSaxceFixedPoint_wr", _wrap_gfc3d_DeSaxceFixedPoint_wr, METH_VARARGS, NULL},
	 { (char *)"gfc3d_DeSaxceFixedPoint_setDefaultSolverOptions", _wrap_gfc3d_DeSaxceFixedPoint_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"gfc3d_TrescaFixedPoint_wr", _wrap_gfc3d_TrescaFixedPoint_wr, METH_VARARGS, NULL},
	 { (char *)"gfc3d_TrescaFixedPoint_setDefaultSolverOptions", _wrap_gfc3d_TrescaFixedPoint_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"gfc3d_nsgs_velocity_wr", _wrap_gfc3d_nsgs_velocity_wr, METH_VARARGS, NULL},
	 { (char *)"gfc3d_nsgs_velocity_wr_setDefaultSolverOptions", _wrap_gfc3d_nsgs_velocity_wr_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"gfc3d_nsgs", _wrap_gfc3d_nsgs, METH_VARARGS, NULL},
	 { (char *)"gfc3d_ACLMFixedPoint", _wrap_gfc3d_ACLMFixedPoint, METH_VARARGS, NULL},
	 { (char *)"gfc3d_ACLMFixedPoint_setDefaultSolverOptions", _wrap_gfc3d_ACLMFixedPoint_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"gfc3d_AVI_gams_path", _wrap_gfc3d_AVI_gams_path, METH_VARARGS, NULL},
	 { (char *)"gfc3d_AVI_gams_pathvi", _wrap_gfc3d_AVI_gams_pathvi, METH_VARARGS, NULL},
	 { (char *)"gfc3d_nonsmooth_Newton_AlartCurnier", _wrap_gfc3d_nonsmooth_Newton_AlartCurnier, METH_VARARGS, NULL},
	 { (char *)"gfc3d_VI_ExtraGradient", _wrap_gfc3d_VI_ExtraGradient, METH_VARARGS, NULL},
	 { (char *)"gfc3d_VI_ExtraGradient_setDefaultSolverOptions", _wrap_gfc3d_VI_ExtraGradient_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"gfc3d_VI_FixedPointProjection", _wrap_gfc3d_VI_FixedPointProjection, METH_VARARGS, NULL},
	 { (char *)"gfc3d_VI_FixedPointProjection_setDefaultSolverOptions", _wrap_gfc3d_VI_FixedPointProjection_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"gfc3d_ADMM", _wrap_gfc3d_ADMM, METH_VARARGS, NULL},
	 { (char *)"gfc3d_ADMM_init", _wrap_gfc3d_ADMM_init, METH_VARARGS, NULL},
	 { (char *)"gfc3d_ADMM_free", _wrap_gfc3d_ADMM_free, METH_VARARGS, NULL},
	 { (char *)"gfc3d_ADMM_setDefaultSolverOptions", _wrap_gfc3d_ADMM_setDefaultSolverOptions, METH_VARARGS, NULL},
	 { (char *)"gfc3d_compute_error", _wrap_gfc3d_compute_error, METH_VARARGS, NULL},
	 { NULL, NULL, 0, NULL }
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static swig_type_info _swigt__p_AffineVariationalInequalities = {"_p_AffineVariationalInequalities", "AffineVariationalInequalities *|struct AffineVariationalInequalities *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_AlartCurnierParams = {"_p_AlartCurnierParams", "AlartCurnierParams *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_CSparseMatrix_lu_factors = {"_p_CSparseMatrix_lu_factors", "CSparseMatrix_lu_factors *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Callback = {"_p_Callback", "Callback *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ConvexQP = {"_p_ConvexQP", "struct ConvexQP *|ConvexQP *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FILE = {"_p_FILE", "FILE *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FrictionContactProblem = {"_p_FrictionContactProblem", "FrictionContactProblem *|struct FrictionContactProblem *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_GAMS_opt_bool_ = {"_p_GAMS_opt_bool_", "GAMS_opt_bool *|struct GAMS_opt_bool_ *|GAMS_opt_bool_ *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_GAMS_opt_double_ = {"_p_GAMS_opt_double_", "struct GAMS_opt_double_ *|GAMS_opt_double_ *|GAMS_opt_double *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_GAMS_opt_int_ = {"_p_GAMS_opt_int_", "GAMS_opt_int *|struct GAMS_opt_int_ *|GAMS_opt_int_ *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_GAMS_opt_str_ = {"_p_GAMS_opt_str_", "GAMS_opt_str *|struct GAMS_opt_str_ *|GAMS_opt_str_ *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_GlobalFrictionContactProblem = {"_p_GlobalFrictionContactProblem", "GlobalFrictionContactProblem *|struct GlobalFrictionContactProblem *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_LinearComplementarityProblem = {"_p_LinearComplementarityProblem", "LinearComplementarityProblem *|struct LinearComplementarityProblem *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MixedComplementarityProblem = {"_p_MixedComplementarityProblem", "MixedComplementarityProblem *|struct MixedComplementarityProblem *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MixedComplementarityProblem2 = {"_p_MixedComplementarityProblem2", "MixedComplementarityProblem2 *|struct MixedComplementarityProblem2 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MixedLinearComplementarityProblem = {"_p_MixedLinearComplementarityProblem", "MixedLinearComplementarityProblem *|struct MixedLinearComplementarityProblem *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_NM_gesv_opts = {"_p_NM_gesv_opts", "enum NM_gesv_opts *|NM_gesv_opts *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_NSM_linear_solver = {"_p_NSM_linear_solver", "enum NSM_linear_solver *|NSM_linear_solver *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_NSM_linear_solver_params = {"_p_NSM_linear_solver_params", "struct NSM_linear_solver_params *|NSM_linear_solver_params *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_NonlinearComplementarityProblem = {"_p_NonlinearComplementarityProblem", "NonlinearComplementarityProblem *|struct NonlinearComplementarityProblem *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_NumericsMatrix = {"_p_NumericsMatrix", "NumericsMatrix *|struct NumericsMatrix *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_NumericsMatrixInternalData = {"_p_NumericsMatrixInternalData", "NumericsMatrixInternalData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_NumericsMatrix_types = {"_p_NumericsMatrix_types", "enum NumericsMatrix_types *|NM_types *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_NumericsSparseMatrix = {"_p_NumericsSparseMatrix", "NumericsSparseMatrix *|struct NumericsSparseMatrix *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_NumericsSparseOrigin = {"_p_NumericsSparseOrigin", "enum NumericsSparseOrigin *|NumericsSparseOrigin *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_NumericsSparseTypesNZ = {"_p_NumericsSparseTypesNZ", "enum NumericsSparseTypesNZ *|NumericsSparseTypesNZ *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_RelayProblem = {"_p_RelayProblem", "RelayProblem *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBM_index_by_column = {"_p_SBM_index_by_column", "struct SBM_index_by_column *|SBM_index_by_column *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SN_GAMS_NM_gdx_ = {"_p_SN_GAMS_NM_gdx_", "SN_GAMS_NM_gdx *|struct SN_GAMS_NM_gdx_ *|SN_GAMS_NM_gdx_ *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SN_GAMS_NV_gdx_ = {"_p_SN_GAMS_NV_gdx_", "SN_GAMS_NV_gdx *|struct SN_GAMS_NV_gdx_ *|SN_GAMS_NV_gdx_ *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SN_GAMS_gdx = {"_p_SN_GAMS_gdx", "SN_GAMS_gdx *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SN_GAMSparams = {"_p_SN_GAMSparams", "SN_GAMSparams *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SecondOrderConeLinearComplementarityProblem = {"_p_SecondOrderConeLinearComplementarityProblem", "SecondOrderConeLinearComplementarityProblem *|struct SecondOrderConeLinearComplementarityProblem *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SolverOptions = {"_p_SolverOptions", "SolverOptions *|struct SolverOptions *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SparseBlockCoordinateMatrix = {"_p_SparseBlockCoordinateMatrix", "struct SparseBlockCoordinateMatrix *|SparseBlockCoordinateMatrix *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SparseBlockStructuredMatrix = {"_p_SparseBlockStructuredMatrix", "SparseBlockStructuredMatrix *|struct SparseBlockStructuredMatrix *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SparseBlockStructuredMatrixPred = {"_p_SparseBlockStructuredMatrixPred", "struct SparseBlockStructuredMatrixPred *|SparseBlockStructuredMatrixPred *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SplittedFrictionContactProblem = {"_p_SplittedFrictionContactProblem", "struct SplittedFrictionContactProblem *|SplittedFrictionContactProblem *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_VariationalInequality = {"_p_VariationalInequality", "VariationalInequality *|struct VariationalInequality *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_cs_di_numeric = {"_p_cs_di_numeric", "struct cs_di_numeric *|cs_din *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_cs_di_symbolic = {"_p_cs_di_symbolic", "cs_dis *|struct cs_di_symbolic *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_cs_dl_numeric = {"_p_cs_dl_numeric", "cs_dln *|struct cs_dl_numeric *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_cs_dl_sparse = {"_p_cs_dl_sparse", "struct cs_dl_sparse *|CSparseMatrix *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_cs_dl_symbolic = {"_p_cs_dl_symbolic", "cs_dls *|struct cs_dl_symbolic *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_double = {"_p_double", "double *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_int_p_double_p_double__void = {"_p_f_int_p_double_p_double__void", "ptrFunctionMCP|void (*)(int,double *,double *)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_double_p_double_double_p_double_p_double_p_double_p_double__void = {"_p_f_p_double_p_double_double_p_double_p_double_p_double_p_double__void", "void (*)(double *,double *,double,double *,double *,double *,double *)|AlartCurnierFun3x3Ptr|FischerBurmeisterFun3x3Ptr|NaturalMapFun3x3Ptr", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_struct_linalg_data_t__void = {"_p_f_p_struct_linalg_data_t__void", "void (*)(struct linalg_data_t *)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_void__void = {"_p_f_p_void__void", "freeNSLSP|void (*)(void *)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_void_int_p_double_p_NumericsMatrix__void = {"_p_f_p_void_int_p_double_p_NumericsMatrix__void", "ptrFunctionVI_nabla|ptrFunctionMCP_nabla|void (*)(void *,int,double *,NumericsMatrix *)|ptrFunctionJacNCP", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_void_int_p_double_p_double__void = {"_p_f_p_void_int_p_double_p_double__void", "ptrFunctionMCP2|ptrFunctionVI|void (*)(void *,int,double *,double *)|ptrFunctionNCP", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_void_int_p_double_p_double_double_p_void__void = {"_p_f_p_void_int_p_double_p_double_double_p_void__void", "void (*)(void *,int,double *,double *,double,void *)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_void_p_double_p_double__p_void = {"_p_f_p_void_p_double_p_double__p_void", "void *(*)(void *,double *,double *)|FVIPtr *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_void_p_double_p_double__void = {"_p_f_p_void_p_double_p_double__void", "void (*)(void *,double *,double *)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_int = {"_p_int", "int *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_linalg_data_id = {"_p_linalg_data_id", "enum linalg_data_id *|linalg_data_id *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_linalg_data_t = {"_p_linalg_data_t", "struct linalg_data_t *|linalg_data_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_long = {"_p_long", "long *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_PyObject = {"_p_p_PyObject", "PyObject **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_double = {"_p_p_double", "double **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_f_int_p_FrictionContactProblem_p_FrictionContactProblem_p_double_p_SolverOptions__void = {"_p_p_f_int_p_FrictionContactProblem_p_FrictionContactProblem_p_double_p_SolverOptions__void", "void (**)(int,FrictionContactProblem *,FrictionContactProblem *,double *,SolverOptions *)|UpdatePtr *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_f_p_FrictionContactProblem_p_FrictionContactProblem_p_SolverOptions__void = {"_p_p_f_p_FrictionContactProblem_p_FrictionContactProblem_p_SolverOptions__void", "void (**)(FrictionContactProblem *,FrictionContactProblem *,SolverOptions *)|FreeSolverNSGSPtr *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_f_p_FrictionContactProblem_p_double_p_SolverOptions__int = {"_p_p_f_p_FrictionContactProblem_p_double_p_SolverOptions__int", "int (**)(FrictionContactProblem *,double *,SolverOptions *)|SolverPtr *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_f_p_FrictionContactProblem_p_double_p_double_double_p_SolverOptions_double_p_double__void = {"_p_p_f_p_FrictionContactProblem_p_double_p_double_double_p_SolverOptions_double_p_double__void", "ComputeErrorPtr *|void (**)(FrictionContactProblem *,double *,double *,double,SolverOptions *,double,double *)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_int = {"_p_p_int", "int **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_polyhedron_set = {"_p_polyhedron_set", "polyhedron_set *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_size_t = {"_p_size_t", "size_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_uintptr_t = {"_p_uintptr_t", "uintptr_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "unsigned int *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_void = {"_p_void", "void *", 0, 0, (void*)0, 0};

static swig_type_info *swig_type_initial[] = {
  &_swigt__p_AffineVariationalInequalities,
  &_swigt__p_AlartCurnierParams,
  &_swigt__p_CSparseMatrix_lu_factors,
  &_swigt__p_Callback,
  &_swigt__p_ConvexQP,
  &_swigt__p_FILE,
  &_swigt__p_FrictionContactProblem,
  &_swigt__p_GAMS_opt_bool_,
  &_swigt__p_GAMS_opt_double_,
  &_swigt__p_GAMS_opt_int_,
  &_swigt__p_GAMS_opt_str_,
  &_swigt__p_GlobalFrictionContactProblem,
  &_swigt__p_LinearComplementarityProblem,
  &_swigt__p_MixedComplementarityProblem,
  &_swigt__p_MixedComplementarityProblem2,
  &_swigt__p_MixedLinearComplementarityProblem,
  &_swigt__p_NM_gesv_opts,
  &_swigt__p_NSM_linear_solver,
  &_swigt__p_NSM_linear_solver_params,
  &_swigt__p_NonlinearComplementarityProblem,
  &_swigt__p_NumericsMatrix,
  &_swigt__p_NumericsMatrixInternalData,
  &_swigt__p_NumericsMatrix_types,
  &_swigt__p_NumericsSparseMatrix,
  &_swigt__p_NumericsSparseOrigin,
  &_swigt__p_NumericsSparseTypesNZ,
  &_swigt__p_RelayProblem,
  &_swigt__p_SBM_index_by_column,
  &_swigt__p_SN_GAMS_NM_gdx_,
  &_swigt__p_SN_GAMS_NV_gdx_,
  &_swigt__p_SN_GAMS_gdx,
  &_swigt__p_SN_GAMSparams,
  &_swigt__p_SecondOrderConeLinearComplementarityProblem,
  &_swigt__p_SolverOptions,
  &_swigt__p_SparseBlockCoordinateMatrix,
  &_swigt__p_SparseBlockStructuredMatrix,
  &_swigt__p_SparseBlockStructuredMatrixPred,
  &_swigt__p_SplittedFrictionContactProblem,
  &_swigt__p_VariationalInequality,
  &_swigt__p_char,
  &_swigt__p_cs_di_numeric,
  &_swigt__p_cs_di_symbolic,
  &_swigt__p_cs_dl_numeric,
  &_swigt__p_cs_dl_sparse,
  &_swigt__p_cs_dl_symbolic,
  &_swigt__p_double,
  &_swigt__p_f_int_p_double_p_double__void,
  &_swigt__p_f_p_double_p_double_double_p_double_p_double_p_double_p_double__void,
  &_swigt__p_f_p_struct_linalg_data_t__void,
  &_swigt__p_f_p_void__void,
  &_swigt__p_f_p_void_int_p_double_p_NumericsMatrix__void,
  &_swigt__p_f_p_void_int_p_double_p_double__void,
  &_swigt__p_f_p_void_int_p_double_p_double_double_p_void__void,
  &_swigt__p_f_p_void_p_double_p_double__p_void,
  &_swigt__p_f_p_void_p_double_p_double__void,
  &_swigt__p_int,
  &_swigt__p_linalg_data_id,
  &_swigt__p_linalg_data_t,
  &_swigt__p_long,
  &_swigt__p_p_PyObject,
  &_swigt__p_p_double,
  &_swigt__p_p_f_int_p_FrictionContactProblem_p_FrictionContactProblem_p_double_p_SolverOptions__void,
  &_swigt__p_p_f_p_FrictionContactProblem_p_FrictionContactProblem_p_SolverOptions__void,
  &_swigt__p_p_f_p_FrictionContactProblem_p_double_p_SolverOptions__int,
  &_swigt__p_p_f_p_FrictionContactProblem_p_double_p_double_double_p_SolverOptions_double_p_double__void,
  &_swigt__p_p_int,
  &_swigt__p_polyhedron_set,
  &_swigt__p_size_t,
  &_swigt__p_uintptr_t,
  &_swigt__p_unsigned_int,
  &_swigt__p_void,
};

static swig_cast_info _swigc__p_AffineVariationalInequalities[] = {  {&_swigt__p_AffineVariationalInequalities, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AlartCurnierParams[] = {  {&_swigt__p_AlartCurnierParams, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CSparseMatrix_lu_factors[] = {  {&_swigt__p_CSparseMatrix_lu_factors, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Callback[] = {  {&_swigt__p_Callback, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ConvexQP[] = {  {&_swigt__p_ConvexQP, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FILE[] = {  {&_swigt__p_FILE, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FrictionContactProblem[] = {  {&_swigt__p_FrictionContactProblem, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_GAMS_opt_bool_[] = {  {&_swigt__p_GAMS_opt_bool_, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_GAMS_opt_double_[] = {  {&_swigt__p_GAMS_opt_double_, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_GAMS_opt_int_[] = {  {&_swigt__p_GAMS_opt_int_, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_GAMS_opt_str_[] = {  {&_swigt__p_GAMS_opt_str_, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_GlobalFrictionContactProblem[] = {  {&_swigt__p_GlobalFrictionContactProblem, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_LinearComplementarityProblem[] = {  {&_swigt__p_LinearComplementarityProblem, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MixedComplementarityProblem[] = {  {&_swigt__p_MixedComplementarityProblem, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MixedComplementarityProblem2[] = {  {&_swigt__p_MixedComplementarityProblem2, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MixedLinearComplementarityProblem[] = {  {&_swigt__p_MixedLinearComplementarityProblem, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_NM_gesv_opts[] = {  {&_swigt__p_NM_gesv_opts, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_NSM_linear_solver[] = {  {&_swigt__p_NSM_linear_solver, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_NSM_linear_solver_params[] = {  {&_swigt__p_NSM_linear_solver_params, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_NonlinearComplementarityProblem[] = {  {&_swigt__p_NonlinearComplementarityProblem, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_NumericsMatrix[] = {  {&_swigt__p_NumericsMatrix, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_NumericsMatrixInternalData[] = {  {&_swigt__p_NumericsMatrixInternalData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_NumericsMatrix_types[] = {  {&_swigt__p_NumericsMatrix_types, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_NumericsSparseMatrix[] = {  {&_swigt__p_NumericsSparseMatrix, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_NumericsSparseOrigin[] = {  {&_swigt__p_NumericsSparseOrigin, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_NumericsSparseTypesNZ[] = {  {&_swigt__p_NumericsSparseTypesNZ, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_RelayProblem[] = {  {&_swigt__p_RelayProblem, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBM_index_by_column[] = {  {&_swigt__p_SBM_index_by_column, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SN_GAMS_NM_gdx_[] = {  {&_swigt__p_SN_GAMS_NM_gdx_, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SN_GAMS_NV_gdx_[] = {  {&_swigt__p_SN_GAMS_NV_gdx_, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SN_GAMS_gdx[] = {  {&_swigt__p_SN_GAMS_gdx, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SN_GAMSparams[] = {  {&_swigt__p_SN_GAMSparams, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SecondOrderConeLinearComplementarityProblem[] = {  {&_swigt__p_SecondOrderConeLinearComplementarityProblem, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SolverOptions[] = {  {&_swigt__p_SolverOptions, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SparseBlockCoordinateMatrix[] = {  {&_swigt__p_SparseBlockCoordinateMatrix, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SparseBlockStructuredMatrix[] = {  {&_swigt__p_SparseBlockStructuredMatrix, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SparseBlockStructuredMatrixPred[] = {  {&_swigt__p_SparseBlockStructuredMatrixPred, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SplittedFrictionContactProblem[] = {  {&_swigt__p_SplittedFrictionContactProblem, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VariationalInequality[] = {  {&_swigt__p_VariationalInequality, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_cs_di_numeric[] = {  {&_swigt__p_cs_di_numeric, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_cs_di_symbolic[] = {  {&_swigt__p_cs_di_symbolic, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_cs_dl_numeric[] = {  {&_swigt__p_cs_dl_numeric, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_cs_dl_sparse[] = {  {&_swigt__p_cs_dl_sparse, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_cs_dl_symbolic[] = {  {&_swigt__p_cs_dl_symbolic, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_double[] = {  {&_swigt__p_double, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_int_p_double_p_double__void[] = {  {&_swigt__p_f_int_p_double_p_double__void, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_double_p_double_double_p_double_p_double_p_double_p_double__void[] = {  {&_swigt__p_f_p_double_p_double_double_p_double_p_double_p_double_p_double__void, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_struct_linalg_data_t__void[] = {  {&_swigt__p_f_p_struct_linalg_data_t__void, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_void__void[] = {  {&_swigt__p_f_p_void__void, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_void_int_p_double_p_NumericsMatrix__void[] = {  {&_swigt__p_f_p_void_int_p_double_p_NumericsMatrix__void, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_void_int_p_double_p_double__void[] = {  {&_swigt__p_f_p_void_int_p_double_p_double__void, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_void_int_p_double_p_double_double_p_void__void[] = {  {&_swigt__p_f_p_void_int_p_double_p_double_double_p_void__void, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_void_p_double_p_double__p_void[] = {  {&_swigt__p_f_p_void_p_double_p_double__p_void, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_void_p_double_p_double__void[] = {  {&_swigt__p_f_p_void_p_double_p_double__void, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_int[] = {  {&_swigt__p_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_linalg_data_id[] = {  {&_swigt__p_linalg_data_id, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_linalg_data_t[] = {  {&_swigt__p_linalg_data_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_long[] = {  {&_swigt__p_long, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_PyObject[] = {  {&_swigt__p_p_PyObject, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_double[] = {  {&_swigt__p_p_double, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_f_int_p_FrictionContactProblem_p_FrictionContactProblem_p_double_p_SolverOptions__void[] = {  {&_swigt__p_p_f_int_p_FrictionContactProblem_p_FrictionContactProblem_p_double_p_SolverOptions__void, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_f_p_FrictionContactProblem_p_FrictionContactProblem_p_SolverOptions__void[] = {  {&_swigt__p_p_f_p_FrictionContactProblem_p_FrictionContactProblem_p_SolverOptions__void, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_f_p_FrictionContactProblem_p_double_p_SolverOptions__int[] = {  {&_swigt__p_p_f_p_FrictionContactProblem_p_double_p_SolverOptions__int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_f_p_FrictionContactProblem_p_double_p_double_double_p_SolverOptions_double_p_double__void[] = {  {&_swigt__p_p_f_p_FrictionContactProblem_p_double_p_double_double_p_SolverOptions_double_p_double__void, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_int[] = {  {&_swigt__p_p_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_polyhedron_set[] = {  {&_swigt__p_polyhedron_set, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_size_t[] = {  {&_swigt__p_size_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_uintptr_t[] = {  {&_swigt__p_uintptr_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_int[] = {  {&_swigt__p_unsigned_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_void[] = {  {&_swigt__p_void, 0, 0, 0},{0, 0, 0, 0}};

static swig_cast_info *swig_cast_initial[] = {
  _swigc__p_AffineVariationalInequalities,
  _swigc__p_AlartCurnierParams,
  _swigc__p_CSparseMatrix_lu_factors,
  _swigc__p_Callback,
  _swigc__p_ConvexQP,
  _swigc__p_FILE,
  _swigc__p_FrictionContactProblem,
  _swigc__p_GAMS_opt_bool_,
  _swigc__p_GAMS_opt_double_,
  _swigc__p_GAMS_opt_int_,
  _swigc__p_GAMS_opt_str_,
  _swigc__p_GlobalFrictionContactProblem,
  _swigc__p_LinearComplementarityProblem,
  _swigc__p_MixedComplementarityProblem,
  _swigc__p_MixedComplementarityProblem2,
  _swigc__p_MixedLinearComplementarityProblem,
  _swigc__p_NM_gesv_opts,
  _swigc__p_NSM_linear_solver,
  _swigc__p_NSM_linear_solver_params,
  _swigc__p_NonlinearComplementarityProblem,
  _swigc__p_NumericsMatrix,
  _swigc__p_NumericsMatrixInternalData,
  _swigc__p_NumericsMatrix_types,
  _swigc__p_NumericsSparseMatrix,
  _swigc__p_NumericsSparseOrigin,
  _swigc__p_NumericsSparseTypesNZ,
  _swigc__p_RelayProblem,
  _swigc__p_SBM_index_by_column,
  _swigc__p_SN_GAMS_NM_gdx_,
  _swigc__p_SN_GAMS_NV_gdx_,
  _swigc__p_SN_GAMS_gdx,
  _swigc__p_SN_GAMSparams,
  _swigc__p_SecondOrderConeLinearComplementarityProblem,
  _swigc__p_SolverOptions,
  _swigc__p_SparseBlockCoordinateMatrix,
  _swigc__p_SparseBlockStructuredMatrix,
  _swigc__p_SparseBlockStructuredMatrixPred,
  _swigc__p_SplittedFrictionContactProblem,
  _swigc__p_VariationalInequality,
  _swigc__p_char,
  _swigc__p_cs_di_numeric,
  _swigc__p_cs_di_symbolic,
  _swigc__p_cs_dl_numeric,
  _swigc__p_cs_dl_sparse,
  _swigc__p_cs_dl_symbolic,
  _swigc__p_double,
  _swigc__p_f_int_p_double_p_double__void,
  _swigc__p_f_p_double_p_double_double_p_double_p_double_p_double_p_double__void,
  _swigc__p_f_p_struct_linalg_data_t__void,
  _swigc__p_f_p_void__void,
  _swigc__p_f_p_void_int_p_double_p_NumericsMatrix__void,
  _swigc__p_f_p_void_int_p_double_p_double__void,
  _swigc__p_f_p_void_int_p_double_p_double_double_p_void__void,
  _swigc__p_f_p_void_p_double_p_double__p_void,
  _swigc__p_f_p_void_p_double_p_double__void,
  _swigc__p_int,
  _swigc__p_linalg_data_id,
  _swigc__p_linalg_data_t,
  _swigc__p_long,
  _swigc__p_p_PyObject,
  _swigc__p_p_double,
  _swigc__p_p_f_int_p_FrictionContactProblem_p_FrictionContactProblem_p_double_p_SolverOptions__void,
  _swigc__p_p_f_p_FrictionContactProblem_p_FrictionContactProblem_p_SolverOptions__void,
  _swigc__p_p_f_p_FrictionContactProblem_p_double_p_SolverOptions__int,
  _swigc__p_p_f_p_FrictionContactProblem_p_double_p_double_double_p_SolverOptions_double_p_double__void,
  _swigc__p_p_int,
  _swigc__p_polyhedron_set,
  _swigc__p_size_t,
  _swigc__p_uintptr_t,
  _swigc__p_unsigned_int,
  _swigc__p_void,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

static swig_const_info swig_const_table[] = {
{0, 0, 0, 0.0, 0, 0}};

#ifdef __cplusplus
}
#endif
/* -----------------------------------------------------------------------------
 * Type initialization:
 * This problem is tough by the requirement that no dynamic
 * memory is used. Also, since swig_type_info structures store pointers to
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization.
 * The idea is that swig generates all the structures that are needed.
 * The runtime then collects these partially filled structures.
 * The SWIG_InitializeModule function takes these initial arrays out of
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.
 *
 * The generated swig_type_info structures are assigned statically to an initial
 * array. We just loop through that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.
 *
 * First off, we lookup the cast->type name to see if it is already loaded.
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* c-mode */
#endif
#endif

#if 0
#define SWIGRUNTIME_DEBUG
#endif


SWIGRUNTIME void
SWIG_InitializeModule(void *clientdata) {
  size_t i;
  swig_module_info *module_head, *iter;
  int init;
  
  /* check to see if the circular list has been setup, if not, set it up */
  if (swig_module.next==0) {
    /* Initialize the swig_module */
    swig_module.type_initial = swig_type_initial;
    swig_module.cast_initial = swig_cast_initial;
    swig_module.next = &swig_module;
    init = 1;
  } else {
    init = 0;
  }
  
  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (!module_head) {
    /* This is the first module loaded for this interpreter */
    /* so set the swig module into the interpreter */
    SWIG_SetModule(clientdata, &swig_module);
  } else {
    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
    iter=module_head;
    do {
      if (iter==&swig_module) {
        /* Our module is already in the list, so there's nothing more to do. */
        return;
      }
      iter=iter->next;
    } while (iter!= module_head);
    
    /* otherwise we must add our module into the list */
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  }
  
  /* When multiple interpreters are used, a module could have already been initialized in
       a different interpreter, but not yet have a pointer in this interpreter.
       In this case, we do not want to continue adding types... everything should be
       set up already */
  if (init == 0) return;
  
  /* Now work on filling in swig_module.types */
#ifdef SWIGRUNTIME_DEBUG
  printf("SWIG_InitializeModule: size %d\n", swig_module.size);
#endif
  for (i = 0; i < swig_module.size; ++i) {
    swig_type_info *type = 0;
    swig_type_info *ret;
    swig_cast_info *cast;
    
#ifdef SWIGRUNTIME_DEBUG
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
#endif
    
    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found type %s\n", type->name);
#endif
      if (swig_module.type_initial[i]->clientdata) {
        type->clientdata = swig_module.type_initial[i]->clientdata;
#ifdef SWIGRUNTIME_DEBUG
        printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
#endif
      }
    } else {
      type = swig_module.type_initial[i];
    }
    
    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {
      /* Don't need to add information already in the list */
      ret = 0;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
#endif
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
#ifdef SWIGRUNTIME_DEBUG
        if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
#endif
      }
      if (ret) {
        if (type == swig_module.type_initial[i]) {
#ifdef SWIGRUNTIME_DEBUG
          printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
#endif
          cast->type = ret;
          ret = 0;
        } else {
          /* Check for casting already in the list */
          swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
#ifdef SWIGRUNTIME_DEBUG
          if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
#endif
          if (!ocast) ret = 0;
        }
      }
      
      if (!ret) {
#ifdef SWIGRUNTIME_DEBUG
        printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
#endif
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }
      cast++;
    }
    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;
  
#ifdef SWIGRUNTIME_DEBUG
  printf("**** SWIG_InitializeModule: Cast List ******\n");
  for (i = 0; i < swig_module.size; ++i) {
    int j = 0;
    swig_cast_info *cast = swig_module.cast_initial[i];
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
    while (cast->type) {
      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
      cast++;
      ++j;
    }
    printf("---- Total casts: %d\n",j);
  }
  printf("**** SWIG_InitializeModule: Cast List ******\n");
#endif
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;
  
  if (init_run) return;
  init_run = 1;
  
  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
          SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
#if 0
{
  /* c-mode */
#endif
}
#endif



#ifdef __cplusplus
extern "C" {
#endif
  
  /* Python-specific SWIG API */
#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
  
  /* -----------------------------------------------------------------------------
   * global variable support code.
   * ----------------------------------------------------------------------------- */
  
  typedef struct swig_globalvar {
    char       *name;                  /* Name of global variable */
    PyObject *(*get_attr)(void);       /* Return the current value */
    int       (*set_attr)(PyObject *); /* Set the value */
    struct swig_globalvar *next;
  } swig_globalvar;
  
  typedef struct swig_varlinkobject {
    PyObject_HEAD
    swig_globalvar *vars;
  } swig_varlinkobject;
  
  SWIGINTERN PyObject *
  swig_varlink_repr(swig_varlinkobject *SWIGUNUSEDPARM(v)) {
#if PY_VERSION_HEX >= 0x03000000
    return PyUnicode_InternFromString("<Swig global variables>");
#else
    return PyString_FromString("<Swig global variables>");
#endif
  }
  
  SWIGINTERN PyObject *
  swig_varlink_str(swig_varlinkobject *v) {
#if PY_VERSION_HEX >= 0x03000000
    PyObject *str = PyUnicode_InternFromString("(");
    PyObject *tail;
    PyObject *joined;
    swig_globalvar *var;
    for (var = v->vars; var; var=var->next) {
      tail = PyUnicode_FromString(var->name);
      joined = PyUnicode_Concat(str, tail);
      Py_DecRef(str);
      Py_DecRef(tail);
      str = joined;
      if (var->next) {
        tail = PyUnicode_InternFromString(", ");
        joined = PyUnicode_Concat(str, tail);
        Py_DecRef(str);
        Py_DecRef(tail);
        str = joined;
      }
    }
    tail = PyUnicode_InternFromString(")");
    joined = PyUnicode_Concat(str, tail);
    Py_DecRef(str);
    Py_DecRef(tail);
    str = joined;
#else
    PyObject *str = PyString_FromString("(");
    swig_globalvar *var;
    for (var = v->vars; var; var=var->next) {
      PyString_ConcatAndDel(&str,PyString_FromString(var->name));
      if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
    }
    PyString_ConcatAndDel(&str,PyString_FromString(")"));
#endif
    return str;
  }
  
  SWIGINTERN int
  swig_varlink_print(swig_varlinkobject *v, FILE *fp, int SWIGUNUSEDPARM(flags)) {
    char *tmp;
    PyObject *str = swig_varlink_str(v);
    fprintf(fp,"Swig global variables ");
    fprintf(fp,"%s\n", tmp = SWIG_Python_str_AsChar(str));
    SWIG_Python_str_DelForPy3(tmp);
    Py_DECREF(str);
    return 0;
  }
  
  SWIGINTERN void
  swig_varlink_dealloc(swig_varlinkobject *v) {
    swig_globalvar *var = v->vars;
    while (var) {
      swig_globalvar *n = var->next;
      free(var->name);
      free(var);
      var = n;
    }
  }
  
  SWIGINTERN PyObject *
  swig_varlink_getattr(swig_varlinkobject *v, char *n) {
    PyObject *res = NULL;
    swig_globalvar *var = v->vars;
    while (var) {
      if (strcmp(var->name,n) == 0) {
        res = (*var->get_attr)();
        break;
      }
      var = var->next;
    }
    if (res == NULL && !PyErr_Occurred()) {
      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
    }
    return res;
  }
  
  SWIGINTERN int
  swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
    int res = 1;
    swig_globalvar *var = v->vars;
    while (var) {
      if (strcmp(var->name,n) == 0) {
        res = (*var->set_attr)(p);
        break;
      }
      var = var->next;
    }
    if (res == 1 && !PyErr_Occurred()) {
      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
    }
    return res;
  }
  
  SWIGINTERN PyTypeObject*
  swig_varlink_type(void) {
    static char varlink__doc__[] = "Swig var link object";
    static PyTypeObject varlink_type;
    static int type_init = 0;
    if (!type_init) {
      const PyTypeObject tmp = {
#if PY_VERSION_HEX >= 0x03000000
        PyVarObject_HEAD_INIT(NULL, 0)
#else
        PyObject_HEAD_INIT(NULL)
        0,                                  /* ob_size */
#endif
        (char *)"swigvarlink",              /* tp_name */
        sizeof(swig_varlinkobject),         /* tp_basicsize */
        0,                                  /* tp_itemsize */
        (destructor) swig_varlink_dealloc,  /* tp_dealloc */
        (printfunc) swig_varlink_print,     /* tp_print */
        (getattrfunc) swig_varlink_getattr, /* tp_getattr */
        (setattrfunc) swig_varlink_setattr, /* tp_setattr */
        0,                                  /* tp_compare */
        (reprfunc) swig_varlink_repr,       /* tp_repr */
        0,                                  /* tp_as_number */
        0,                                  /* tp_as_sequence */
        0,                                  /* tp_as_mapping */
        0,                                  /* tp_hash */
        0,                                  /* tp_call */
        (reprfunc) swig_varlink_str,        /* tp_str */
        0,                                  /* tp_getattro */
        0,                                  /* tp_setattro */
        0,                                  /* tp_as_buffer */
        0,                                  /* tp_flags */
        varlink__doc__,                     /* tp_doc */
        0,                                  /* tp_traverse */
        0,                                  /* tp_clear */
        0,                                  /* tp_richcompare */
        0,                                  /* tp_weaklistoffset */
#if PY_VERSION_HEX >= 0x02020000
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
#endif
#if PY_VERSION_HEX >= 0x02030000
        0,                                  /* tp_del */
#endif
#if PY_VERSION_HEX >= 0x02060000
        0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
        0,                                  /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
        0,                                  /* tp_allocs */
        0,                                  /* tp_frees */
        0,                                  /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
        0,                                  /* tp_prev */
#endif
        0                                   /* tp_next */
#endif
      };
      varlink_type = tmp;
      type_init = 1;
#if PY_VERSION_HEX < 0x02020000
      varlink_type.ob_type = &PyType_Type;
#else
      if (PyType_Ready(&varlink_type) < 0)
      return NULL;
#endif
    }
    return &varlink_type;
  }
  
  /* Create a variable linking object for use later */
  SWIGINTERN PyObject *
  SWIG_Python_newvarlink(void) {
    swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
    if (result) {
      result->vars = 0;
    }
    return ((PyObject*) result);
  }
  
  SWIGINTERN void 
  SWIG_Python_addvarlink(PyObject *p, char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
    swig_varlinkobject *v = (swig_varlinkobject *) p;
    swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
    if (gv) {
      size_t size = strlen(name)+1;
      gv->name = (char *)malloc(size);
      if (gv->name) {
        strncpy(gv->name,name,size);
        gv->get_attr = get_attr;
        gv->set_attr = set_attr;
        gv->next = v->vars;
      }
    }
    v->vars = gv;
  }
  
  SWIGINTERN PyObject *
  SWIG_globals(void) {
    static PyObject *_SWIG_globals = 0; 
    if (!_SWIG_globals) _SWIG_globals = SWIG_newvarlink();  
    return _SWIG_globals;
  }
  
  /* -----------------------------------------------------------------------------
   * constants/methods manipulation
   * ----------------------------------------------------------------------------- */
  
  /* Install Constants */
  SWIGINTERN void
  SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
    PyObject *obj = 0;
    size_t i;
    for (i = 0; constants[i].type; ++i) {
      switch(constants[i].type) {
      case SWIG_PY_POINTER:
        obj = SWIG_InternalNewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
        break;
      case SWIG_PY_BINARY:
        obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
        break;
      default:
        obj = 0;
        break;
      }
      if (obj) {
        PyDict_SetItemString(d, constants[i].name, obj);
        Py_DECREF(obj);
      }
    }
  }
  
  /* -----------------------------------------------------------------------------*/
  /* Fix SwigMethods to carry the callback ptrs when needed */
  /* -----------------------------------------------------------------------------*/
  
  SWIGINTERN void
  SWIG_Python_FixMethods(PyMethodDef *methods,
    swig_const_info *const_table,
    swig_type_info **types,
    swig_type_info **types_initial) {
    size_t i;
    for (i = 0; methods[i].ml_name; ++i) {
      const char *c = methods[i].ml_doc;
      if (!c) continue;
      c = strstr(c, "swig_ptr: ");
      if (c) {
        int j;
        swig_const_info *ci = 0;
        const char *name = c + 10;
        for (j = 0; const_table[j].type; ++j) {
          if (strncmp(const_table[j].name, name, 
              strlen(const_table[j].name)) == 0) {
            ci = &(const_table[j]);
            break;
          }
        }
        if (ci) {
          void *ptr = (ci->type == SWIG_PY_POINTER) ? ci->pvalue : 0;
          if (ptr) {
            size_t shift = (ci->ptype) - types;
            swig_type_info *ty = types_initial[shift];
            size_t ldoc = (c - methods[i].ml_doc);
            size_t lptr = strlen(ty->name)+2*sizeof(void*)+2;
            char *ndoc = (char*)malloc(ldoc + lptr + 10);
            if (ndoc) {
              char *buff = ndoc;
              strncpy(buff, methods[i].ml_doc, ldoc);
              buff += ldoc;
              strncpy(buff, "swig_ptr: ", 10);
              buff += 10;
              SWIG_PackVoidPtr(buff, ptr, ty->name, lptr);
              methods[i].ml_doc = ndoc;
            }
          }
        }
      }
    }
  } 
  
#ifdef __cplusplus
}
#endif

/* -----------------------------------------------------------------------------*
 *  Partial Init method
 * -----------------------------------------------------------------------------*/

#ifdef __cplusplus
extern "C"
#endif

SWIGEXPORT 
#if PY_VERSION_HEX >= 0x03000000
PyObject*
#else
void
#endif
SWIG_init(void) {
  PyObject *m, *d, *md;
#if PY_VERSION_HEX >= 0x03000000
  static struct PyModuleDef SWIG_module = {
# if PY_VERSION_HEX >= 0x03020000
    PyModuleDef_HEAD_INIT,
# else
    {
      PyObject_HEAD_INIT(NULL)
      NULL, /* m_init */
      0,    /* m_index */
      NULL, /* m_copy */
    },
# endif
    (char *) SWIG_name,
    NULL,
    -1,
    SwigMethods,
    NULL,
    NULL,
    NULL,
    NULL
  };
#endif
  
#if defined(SWIGPYTHON_BUILTIN)
  static SwigPyClientData SwigPyObject_clientdata = {
    0, 0, 0, 0, 0, 0, 0
  };
  static PyGetSetDef this_getset_def = {
    (char *)"this", &SwigPyBuiltin_ThisClosure, NULL, NULL, NULL
  };
  static SwigPyGetSet thisown_getset_closure = {
    (PyCFunction) SwigPyObject_own,
    (PyCFunction) SwigPyObject_own
  };
  static PyGetSetDef thisown_getset_def = {
    (char *)"thisown", SwigPyBuiltin_GetterClosure, SwigPyBuiltin_SetterClosure, NULL, &thisown_getset_closure
  };
  PyTypeObject *builtin_pytype;
  int builtin_base_count;
  swig_type_info *builtin_basetype;
  PyObject *tuple;
  PyGetSetDescrObject *static_getset;
  PyTypeObject *metatype;
  PyTypeObject *swigpyobject;
  SwigPyClientData *cd;
  PyObject *public_interface, *public_symbol;
  PyObject *this_descr;
  PyObject *thisown_descr;
  PyObject *self = 0;
  int i;
  
  (void)builtin_pytype;
  (void)builtin_base_count;
  (void)builtin_basetype;
  (void)tuple;
  (void)static_getset;
  (void)self;
  
  /* Metaclass is used to implement static member variables */
  metatype = SwigPyObjectType();
  assert(metatype);
#endif
  
  /* Fix SwigMethods to carry the callback ptrs when needed */
  SWIG_Python_FixMethods(SwigMethods, swig_const_table, swig_types, swig_type_initial);
  
#if PY_VERSION_HEX >= 0x03000000
  m = PyModule_Create(&SWIG_module);
#else
  m = Py_InitModule((char *) SWIG_name, SwigMethods);
#endif
  
  md = d = PyModule_GetDict(m);
  (void)md;
  
  SWIG_InitializeModule(0);
  
#ifdef SWIGPYTHON_BUILTIN
  swigpyobject = SwigPyObject_TypeOnce();
  
  SwigPyObject_stype = SWIG_MangledTypeQuery("_p_SwigPyObject");
  assert(SwigPyObject_stype);
  cd = (SwigPyClientData*) SwigPyObject_stype->clientdata;
  if (!cd) {
    SwigPyObject_stype->clientdata = &SwigPyObject_clientdata;
    SwigPyObject_clientdata.pytype = swigpyobject;
  } else if (swigpyobject->tp_basicsize != cd->pytype->tp_basicsize) {
    PyErr_SetString(PyExc_RuntimeError, "Import error: attempted to load two incompatible swig-generated modules.");
# if PY_VERSION_HEX >= 0x03000000
    return NULL;
# else
    return;
# endif
  }
  
  /* All objects have a 'this' attribute */
  this_descr = PyDescr_NewGetSet(SwigPyObject_type(), &this_getset_def);
  (void)this_descr;
  
  /* All objects have a 'thisown' attribute */
  thisown_descr = PyDescr_NewGetSet(SwigPyObject_type(), &thisown_getset_def);
  (void)thisown_descr;
  
  public_interface = PyList_New(0);
  public_symbol = 0;
  (void)public_symbol;
  
  PyDict_SetItemString(md, "__all__", public_interface);
  Py_DECREF(public_interface);
  for (i = 0; SwigMethods[i].ml_name != NULL; ++i)
  SwigPyBuiltin_AddPublicSymbol(public_interface, SwigMethods[i].ml_name);
  for (i = 0; swig_const_table[i].name != 0; ++i)
  SwigPyBuiltin_AddPublicSymbol(public_interface, swig_const_table[i].name);
#endif
  
  SWIG_InstallConstants(d,swig_const_table);
  
  
  import_array();
  
  SWIG_Python_SetConstant(d, "SICONOS_CXXVERSION",SWIG_From_long((long)(201402L)));
  SWIG_Python_SetConstant(d, "ALLOC_CTRL_I",SWIG_From_int((int)(0x1)));
  SWIG_Python_SetConstant(d, "ALLOC_CTRL_P",SWIG_From_int((int)(0x2)));
  SWIG_Python_SetConstant(d, "SICONOS_NUMERICS_PROBLEM_LCP",SWIG_From_int((int)(SICONOS_NUMERICS_PROBLEM_LCP)));
  SWIG_Python_SetConstant(d, "SICONOS_NUMERICS_PROBLEM_MLCP",SWIG_From_int((int)(SICONOS_NUMERICS_PROBLEM_MLCP)));
  SWIG_Python_SetConstant(d, "SICONOS_NUMERICS_PROBLEM_EQUALITY",SWIG_From_int((int)(SICONOS_NUMERICS_PROBLEM_EQUALITY)));
  SWIG_Python_SetConstant(d, "SICONOS_NUMERICS_PROBLEM_FC2D",SWIG_From_int((int)(SICONOS_NUMERICS_PROBLEM_FC2D)));
  SWIG_Python_SetConstant(d, "SICONOS_NUMERICS_PROBLEM_FC3D",SWIG_From_int((int)(SICONOS_NUMERICS_PROBLEM_FC3D)));
  SWIG_Python_SetConstant(d, "SICONOS_NUMERICS_PROBLEM_NCP",SWIG_From_int((int)(SICONOS_NUMERICS_PROBLEM_NCP)));
  SWIG_Python_SetConstant(d, "SICONOS_NUMERICS_PROBLEM_MCP",SWIG_From_int((int)(SICONOS_NUMERICS_PROBLEM_MCP)));
  SWIG_Python_SetConstant(d, "SICONOS_NUMERICS_PROBLEM_VI",SWIG_From_int((int)(SICONOS_NUMERICS_PROBLEM_VI)));
  SWIG_Python_SetConstant(d, "SICONOS_NUMERICS_PROBLEM_AVI",SWIG_From_int((int)(SICONOS_NUMERICS_PROBLEM_AVI)));
  SWIG_Python_SetConstant(d, "SICONOS_NUMERICS_PROBLEM_RELAY",SWIG_From_int((int)(SICONOS_NUMERICS_PROBLEM_RELAY)));
  SWIG_Python_SetConstant(d, "SICONOS_IPARAM_MAX_ITER",SWIG_From_int((int)(SICONOS_IPARAM_MAX_ITER)));
  SWIG_Python_SetConstant(d, "SICONOS_IPARAM_ITER_DONE",SWIG_From_int((int)(SICONOS_IPARAM_ITER_DONE)));
  SWIG_Python_SetConstant(d, "SICONOS_IPARAM_PREALLOC",SWIG_From_int((int)(SICONOS_IPARAM_PREALLOC)));
  SWIG_Python_SetConstant(d, "SICONOS_IPARAM_PIVOT_RULE",SWIG_From_int((int)(3)));
  SWIG_Python_SetConstant(d, "SICONOS_IPARAM_PATHSEARCH_STACKSIZE",SWIG_From_int((int)(5)));
  SWIG_Python_SetConstant(d, "SICONOS_IPARAM_LSA_NONMONOTONE_LS",SWIG_From_int((int)(3)));
  SWIG_Python_SetConstant(d, "SICONOS_IPARAM_LSA_NONMONOTONE_LS_M",SWIG_From_int((int)(4)));
  SWIG_Python_SetConstant(d, "SICONOS_IPARAM_LSA_FORCE_ARCSEARCH",SWIG_From_int((int)(5)));
  SWIG_Python_SetConstant(d, "SICONOS_IPARAM_LSA_SEARCH_CRITERION",SWIG_From_int((int)(6)));
  SWIG_Python_SetConstant(d, "SICONOS_IPARAM_GOLDSTEIN_ITERMAX",SWIG_From_int((int)(4)));
  SWIG_Python_SetConstant(d, "SICONOS_IPARAM_NMS_WATCHDOG_TYPE",SWIG_From_int((int)(7)));
  SWIG_Python_SetConstant(d, "SICONOS_IPARAM_NMS_PROJECTED_GRADIENT_TYPE",SWIG_From_int((int)(8)));
  SWIG_Python_SetConstant(d, "SICONOS_IPARAM_NMS_N_MAX",SWIG_From_int((int)(9)));
  SWIG_Python_SetConstant(d, "SICONOS_DPARAM_TOL",SWIG_From_int((int)(SICONOS_DPARAM_TOL)));
  SWIG_Python_SetConstant(d, "SICONOS_DPARAM_RESIDU",SWIG_From_int((int)(SICONOS_DPARAM_RESIDU)));
  SWIG_Python_SetConstant(d, "SICONOS_DPARAM_LSA_ALPHA_MIN",SWIG_From_int((int)(2)));
  SWIG_Python_SetConstant(d, "SICONOS_DPARAM_GOLDSTEIN_C",SWIG_From_int((int)(3)));
  SWIG_Python_SetConstant(d, "SICONOS_DPARAM_GOLDSTEIN_ALPHAMAX",SWIG_From_int((int)(4)));
  SWIG_Python_SetConstant(d, "SICONOS_DPARAM_NMS_DELTA",SWIG_From_int((int)(2)));
  SWIG_Python_SetConstant(d, "SICONOS_DPARAM_NMS_DELTA_VAR",SWIG_From_int((int)(3)));
  SWIG_Python_SetConstant(d, "SICONOS_DPARAM_NMS_SIGMA",SWIG_From_int((int)(4)));
  SWIG_Python_SetConstant(d, "SICONOS_DPARAM_NMS_ALPHA_MIN_WATCHDOG",SWIG_From_int((int)(5)));
  SWIG_Python_SetConstant(d, "SICONOS_DPARAM_NMS_ALPHA_MIN_PGRAD",SWIG_From_int((int)(6)));
  SWIG_Python_SetConstant(d, "SICONOS_DPARAM_NMS_MERIT_INCR",SWIG_From_int((int)(7)));
  PyDict_SetItemString(md,(char *)"cvar", SWIG_globals());
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_NUMERICS_PROBLEM_LCP_STR",Swig_var_SICONOS_NUMERICS_PROBLEM_LCP_STR_get, Swig_var_SICONOS_NUMERICS_PROBLEM_LCP_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_NUMERICS_PROBLEM_MLCP_STR",Swig_var_SICONOS_NUMERICS_PROBLEM_MLCP_STR_get, Swig_var_SICONOS_NUMERICS_PROBLEM_MLCP_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_NUMERICS_PROBLEM_NCP_STR",Swig_var_SICONOS_NUMERICS_PROBLEM_NCP_STR_get, Swig_var_SICONOS_NUMERICS_PROBLEM_NCP_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_NUMERICS_PROBLEM_MCP_STR",Swig_var_SICONOS_NUMERICS_PROBLEM_MCP_STR_get, Swig_var_SICONOS_NUMERICS_PROBLEM_MCP_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_NUMERICS_PROBLEM_EQUALITY_STR",Swig_var_SICONOS_NUMERICS_PROBLEM_EQUALITY_STR_get, Swig_var_SICONOS_NUMERICS_PROBLEM_EQUALITY_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_NUMERICS_PROBLEM_FC2D_STR",Swig_var_SICONOS_NUMERICS_PROBLEM_FC2D_STR_get, Swig_var_SICONOS_NUMERICS_PROBLEM_FC2D_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_NUMERICS_PROBLEM_FC3D_STR",Swig_var_SICONOS_NUMERICS_PROBLEM_FC3D_STR_get, Swig_var_SICONOS_NUMERICS_PROBLEM_FC3D_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_NUMERICS_PROBLEM_VI_STR",Swig_var_SICONOS_NUMERICS_PROBLEM_VI_STR_get, Swig_var_SICONOS_NUMERICS_PROBLEM_VI_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_NUMERICS_PROBLEM_AVI_STR",Swig_var_SICONOS_NUMERICS_PROBLEM_AVI_STR_get, Swig_var_SICONOS_NUMERICS_PROBLEM_AVI_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_NUMERICS_PROBLEM_RELAY_STR",Swig_var_SICONOS_NUMERICS_PROBLEM_RELAY_STR_get, Swig_var_SICONOS_NUMERICS_PROBLEM_RELAY_STR_set);
  SWIG_Python_SetConstant(d, "NUMERICS_LOG_TO_SCREEN",SWIG_From_int((int)(NUMERICS_LOG_TO_SCREEN)));
  SWIG_Python_SetConstant(d, "NUMERICS_LOG_TO_FILE",SWIG_From_int((int)(NUMERICS_LOG_TO_FILE)));
  SWIG_Python_SetConstant(d, "NUMERICS_EXTERNAL_LOGGER",SWIG_From_int((int)(NUMERICS_EXTERNAL_LOGGER)));
  SWIG_addvarlink(SWIG_globals(),(char *)"verbose",Swig_var_verbose_get, Swig_var_verbose_set);
  SWIG_Python_SetConstant(d, "NUMERICS_SBM_FREE_BLOCK",SWIG_From_int((int)(4)));
  SWIG_Python_SetConstant(d, "NUMERICS_SBM_FREE_SBM",SWIG_From_int((int)(8)));
  SWIG_Python_SetConstant(d, "NM_DENSE",SWIG_From_int((int)(NM_DENSE)));
  SWIG_Python_SetConstant(d, "NM_SPARSE_BLOCK",SWIG_From_int((int)(NM_SPARSE_BLOCK)));
  SWIG_Python_SetConstant(d, "NM_SPARSE",SWIG_From_int((int)(NM_SPARSE)));
  SWIG_Python_SetConstant(d, "NM_NONE",SWIG_From_int((int)(NM_NONE)));
  SWIG_Python_SetConstant(d, "NM_KEEP_FACTORS",SWIG_From_int((int)(NM_KEEP_FACTORS)));
  SWIG_Python_SetConstant(d, "NM_PRESERVE",SWIG_From_int((int)(NM_PRESERVE)));
  SWIG_Python_SetConstant(d, "SN_LINALG_UNKNOWN",SWIG_From_int((int)(SN_LINALG_UNKNOWN)));
  SWIG_Python_SetConstant(d, "SN_LINALG_MKL",SWIG_From_int((int)(SN_LINALG_MKL)));
  SWIG_Python_SetConstant(d, "NSM_CS_LUSOL",SWIG_From_int((int)(NSM_CS_LUSOL)));
  SWIG_Python_SetConstant(d, "NSM_MUMPS",SWIG_From_int((int)(NSM_MUMPS)));
  SWIG_Python_SetConstant(d, "NSM_UMFPACK",SWIG_From_int((int)(NSM_UMFPACK)));
  SWIG_Python_SetConstant(d, "NSM_MKL_PARDISO",SWIG_From_int((int)(NSM_MKL_PARDISO)));
  SWIG_Python_SetConstant(d, "NSM_SUPERLU",SWIG_From_int((int)(NSM_SUPERLU)));
  SWIG_Python_SetConstant(d, "NSM_SUPERLU_MT",SWIG_From_int((int)(NSM_SUPERLU_MT)));
  SWIG_Python_SetConstant(d, "NSM_CS_CSC",SWIG_From_int((int)(NSM_CS_CSC)));
  SWIG_Python_SetConstant(d, "NSM_CS_CSR",SWIG_From_int((int)(NSM_CS_CSR)));
  SWIG_Python_SetConstant(d, "NSM_UNKNOWN",SWIG_From_int((int)(NSM_UNKNOWN)));
  SWIG_Python_SetConstant(d, "NSM_TRIPLET",SWIG_From_int((int)(NSM_TRIPLET)));
  SWIG_Python_SetConstant(d, "NSM_CSC",SWIG_From_int((int)(NSM_CSC)));
  SWIG_Python_SetConstant(d, "NSM_CSR",SWIG_From_int((int)(NSM_CSR)));
  SWIG_Python_SetConstant(d, "SICONOS_MLCP_PGS",SWIG_From_int((int)(SICONOS_MLCP_PGS)));
  SWIG_Python_SetConstant(d, "SICONOS_MLCP_RPGS",SWIG_From_int((int)(SICONOS_MLCP_RPGS)));
  SWIG_Python_SetConstant(d, "SICONOS_MLCP_PSOR",SWIG_From_int((int)(SICONOS_MLCP_PSOR)));
  SWIG_Python_SetConstant(d, "SICONOS_MLCP_RPSOR",SWIG_From_int((int)(SICONOS_MLCP_RPSOR)));
  SWIG_Python_SetConstant(d, "SICONOS_MLCP_PATH",SWIG_From_int((int)(SICONOS_MLCP_PATH)));
  SWIG_Python_SetConstant(d, "SICONOS_MLCP_ENUM",SWIG_From_int((int)(SICONOS_MLCP_ENUM)));
  SWIG_Python_SetConstant(d, "SICONOS_MLCP_SIMPLEX",SWIG_From_int((int)(SICONOS_MLCP_SIMPLEX)));
  SWIG_Python_SetConstant(d, "SICONOS_MLCP_DIRECT_ENUM",SWIG_From_int((int)(SICONOS_MLCP_DIRECT_ENUM)));
  SWIG_Python_SetConstant(d, "SICONOS_MLCP_PATH_ENUM",SWIG_From_int((int)(SICONOS_MLCP_PATH_ENUM)));
  SWIG_Python_SetConstant(d, "SICONOS_MLCP_DIRECT_SIMPLEX",SWIG_From_int((int)(SICONOS_MLCP_DIRECT_SIMPLEX)));
  SWIG_Python_SetConstant(d, "SICONOS_MLCP_DIRECT_PATH",SWIG_From_int((int)(SICONOS_MLCP_DIRECT_PATH)));
  SWIG_Python_SetConstant(d, "SICONOS_MLCP_DIRECT_PATH_ENUM",SWIG_From_int((int)(SICONOS_MLCP_DIRECT_PATH_ENUM)));
  SWIG_Python_SetConstant(d, "SICONOS_MLCP_FB",SWIG_From_int((int)(SICONOS_MLCP_FB)));
  SWIG_Python_SetConstant(d, "SICONOS_MLCP_DIRECT_FB",SWIG_From_int((int)(SICONOS_MLCP_DIRECT_FB)));
  SWIG_Python_SetConstant(d, "SICONOS_MLCP_PGS_SBM",SWIG_From_int((int)(SICONOS_MLCP_PGS_SBM)));
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_NONAME_STR",Swig_var_SICONOS_NONAME_STR_get, Swig_var_SICONOS_NONAME_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_MLCP_PGS_STR",Swig_var_SICONOS_MLCP_PGS_STR_get, Swig_var_SICONOS_MLCP_PGS_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_MLCP_RPGS_STR",Swig_var_SICONOS_MLCP_RPGS_STR_get, Swig_var_SICONOS_MLCP_RPGS_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_MLCP_PSOR_STR",Swig_var_SICONOS_MLCP_PSOR_STR_get, Swig_var_SICONOS_MLCP_PSOR_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_MLCP_RPSOR_STR",Swig_var_SICONOS_MLCP_RPSOR_STR_get, Swig_var_SICONOS_MLCP_RPSOR_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_MLCP_PATH_STR",Swig_var_SICONOS_MLCP_PATH_STR_get, Swig_var_SICONOS_MLCP_PATH_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_MLCP_ENUM_STR",Swig_var_SICONOS_MLCP_ENUM_STR_get, Swig_var_SICONOS_MLCP_ENUM_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_MLCP_SIMPLEX_STR",Swig_var_SICONOS_MLCP_SIMPLEX_STR_get, Swig_var_SICONOS_MLCP_SIMPLEX_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_MLCP_DIRECT_ENUM_STR",Swig_var_SICONOS_MLCP_DIRECT_ENUM_STR_get, Swig_var_SICONOS_MLCP_DIRECT_ENUM_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_MLCP_PATH_ENUM_STR",Swig_var_SICONOS_MLCP_PATH_ENUM_STR_get, Swig_var_SICONOS_MLCP_PATH_ENUM_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_MLCP_DIRECT_SIMPLEX_STR",Swig_var_SICONOS_MLCP_DIRECT_SIMPLEX_STR_get, Swig_var_SICONOS_MLCP_DIRECT_SIMPLEX_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_MLCP_DIRECT_PATH_STR",Swig_var_SICONOS_MLCP_DIRECT_PATH_STR_get, Swig_var_SICONOS_MLCP_DIRECT_PATH_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_MLCP_DIRECT_PATH_ENUM_STR",Swig_var_SICONOS_MLCP_DIRECT_PATH_ENUM_STR_get, Swig_var_SICONOS_MLCP_DIRECT_PATH_ENUM_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_MLCP_FB_STR",Swig_var_SICONOS_MLCP_FB_STR_get, Swig_var_SICONOS_MLCP_FB_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_MLCP_DIRECT_FB_STR",Swig_var_SICONOS_MLCP_DIRECT_FB_STR_get, Swig_var_SICONOS_MLCP_DIRECT_FB_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_MLCP_PGS_SBM_STR",Swig_var_SICONOS_MLCP_PGS_SBM_STR_get, Swig_var_SICONOS_MLCP_PGS_SBM_STR_set);
  SWIG_Python_SetConstant(d, "SICONOS_LCP_LEMKE",SWIG_From_int((int)(SICONOS_LCP_LEMKE)));
  SWIG_Python_SetConstant(d, "SICONOS_LCP_NSGS_SBM",SWIG_From_int((int)(SICONOS_LCP_NSGS_SBM)));
  SWIG_Python_SetConstant(d, "SICONOS_LCP_PGS",SWIG_From_int((int)(SICONOS_LCP_PGS)));
  SWIG_Python_SetConstant(d, "SICONOS_LCP_CPG",SWIG_From_int((int)(SICONOS_LCP_CPG)));
  SWIG_Python_SetConstant(d, "SICONOS_LCP_LATIN",SWIG_From_int((int)(SICONOS_LCP_LATIN)));
  SWIG_Python_SetConstant(d, "SICONOS_LCP_LATIN_W",SWIG_From_int((int)(SICONOS_LCP_LATIN_W)));
  SWIG_Python_SetConstant(d, "SICONOS_LCP_QP",SWIG_From_int((int)(SICONOS_LCP_QP)));
  SWIG_Python_SetConstant(d, "SICONOS_LCP_NSQP",SWIG_From_int((int)(SICONOS_LCP_NSQP)));
  SWIG_Python_SetConstant(d, "SICONOS_LCP_NEWTONMIN",SWIG_From_int((int)(SICONOS_LCP_NEWTONMIN)));
  SWIG_Python_SetConstant(d, "SICONOS_LCP_NEWTON_FBLSA",SWIG_From_int((int)(SICONOS_LCP_NEWTON_FBLSA)));
  SWIG_Python_SetConstant(d, "SICONOS_LCP_PSOR",SWIG_From_int((int)(SICONOS_LCP_PSOR)));
  SWIG_Python_SetConstant(d, "SICONOS_LCP_RPGS",SWIG_From_int((int)(SICONOS_LCP_RPGS)));
  SWIG_Python_SetConstant(d, "SICONOS_LCP_PATH",SWIG_From_int((int)(SICONOS_LCP_PATH)));
  SWIG_Python_SetConstant(d, "SICONOS_LCP_ENUM",SWIG_From_int((int)(SICONOS_LCP_ENUM)));
  SWIG_Python_SetConstant(d, "SICONOS_LCP_AVI_CAOFERRIS",SWIG_From_int((int)(SICONOS_LCP_AVI_CAOFERRIS)));
  SWIG_Python_SetConstant(d, "SICONOS_LCP_PIVOT",SWIG_From_int((int)(SICONOS_LCP_PIVOT)));
  SWIG_Python_SetConstant(d, "SICONOS_LCP_BARD",SWIG_From_int((int)(SICONOS_LCP_BARD)));
  SWIG_Python_SetConstant(d, "SICONOS_LCP_MURTY",SWIG_From_int((int)(SICONOS_LCP_MURTY)));
  SWIG_Python_SetConstant(d, "SICONOS_LCP_NEWTON_MINFBLSA",SWIG_From_int((int)(SICONOS_LCP_NEWTON_MINFBLSA)));
  SWIG_Python_SetConstant(d, "SICONOS_LCP_PATHSEARCH",SWIG_From_int((int)(SICONOS_LCP_PATHSEARCH)));
  SWIG_Python_SetConstant(d, "SICONOS_LCP_PIVOT_LUMOD",SWIG_From_int((int)(SICONOS_LCP_PIVOT_LUMOD)));
  SWIG_Python_SetConstant(d, "SICONOS_LCP_GAMS",SWIG_From_int((int)(SICONOS_LCP_GAMS)));
  SWIG_Python_SetConstant(d, "SICONOS_LCP_CONVEXQP_PG",SWIG_From_int((int)(SICONOS_LCP_CONVEXQP_PG)));
  SWIG_Python_SetConstant(d, "SICONOS_LCP_PIVOT_BARD",SWIG_From_int((int)(SICONOS_LCP_PIVOT_BARD)));
  SWIG_Python_SetConstant(d, "SICONOS_LCP_PIVOT_LEAST_INDEX",SWIG_From_int((int)(SICONOS_LCP_PIVOT_LEAST_INDEX)));
  SWIG_Python_SetConstant(d, "SICONOS_LCP_PIVOT_LEMKE",SWIG_From_int((int)(SICONOS_LCP_PIVOT_LEMKE)));
  SWIG_Python_SetConstant(d, "SICONOS_LCP_PIVOT_PATHSEARCH",SWIG_From_int((int)(SICONOS_LCP_PIVOT_PATHSEARCH)));
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_LCP_LEMKE_STR",Swig_var_SICONOS_LCP_LEMKE_STR_get, Swig_var_SICONOS_LCP_LEMKE_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_LCP_NSGS_SBM_STR",Swig_var_SICONOS_LCP_NSGS_SBM_STR_get, Swig_var_SICONOS_LCP_NSGS_SBM_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_LCP_PGS_STR",Swig_var_SICONOS_LCP_PGS_STR_get, Swig_var_SICONOS_LCP_PGS_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_LCP_CPG_STR",Swig_var_SICONOS_LCP_CPG_STR_get, Swig_var_SICONOS_LCP_CPG_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_LCP_LATIN_STR",Swig_var_SICONOS_LCP_LATIN_STR_get, Swig_var_SICONOS_LCP_LATIN_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_LCP_LATIN_W_STR",Swig_var_SICONOS_LCP_LATIN_W_STR_get, Swig_var_SICONOS_LCP_LATIN_W_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_LCP_QP_STR",Swig_var_SICONOS_LCP_QP_STR_get, Swig_var_SICONOS_LCP_QP_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_LCP_NSQP_STR",Swig_var_SICONOS_LCP_NSQP_STR_get, Swig_var_SICONOS_LCP_NSQP_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_LCP_NEWTONMIN_STR",Swig_var_SICONOS_LCP_NEWTONMIN_STR_get, Swig_var_SICONOS_LCP_NEWTONMIN_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_LCP_NEWTON_FBLSA_STR",Swig_var_SICONOS_LCP_NEWTON_FBLSA_STR_get, Swig_var_SICONOS_LCP_NEWTON_FBLSA_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_LCP_NEWTON_MINFBLSA_STR",Swig_var_SICONOS_LCP_NEWTON_MINFBLSA_STR_get, Swig_var_SICONOS_LCP_NEWTON_MINFBLSA_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_LCP_PSOR_STR",Swig_var_SICONOS_LCP_PSOR_STR_get, Swig_var_SICONOS_LCP_PSOR_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_LCP_RPGS_STR",Swig_var_SICONOS_LCP_RPGS_STR_get, Swig_var_SICONOS_LCP_RPGS_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_LCP_PATH_STR",Swig_var_SICONOS_LCP_PATH_STR_get, Swig_var_SICONOS_LCP_PATH_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_LCP_ENUM_STR",Swig_var_SICONOS_LCP_ENUM_STR_get, Swig_var_SICONOS_LCP_ENUM_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_LCP_AVI_CAOFERRIS_STR",Swig_var_SICONOS_LCP_AVI_CAOFERRIS_STR_get, Swig_var_SICONOS_LCP_AVI_CAOFERRIS_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_LCP_PIVOT_STR",Swig_var_SICONOS_LCP_PIVOT_STR_get, Swig_var_SICONOS_LCP_PIVOT_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_LCP_BARD_STR",Swig_var_SICONOS_LCP_BARD_STR_get, Swig_var_SICONOS_LCP_BARD_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_LCP_MURTY_STR",Swig_var_SICONOS_LCP_MURTY_STR_get, Swig_var_SICONOS_LCP_MURTY_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_LCP_PATHSEARCH_STR",Swig_var_SICONOS_LCP_PATHSEARCH_STR_get, Swig_var_SICONOS_LCP_PATHSEARCH_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_LCP_PIVOT_LUMOD_STR",Swig_var_SICONOS_LCP_PIVOT_LUMOD_STR_get, Swig_var_SICONOS_LCP_PIVOT_LUMOD_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_LCP_GAMS_STR",Swig_var_SICONOS_LCP_GAMS_STR_get, Swig_var_SICONOS_LCP_GAMS_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_LCP_CONVEXQP_PG_STR",Swig_var_SICONOS_LCP_CONVEXQP_PG_STR_get, Swig_var_SICONOS_LCP_CONVEXQP_PG_STR_set);
  SWIG_Python_SetConstant(d, "SICONOS_AVI_CAOFERRIS",SWIG_From_int((int)(SICONOS_AVI_CAOFERRIS)));
  SWIG_Python_SetConstant(d, "SICONOS_AVI_PATHAVI",SWIG_From_int((int)(SICONOS_AVI_PATHAVI)));
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_AVI_CAOFERRIS_STR",Swig_var_SICONOS_AVI_CAOFERRIS_STR_get, Swig_var_SICONOS_AVI_CAOFERRIS_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_AVI_PATHAVI_STR",Swig_var_SICONOS_AVI_PATHAVI_STR_get, Swig_var_SICONOS_AVI_PATHAVI_STR_set);
  SWIG_Python_SetConstant(d, "SICONOS_RELAY_PGS",SWIG_From_int((int)(SICONOS_RELAY_PGS)));
  SWIG_Python_SetConstant(d, "SICONOS_RELAY_ENUM",SWIG_From_int((int)(SICONOS_RELAY_ENUM)));
  SWIG_Python_SetConstant(d, "SICONOS_RELAY_PATH",SWIG_From_int((int)(SICONOS_RELAY_PATH)));
  SWIG_Python_SetConstant(d, "SICONOS_RELAY_LEMKE",SWIG_From_int((int)(SICONOS_RELAY_LEMKE)));
  SWIG_Python_SetConstant(d, "SICONOS_RELAY_LATIN",SWIG_From_int((int)(SICONOS_RELAY_LATIN)));
  SWIG_Python_SetConstant(d, "SICONOS_RELAY_NLGS",SWIG_From_int((int)(SICONOS_RELAY_NLGS)));
  SWIG_Python_SetConstant(d, "SICONOS_RELAY_AVI_CAOFERRIS",SWIG_From_int((int)(SICONOS_RELAY_AVI_CAOFERRIS)));
  SWIG_Python_SetConstant(d, "SICONOS_RELAY_AVI_CAOFERRIS_TEST",SWIG_From_int((int)(SICONOS_RELAY_AVI_CAOFERRIS_TEST)));
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_RELAY_PGS_STR",Swig_var_SICONOS_RELAY_PGS_STR_get, Swig_var_SICONOS_RELAY_PGS_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_RELAY_PATH_STR",Swig_var_SICONOS_RELAY_PATH_STR_get, Swig_var_SICONOS_RELAY_PATH_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_RELAY_ENUM_STR",Swig_var_SICONOS_RELAY_ENUM_STR_get, Swig_var_SICONOS_RELAY_ENUM_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_RELAY_NLGS_STR",Swig_var_SICONOS_RELAY_NLGS_STR_get, Swig_var_SICONOS_RELAY_NLGS_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_RELAY_LEMKE_STR",Swig_var_SICONOS_RELAY_LEMKE_STR_get, Swig_var_SICONOS_RELAY_LEMKE_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_RELAY_LATIN_STR",Swig_var_SICONOS_RELAY_LATIN_STR_get, Swig_var_SICONOS_RELAY_LATIN_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_RELAY_AVI_CAOFERRIS_STR",Swig_var_SICONOS_RELAY_AVI_CAOFERRIS_STR_get, Swig_var_SICONOS_RELAY_AVI_CAOFERRIS_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_RELAY_AVI_CAOFERRIS_TEST_STR",Swig_var_SICONOS_RELAY_AVI_CAOFERRIS_TEST_STR_get, Swig_var_SICONOS_RELAY_AVI_CAOFERRIS_TEST_STR_set);
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_2D_NSGS",SWIG_From_int((int)(SICONOS_FRICTION_2D_NSGS)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_2D_PGS",SWIG_From_int((int)(SICONOS_FRICTION_2D_PGS)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_2D_CPG",SWIG_From_int((int)(SICONOS_FRICTION_2D_CPG)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_2D_LATIN",SWIG_From_int((int)(SICONOS_FRICTION_2D_LATIN)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_2D_LEMKE",SWIG_From_int((int)(SICONOS_FRICTION_2D_LEMKE)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_2D_ENUM",SWIG_From_int((int)(SICONOS_FRICTION_2D_ENUM)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSGS",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSGS)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSGSV",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSGSV)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_PROX",SWIG_From_int((int)(SICONOS_FRICTION_3D_PROX)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_TFP",SWIG_From_int((int)(SICONOS_FRICTION_3D_TFP)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSN_AC",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSN_AC)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_DSFP",SWIG_From_int((int)(SICONOS_FRICTION_3D_DSFP)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_VI_FPP",SWIG_From_int((int)(SICONOS_FRICTION_3D_VI_FPP)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_VI_EG",SWIG_From_int((int)(SICONOS_FRICTION_3D_VI_EG)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_HP",SWIG_From_int((int)(SICONOS_FRICTION_3D_HP)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NCPGlockerFBFixedPoint",SWIG_From_int((int)(SICONOS_FRICTION_3D_NCPGlockerFBFixedPoint)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_FPP",SWIG_From_int((int)(SICONOS_FRICTION_3D_FPP)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_EG",SWIG_From_int((int)(SICONOS_FRICTION_3D_EG)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSN_FB",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSN_FB)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_GAMS_PATH",SWIG_From_int((int)(SICONOS_FRICTION_3D_GAMS_PATH)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_GAMS_PATHVI",SWIG_From_int((int)(SICONOS_FRICTION_3D_GAMS_PATHVI)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_ACLMFP",SWIG_From_int((int)(SICONOS_FRICTION_3D_ACLMFP)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_SOCLCP",SWIG_From_int((int)(SICONOS_FRICTION_3D_SOCLCP)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_GAMS_LCP_PATH",SWIG_From_int((int)(SICONOS_FRICTION_3D_GAMS_LCP_PATH)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_GAMS_LCP_PATHVI",SWIG_From_int((int)(SICONOS_FRICTION_3D_GAMS_LCP_PATHVI)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSN_NM",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSN_NM)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSN_AC_TEST",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSN_AC_TEST)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_PFP",SWIG_From_int((int)(SICONOS_FRICTION_3D_PFP)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_ADMM",SWIG_From_int((int)(SICONOS_FRICTION_3D_ADMM)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_ONECONTACT_NSN",SWIG_From_int((int)(SICONOS_FRICTION_3D_ONECONTACT_NSN)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_ONECONTACT_NSN_GP",SWIG_From_int((int)(SICONOS_FRICTION_3D_ONECONTACT_NSN_GP)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnCone",SWIG_From_int((int)(SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnCone)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnConeWithLocalIteration",SWIG_From_int((int)(SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnConeWithLocalIteration)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnConeWithRegularization",SWIG_From_int((int)(SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnConeWithRegularization)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnConeWithDiagonalization",SWIG_From_int((int)(SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnConeWithDiagonalization)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnCone_velocity",SWIG_From_int((int)(SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnCone_velocity)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_DeSaxceFixedPoint",SWIG_From_int((int)(SICONOS_FRICTION_3D_DeSaxceFixedPoint)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NCPGlockerFBPATH",SWIG_From_int((int)(SICONOS_FRICTION_3D_NCPGlockerFBPATH)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NCPGlockerFBNewton",SWIG_From_int((int)(SICONOS_FRICTION_3D_NCPGlockerFBNewton)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_ONECONTACT_QUARTIC",SWIG_From_int((int)(SICONOS_FRICTION_3D_ONECONTACT_QUARTIC)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_ONECONTACT_QUARTIC_NU",SWIG_From_int((int)(SICONOS_FRICTION_3D_ONECONTACT_QUARTIC_NU)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnCylinder",SWIG_From_int((int)(SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnCylinder)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnCylinderWithLocalIteration",SWIG_From_int((int)(SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnCylinderWithLocalIteration)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_ONECONTACT_NSN_GP_HYBRID",SWIG_From_int((int)(SICONOS_FRICTION_3D_ONECONTACT_NSN_GP_HYBRID)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_VI_FPP_Cylinder",SWIG_From_int((int)(SICONOS_FRICTION_3D_VI_FPP_Cylinder)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_ConvexQP_PG_Cylinder",SWIG_From_int((int)(SICONOS_FRICTION_3D_ConvexQP_PG_Cylinder)));
  SWIG_Python_SetConstant(d, "SICONOS_GLOBAL_FRICTION_3D_NSGS_WR",SWIG_From_int((int)(SICONOS_GLOBAL_FRICTION_3D_NSGS_WR)));
  SWIG_Python_SetConstant(d, "SICONOS_GLOBAL_FRICTION_3D_NSGSV_WR",SWIG_From_int((int)(SICONOS_GLOBAL_FRICTION_3D_NSGSV_WR)));
  SWIG_Python_SetConstant(d, "SICONOS_GLOBAL_FRICTION_3D_PROX_WR",SWIG_From_int((int)(SICONOS_GLOBAL_FRICTION_3D_PROX_WR)));
  SWIG_Python_SetConstant(d, "SICONOS_GLOBAL_FRICTION_3D_DSFP_WR",SWIG_From_int((int)(SICONOS_GLOBAL_FRICTION_3D_DSFP_WR)));
  SWIG_Python_SetConstant(d, "SICONOS_GLOBAL_FRICTION_3D_TFP_WR",SWIG_From_int((int)(SICONOS_GLOBAL_FRICTION_3D_TFP_WR)));
  SWIG_Python_SetConstant(d, "SICONOS_GLOBAL_FRICTION_3D_NSGS",SWIG_From_int((int)(SICONOS_GLOBAL_FRICTION_3D_NSGS)));
  SWIG_Python_SetConstant(d, "SICONOS_GLOBAL_FRICTION_3D_NSN_AC_WR",SWIG_From_int((int)(SICONOS_GLOBAL_FRICTION_3D_NSN_AC_WR)));
  SWIG_Python_SetConstant(d, "SICONOS_GLOBAL_FRICTION_3D_NSN_AC",SWIG_From_int((int)(SICONOS_GLOBAL_FRICTION_3D_NSN_AC)));
  SWIG_Python_SetConstant(d, "SICONOS_GLOBAL_FRICTION_3D_GAMS_PATH",SWIG_From_int((int)(SICONOS_GLOBAL_FRICTION_3D_GAMS_PATH)));
  SWIG_Python_SetConstant(d, "SICONOS_GLOBAL_FRICTION_3D_GAMS_PATHVI",SWIG_From_int((int)(SICONOS_GLOBAL_FRICTION_3D_GAMS_PATHVI)));
  SWIG_Python_SetConstant(d, "SICONOS_GLOBAL_FRICTION_3D_VI_FPP",SWIG_From_int((int)(SICONOS_GLOBAL_FRICTION_3D_VI_FPP)));
  SWIG_Python_SetConstant(d, "SICONOS_GLOBAL_FRICTION_3D_VI_EG",SWIG_From_int((int)(SICONOS_GLOBAL_FRICTION_3D_VI_EG)));
  SWIG_Python_SetConstant(d, "SICONOS_GLOBAL_FRICTION_3D_ACLMFP",SWIG_From_int((int)(SICONOS_GLOBAL_FRICTION_3D_ACLMFP)));
  SWIG_Python_SetConstant(d, "SICONOS_GLOBAL_FRICTION_3D_ADMM",SWIG_From_int((int)(SICONOS_GLOBAL_FRICTION_3D_ADMM)));
  SWIG_Python_SetConstant(d, "SICONOS_GLOBAL_FRICTION_3D_ADMM_WR",SWIG_From_int((int)(SICONOS_GLOBAL_FRICTION_3D_ADMM_WR)));
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_2D_NSGS_STR",Swig_var_SICONOS_FRICTION_2D_NSGS_STR_get, Swig_var_SICONOS_FRICTION_2D_NSGS_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_2D_PGS_STR",Swig_var_SICONOS_FRICTION_2D_PGS_STR_get, Swig_var_SICONOS_FRICTION_2D_PGS_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_2D_CPG_STR",Swig_var_SICONOS_FRICTION_2D_CPG_STR_get, Swig_var_SICONOS_FRICTION_2D_CPG_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_2D_LATIN_STR",Swig_var_SICONOS_FRICTION_2D_LATIN_STR_get, Swig_var_SICONOS_FRICTION_2D_LATIN_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_2D_LEMKE_STR",Swig_var_SICONOS_FRICTION_2D_LEMKE_STR_get, Swig_var_SICONOS_FRICTION_2D_LEMKE_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_2D_ENUM_STR",Swig_var_SICONOS_FRICTION_2D_ENUM_STR_get, Swig_var_SICONOS_FRICTION_2D_ENUM_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_3D_NSGS_STR",Swig_var_SICONOS_FRICTION_3D_NSGS_STR_get, Swig_var_SICONOS_FRICTION_3D_NSGS_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_3D_NSGSV_STR",Swig_var_SICONOS_FRICTION_3D_NSGSV_STR_get, Swig_var_SICONOS_FRICTION_3D_NSGSV_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_3D_PROX_STR",Swig_var_SICONOS_FRICTION_3D_PROX_STR_get, Swig_var_SICONOS_FRICTION_3D_PROX_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_3D_TFP_STR",Swig_var_SICONOS_FRICTION_3D_TFP_STR_get, Swig_var_SICONOS_FRICTION_3D_TFP_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_3D_PFP_STR",Swig_var_SICONOS_FRICTION_3D_PFP_STR_get, Swig_var_SICONOS_FRICTION_3D_PFP_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_3D_NSN_AC_STR",Swig_var_SICONOS_FRICTION_3D_NSN_AC_STR_get, Swig_var_SICONOS_FRICTION_3D_NSN_AC_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_3D_NSN_AC_TEST_STR",Swig_var_SICONOS_FRICTION_3D_NSN_AC_TEST_STR_get, Swig_var_SICONOS_FRICTION_3D_NSN_AC_TEST_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_3D_NSN_FB_STR",Swig_var_SICONOS_FRICTION_3D_NSN_FB_STR_get, Swig_var_SICONOS_FRICTION_3D_NSN_FB_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_3D_NSN_NM_STR",Swig_var_SICONOS_FRICTION_3D_NSN_NM_STR_get, Swig_var_SICONOS_FRICTION_3D_NSN_NM_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_3D_DSFP_STR",Swig_var_SICONOS_FRICTION_3D_DSFP_STR_get, Swig_var_SICONOS_FRICTION_3D_DSFP_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_3D_VI_EG_STR",Swig_var_SICONOS_FRICTION_3D_VI_EG_STR_get, Swig_var_SICONOS_FRICTION_3D_VI_EG_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_3D_VI_FPP_STR",Swig_var_SICONOS_FRICTION_3D_VI_FPP_STR_get, Swig_var_SICONOS_FRICTION_3D_VI_FPP_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_3D_EG_STR",Swig_var_SICONOS_FRICTION_3D_EG_STR_get, Swig_var_SICONOS_FRICTION_3D_EG_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_3D_FPP_STR",Swig_var_SICONOS_FRICTION_3D_FPP_STR_get, Swig_var_SICONOS_FRICTION_3D_FPP_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_3D_HP_STR",Swig_var_SICONOS_FRICTION_3D_HP_STR_get, Swig_var_SICONOS_FRICTION_3D_HP_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_3D_NCPGlockerFBFixedPoint_STR",Swig_var_SICONOS_FRICTION_3D_NCPGlockerFBFixedPoint_STR_get, Swig_var_SICONOS_FRICTION_3D_NCPGlockerFBFixedPoint_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_3D_ONECONTACT_NSN_STR",Swig_var_SICONOS_FRICTION_3D_ONECONTACT_NSN_STR_get, Swig_var_SICONOS_FRICTION_3D_ONECONTACT_NSN_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_3D_ONECONTACT_NSN_GP_STR",Swig_var_SICONOS_FRICTION_3D_ONECONTACT_NSN_GP_STR_get, Swig_var_SICONOS_FRICTION_3D_ONECONTACT_NSN_GP_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_3D_ONECONTACT_NSN_GP_HYBRID_STR",Swig_var_SICONOS_FRICTION_3D_ONECONTACT_NSN_GP_HYBRID_STR_get, Swig_var_SICONOS_FRICTION_3D_ONECONTACT_NSN_GP_HYBRID_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_3D_NCPGlockerFBNewton_STR",Swig_var_SICONOS_FRICTION_3D_NCPGlockerFBNewton_STR_get, Swig_var_SICONOS_FRICTION_3D_NCPGlockerFBNewton_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnConeWithDiagonalization_STR",Swig_var_SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnConeWithDiagonalization_STR_get, Swig_var_SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnConeWithDiagonalization_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnCone_STR",Swig_var_SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnCone_STR_get, Swig_var_SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnCone_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnConeWithLocalIteration_STR",Swig_var_SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnConeWithLocalIteration_STR_get, Swig_var_SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnConeWithLocalIteration_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnConeWithRegularization_STR",Swig_var_SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnConeWithRegularization_STR_get, Swig_var_SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnConeWithRegularization_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_3D_NCPGlockerFBPATH_STR",Swig_var_SICONOS_FRICTION_3D_NCPGlockerFBPATH_STR_get, Swig_var_SICONOS_FRICTION_3D_NCPGlockerFBPATH_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnCylinder_STR",Swig_var_SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnCylinder_STR_get, Swig_var_SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnCylinder_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnCone_velocity_STR",Swig_var_SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnCone_velocity_STR_get, Swig_var_SICONOS_FRICTION_3D_ONECONTACT_ProjectionOnCone_velocity_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_3D_ConvexQP_PG_Cylinder_STR",Swig_var_SICONOS_FRICTION_3D_ConvexQP_PG_Cylinder_STR_get, Swig_var_SICONOS_FRICTION_3D_ConvexQP_PG_Cylinder_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_3D_VI_FPP_Cylinder_STR",Swig_var_SICONOS_FRICTION_3D_VI_FPP_Cylinder_STR_get, Swig_var_SICONOS_FRICTION_3D_VI_FPP_Cylinder_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_3D_DeSaxceFixedPoint_STR",Swig_var_SICONOS_FRICTION_3D_DeSaxceFixedPoint_STR_get, Swig_var_SICONOS_FRICTION_3D_DeSaxceFixedPoint_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_3D_GAMS_PATH_STR",Swig_var_SICONOS_FRICTION_3D_GAMS_PATH_STR_get, Swig_var_SICONOS_FRICTION_3D_GAMS_PATH_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_3D_GAMS_PATHVI_STR",Swig_var_SICONOS_FRICTION_3D_GAMS_PATHVI_STR_get, Swig_var_SICONOS_FRICTION_3D_GAMS_PATHVI_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_3D_GAMS_LCP_PATH_STR",Swig_var_SICONOS_FRICTION_3D_GAMS_LCP_PATH_STR_get, Swig_var_SICONOS_FRICTION_3D_GAMS_LCP_PATH_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_3D_GAMS_LCP_PATHVI_STR",Swig_var_SICONOS_FRICTION_3D_GAMS_LCP_PATHVI_STR_get, Swig_var_SICONOS_FRICTION_3D_GAMS_LCP_PATHVI_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_3D_SOCLCP_STR",Swig_var_SICONOS_FRICTION_3D_SOCLCP_STR_get, Swig_var_SICONOS_FRICTION_3D_SOCLCP_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_3D_ACLMFP_STR",Swig_var_SICONOS_FRICTION_3D_ACLMFP_STR_get, Swig_var_SICONOS_FRICTION_3D_ACLMFP_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_3D_ADMM_STR",Swig_var_SICONOS_FRICTION_3D_ADMM_STR_get, Swig_var_SICONOS_FRICTION_3D_ADMM_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_GLOBAL_FRICTION_3D_NSGS_WR_STR",Swig_var_SICONOS_GLOBAL_FRICTION_3D_NSGS_WR_STR_get, Swig_var_SICONOS_GLOBAL_FRICTION_3D_NSGS_WR_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_GLOBAL_FRICTION_3D_NSGSV_WR_STR",Swig_var_SICONOS_GLOBAL_FRICTION_3D_NSGSV_WR_STR_get, Swig_var_SICONOS_GLOBAL_FRICTION_3D_NSGSV_WR_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_GLOBAL_FRICTION_3D_PROX_WR_STR",Swig_var_SICONOS_GLOBAL_FRICTION_3D_PROX_WR_STR_get, Swig_var_SICONOS_GLOBAL_FRICTION_3D_PROX_WR_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_GLOBAL_FRICTION_3D_DSFP_WR_STR",Swig_var_SICONOS_GLOBAL_FRICTION_3D_DSFP_WR_STR_get, Swig_var_SICONOS_GLOBAL_FRICTION_3D_DSFP_WR_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_GLOBAL_FRICTION_3D_TFP_WR_STR",Swig_var_SICONOS_GLOBAL_FRICTION_3D_TFP_WR_STR_get, Swig_var_SICONOS_GLOBAL_FRICTION_3D_TFP_WR_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_GLOBAL_FRICTION_3D_NSGS_STR",Swig_var_SICONOS_GLOBAL_FRICTION_3D_NSGS_STR_get, Swig_var_SICONOS_GLOBAL_FRICTION_3D_NSGS_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_GLOBAL_FRICTION_3D_NSN_AC_WR_STR",Swig_var_SICONOS_GLOBAL_FRICTION_3D_NSN_AC_WR_STR_get, Swig_var_SICONOS_GLOBAL_FRICTION_3D_NSN_AC_WR_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_GLOBAL_FRICTION_3D_NSN_AC_STR",Swig_var_SICONOS_GLOBAL_FRICTION_3D_NSN_AC_STR_get, Swig_var_SICONOS_GLOBAL_FRICTION_3D_NSN_AC_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_GLOBAL_FRICTION_3D_GAMS_PATH_STR",Swig_var_SICONOS_GLOBAL_FRICTION_3D_GAMS_PATH_STR_get, Swig_var_SICONOS_GLOBAL_FRICTION_3D_GAMS_PATH_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_GLOBAL_FRICTION_3D_GAMS_PATHVI_STR",Swig_var_SICONOS_GLOBAL_FRICTION_3D_GAMS_PATHVI_STR_get, Swig_var_SICONOS_GLOBAL_FRICTION_3D_GAMS_PATHVI_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_GLOBAL_FRICTION_3D_VI_FPP_STR",Swig_var_SICONOS_GLOBAL_FRICTION_3D_VI_FPP_STR_get, Swig_var_SICONOS_GLOBAL_FRICTION_3D_VI_FPP_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_GLOBAL_FRICTION_3D_VI_EG_STR",Swig_var_SICONOS_GLOBAL_FRICTION_3D_VI_EG_STR_get, Swig_var_SICONOS_GLOBAL_FRICTION_3D_VI_EG_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_GLOBAL_FRICTION_3D_ACLMFP_STR",Swig_var_SICONOS_GLOBAL_FRICTION_3D_ACLMFP_STR_get, Swig_var_SICONOS_GLOBAL_FRICTION_3D_ACLMFP_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_GLOBAL_FRICTION_3D_ADMM_STR",Swig_var_SICONOS_GLOBAL_FRICTION_3D_ADMM_STR_get, Swig_var_SICONOS_GLOBAL_FRICTION_3D_ADMM_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_GLOBAL_FRICTION_3D_ADMM_WR_STR",Swig_var_SICONOS_GLOBAL_FRICTION_3D_ADMM_WR_STR_get, Swig_var_SICONOS_GLOBAL_FRICTION_3D_ADMM_WR_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_3D_ONECONTACT_QUARTIC_STR",Swig_var_SICONOS_FRICTION_3D_ONECONTACT_QUARTIC_STR_get, Swig_var_SICONOS_FRICTION_3D_ONECONTACT_QUARTIC_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_FRICTION_3D_ONECONTACT_QUARTIC_NU_STR",Swig_var_SICONOS_FRICTION_3D_ONECONTACT_QUARTIC_NU_STR_get, Swig_var_SICONOS_FRICTION_3D_ONECONTACT_QUARTIC_NU_STR_set);
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_IPARAM_INTERNAL_ERROR_STRATEGY",SWIG_From_int((int)(SICONOS_FRICTION_3D_IPARAM_INTERNAL_ERROR_STRATEGY)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_IPARAM_ERROR_EVALUATION",SWIG_From_int((int)(SICONOS_FRICTION_3D_IPARAM_ERROR_EVALUATION)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_IPARAM_ERROR_EVALUATION_FREQUENCY",SWIG_From_int((int)(SICONOS_FRICTION_3D_IPARAM_ERROR_EVALUATION_FREQUENCY)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_INTERNAL_ERROR_STRATEGY_ADAPTIVE",SWIG_From_int((int)(SICONOS_FRICTION_3D_INTERNAL_ERROR_STRATEGY_ADAPTIVE)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_INTERNAL_ERROR_STRATEGY_GIVEN_VALUE",SWIG_From_int((int)(SICONOS_FRICTION_3D_INTERNAL_ERROR_STRATEGY_GIVEN_VALUE)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_INTERNAL_ERROR_STRATEGY_ADAPTIVE_N_CONTACT",SWIG_From_int((int)(SICONOS_FRICTION_3D_INTERNAL_ERROR_STRATEGY_ADAPTIVE_N_CONTACT)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_DPARAM_INTERNAL_ERROR_RATIO",SWIG_From_int((int)(SICONOS_FRICTION_3D_DPARAM_INTERNAL_ERROR_RATIO)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSGS_RELAXATION",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSGS_RELAXATION)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSGS_SHUFFLE",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSGS_SHUFFLE)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSGS_SHUFFLE_SEED",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSGS_SHUFFLE_SEED)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSGS_FILTER_LOCAL_SOLUTION",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSGS_FILTER_LOCAL_SOLUTION)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSGS_RELAXATION_VALUE",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSGS_RELAXATION_VALUE)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSGS_LOCALSOLVER_CONTACTNUMBER",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSGS_LOCALSOLVER_CONTACTNUMBER)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSGS_ERROR_EVALUATION_FULL",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSGS_ERROR_EVALUATION_FULL)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSGS_ERROR_EVALUATION_LIGHT",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSGS_ERROR_EVALUATION_LIGHT)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSGS_ERROR_EVALUATION_LIGHT_WITH_FULL_FINAL",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSGS_ERROR_EVALUATION_LIGHT_WITH_FULL_FINAL)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSGS_ERROR_EVALUATION_ADAPTIVE",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSGS_ERROR_EVALUATION_ADAPTIVE)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSGS_SHUFFLE_FALSE",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSGS_SHUFFLE_FALSE)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSGS_SHUFFLE_TRUE",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSGS_SHUFFLE_TRUE)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSGS_SHUFFLE_TRUE_EACH_LOOP",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSGS_SHUFFLE_TRUE_EACH_LOOP)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSGS_RELAXATION_FALSE",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSGS_RELAXATION_FALSE)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSGS_RELAXATION_TRUE",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSGS_RELAXATION_TRUE)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSGS_FILTER_LOCAL_SOLUTION_FALSE",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSGS_FILTER_LOCAL_SOLUTION_FALSE)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSGS_FILTER_LOCAL_SOLUTION_TRUE",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSGS_FILTER_LOCAL_SOLUTION_TRUE)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSN_RHO_STRATEGY",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSN_RHO_STRATEGY)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSN_FORMULATION",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSN_FORMULATION)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSN_LINESEARCH",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSN_LINESEARCH)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSN_LINESEARCH_MAXITER",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSN_LINESEARCH_MAXITER)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSN_HYBRID_STRATEGY",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSN_HYBRID_STRATEGY)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSN_HYBRID_MAX_LOOP",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSN_HYBRID_MAX_LOOP)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSN_HYBRID_MAX_ITER",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSN_HYBRID_MAX_ITER)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSN_MEMORY_ALLOCATION",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSN_MEMORY_ALLOCATION)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSN_MPI_COM",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSN_MPI_COM)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSN_RHO",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSN_RHO)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSN_FORMULATION_RHO_STRATEGY_CONSTANT",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSN_FORMULATION_RHO_STRATEGY_CONSTANT)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSN_FORMULATION_RHO_STRATEGY_SPECTRAL_NORM",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSN_FORMULATION_RHO_STRATEGY_SPECTRAL_NORM)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSN_FORMULATION_RHO_STRATEGY_SPLIT_SPECTRAL_NORM_COND",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSN_FORMULATION_RHO_STRATEGY_SPLIT_SPECTRAL_NORM_COND)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSN_FORMULATION_RHO_STRATEGY_SPLIT_SPECTRAL_NORM",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSN_FORMULATION_RHO_STRATEGY_SPLIT_SPECTRAL_NORM)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSN_FORMULATION_RHO_STRATEGY_ADAPTIVE",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSN_FORMULATION_RHO_STRATEGY_ADAPTIVE)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSN_FORMULATION_ALARTCURNIER_STD",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSN_FORMULATION_ALARTCURNIER_STD)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSN_FORMULATION_JEANMOREAU_STD",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSN_FORMULATION_JEANMOREAU_STD)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSN_FORMULATION_ALARTCURNIER_GENERATED",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSN_FORMULATION_ALARTCURNIER_GENERATED)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSN_FORMULATION_JEANMOREAU_GENERATED",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSN_FORMULATION_JEANMOREAU_GENERATED)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSN_FORMULATION_NULL",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSN_FORMULATION_NULL)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSN_LINESEARCH_GOLDSTEINPRICE",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSN_LINESEARCH_GOLDSTEINPRICE)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSN_LINESEARCH_ARMIJO",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSN_LINESEARCH_ARMIJO)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSN_LINESEARCH_NO",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSN_LINESEARCH_NO)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSN_HYBRID_STRATEGY_NO",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSN_HYBRID_STRATEGY_NO)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSN_HYBRID_STRATEGY_PLI_NSN_LOOP",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSN_HYBRID_STRATEGY_PLI_NSN_LOOP)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSN_HYBRID_STRATEGY_NSN_AND_PLI_NSN_LOOP",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSN_HYBRID_STRATEGY_NSN_AND_PLI_NSN_LOOP)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_NSN_HYBRID_STRATEGY_VI_EG_NSN",SWIG_From_int((int)(SICONOS_FRICTION_3D_NSN_HYBRID_STRATEGY_VI_EG_NSN)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_FP_ERROR_STRATEGY",SWIG_From_int((int)(SICONOS_FRICTION_3D_FP_ERROR_STRATEGY)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_PROXIMAL_IPARAM_CUMULATIVE_ITER_DONE",SWIG_From_int((int)(SICONOS_FRICTION_3D_PROXIMAL_IPARAM_CUMULATIVE_ITER_DONE)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_PROXIMAL_IPARAM_RELAXATION",SWIG_From_int((int)(SICONOS_FRICTION_3D_PROXIMAL_IPARAM_RELAXATION)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_PROXIMAL_IPARAM_STRATEGY",SWIG_From_int((int)(SICONOS_FRICTION_3D_PROXIMAL_IPARAM_STRATEGY)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_PROXIMAL_DPARAM_ALPHA",SWIG_From_int((int)(SICONOS_FRICTION_3D_PROXIMAL_DPARAM_ALPHA)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_PROXIMAL_DPARAM_SIGMA",SWIG_From_int((int)(SICONOS_FRICTION_3D_PROXIMAL_DPARAM_SIGMA)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_PROXIMAL_DPARAM_NU",SWIG_From_int((int)(SICONOS_FRICTION_3D_PROXIMAL_DPARAM_NU)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_PROXIMAL_DPARAM_RELAXATION",SWIG_From_int((int)(SICONOS_FRICTION_3D_PROXIMAL_DPARAM_RELAXATION)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_PROXIMAL_PROX",SWIG_From_int((int)(SICONOS_FRICTION_3D_PROXIMAL_PROX)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_PROXIMAL_REGULARIZATION",SWIG_From_int((int)(SICONOS_FRICTION_3D_PROXIMAL_REGULARIZATION)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_ADMM_IPARAM_RHO_STRATEGY",SWIG_From_int((int)(SICONOS_FRICTION_3D_ADMM_IPARAM_RHO_STRATEGY)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_ADMM_IPARAM_ACCELERATION",SWIG_From_int((int)(SICONOS_FRICTION_3D_ADMM_IPARAM_ACCELERATION)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_ADMM_IPARAM_SYMMETRY",SWIG_From_int((int)(SICONOS_FRICTION_3D_ADMM_IPARAM_SYMMETRY)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_ADMM_IPARAM_SPARSE_STORAGE",SWIG_From_int((int)(SICONOS_FRICTION_3D_ADMM_IPARAM_SPARSE_STORAGE)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_ADMM_RHO",SWIG_From_int((int)(SICONOS_FRICTION_3D_ADMM_RHO)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_ADMM_RESTART_ETA",SWIG_From_int((int)(SICONOS_FRICTION_3D_ADMM_RESTART_ETA)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_ADMM_BALANCING_RESIDUAL_TAU",SWIG_From_int((int)(SICONOS_FRICTION_3D_ADMM_BALANCING_RESIDUAL_TAU)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_ADMM_BALANCING_RESIDUAL_PHI",SWIG_From_int((int)(SICONOS_FRICTION_3D_ADMM_BALANCING_RESIDUAL_PHI)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_ADMM_NO_ACCELERATION",SWIG_From_int((int)(SICONOS_FRICTION_3D_ADMM_NO_ACCELERATION)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_ADMM_ACCELERATION",SWIG_From_int((int)(SICONOS_FRICTION_3D_ADMM_ACCELERATION)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_ADMM_ACCELERATION_AND_RESTART",SWIG_From_int((int)(SICONOS_FRICTION_3D_ADMM_ACCELERATION_AND_RESTART)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_ADMM_CHECK_SYMMETRY",SWIG_From_int((int)(SICONOS_FRICTION_3D_ADMM_CHECK_SYMMETRY)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_ADMM_FORCED_SYMMETRY",SWIG_From_int((int)(SICONOS_FRICTION_3D_ADMM_FORCED_SYMMETRY)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_ADMM_FORCED_ASYMMETRY",SWIG_From_int((int)(SICONOS_FRICTION_3D_ADMM_FORCED_ASYMMETRY)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_ADMM_KEEP_STORAGE",SWIG_From_int((int)(SICONOS_FRICTION_3D_ADMM_KEEP_STORAGE)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_ADMM_FORCED_SPARSE_STORAGE",SWIG_From_int((int)(SICONOS_FRICTION_3D_ADMM_FORCED_SPARSE_STORAGE)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_ADMM_RHO_STRATEGY_CONSTANT",SWIG_From_int((int)(SICONOS_FRICTION_3D_ADMM_RHO_STRATEGY_CONSTANT)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_ADMM_RHO_STRATEGY_NORM_INF",SWIG_From_int((int)(SICONOS_FRICTION_3D_ADMM_RHO_STRATEGY_NORM_INF)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_ADMM_RHO_STRATEGY_RESIDUAL_BALANCING",SWIG_From_int((int)(SICONOS_FRICTION_3D_ADMM_RHO_STRATEGY_RESIDUAL_BALANCING)));
  SWIG_Python_SetConstant(d, "SICONOS_FRICTION_3D_ADMM_RHO_STRATEGY_SCALED_RESIDUAL_BALANCING",SWIG_From_int((int)(SICONOS_FRICTION_3D_ADMM_RHO_STRATEGY_SCALED_RESIDUAL_BALANCING)));
  SWIG_Python_SetConstant(d, "SICONOS_MCP_FB",SWIG_From_int((int)(SICONOS_MCP_FB)));
  SWIG_Python_SetConstant(d, "SICONOS_MCP_NEWTON_FBLSA",SWIG_From_int((int)(SICONOS_MCP_NEWTON_FBLSA)));
  SWIG_Python_SetConstant(d, "SICONOS_MCP_NEWTON_MINFBLSA",SWIG_From_int((int)(SICONOS_MCP_NEWTON_MINFBLSA)));
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_MCP_FB_STR",Swig_var_SICONOS_MCP_FB_STR_get, Swig_var_SICONOS_MCP_FB_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_MCP_NEWTON_FBLSA_STR",Swig_var_SICONOS_MCP_NEWTON_FBLSA_STR_get, Swig_var_SICONOS_MCP_NEWTON_FBLSA_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_MCP_NEWTON_MINFBLSA_STR",Swig_var_SICONOS_MCP_NEWTON_MINFBLSA_STR_get, Swig_var_SICONOS_MCP_NEWTON_MINFBLSA_STR_set);
  SWIG_Python_SetConstant(d, "SICONOS_NCP_NEWTON_FBLSA",SWIG_From_int((int)(SICONOS_NCP_NEWTON_FBLSA)));
  SWIG_Python_SetConstant(d, "SICONOS_NCP_NEWTON_MINFBLSA",SWIG_From_int((int)(SICONOS_NCP_NEWTON_MINFBLSA)));
  SWIG_Python_SetConstant(d, "SICONOS_NCP_PATHSEARCH",SWIG_From_int((int)(SICONOS_NCP_PATHSEARCH)));
  SWIG_Python_SetConstant(d, "SICONOS_NCP_PATH",SWIG_From_int((int)(SICONOS_NCP_PATH)));
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_NCP_NEWTON_FBLSA_STR",Swig_var_SICONOS_NCP_NEWTON_FBLSA_STR_get, Swig_var_SICONOS_NCP_NEWTON_FBLSA_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_NCP_NEWTON_MINFBLSA_STR",Swig_var_SICONOS_NCP_NEWTON_MINFBLSA_STR_get, Swig_var_SICONOS_NCP_NEWTON_MINFBLSA_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_NCP_PATHSEARCH_STR",Swig_var_SICONOS_NCP_PATHSEARCH_STR_get, Swig_var_SICONOS_NCP_PATHSEARCH_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_NCP_PATH_STR",Swig_var_SICONOS_NCP_PATH_STR_get, Swig_var_SICONOS_NCP_PATH_STR_set);
  SWIG_Python_SetConstant(d, "SICONOS_VI_EG",SWIG_From_int((int)(SICONOS_VI_EG)));
  SWIG_Python_SetConstant(d, "SICONOS_VI_FPP",SWIG_From_int((int)(SICONOS_VI_FPP)));
  SWIG_Python_SetConstant(d, "SICONOS_VI_HP",SWIG_From_int((int)(SICONOS_VI_HP)));
  SWIG_Python_SetConstant(d, "SICONOS_VI_BOX_QI",SWIG_From_int((int)(SICONOS_VI_BOX_QI)));
  SWIG_Python_SetConstant(d, "SICONOS_VI_BOX_AVI_LSA",SWIG_From_int((int)(SICONOS_VI_BOX_AVI_LSA)));
  SWIG_Python_SetConstant(d, "SICONOS_VI_BOX_PATH",SWIG_From_int((int)(SICONOS_VI_BOX_PATH)));
  SWIG_Python_SetConstant(d, "SICONOS_VI_IPARAM_LINESEARCH_METHOD",SWIG_From_int((int)(SICONOS_VI_IPARAM_LINESEARCH_METHOD)));
  SWIG_Python_SetConstant(d, "SICONOS_VI_IPARAM_ERROR_EVALUATION",SWIG_From_int((int)(SICONOS_VI_IPARAM_ERROR_EVALUATION)));
  SWIG_Python_SetConstant(d, "SICONOS_VI_IPARAM_ERROR_EVALUATION_FREQUENCY",SWIG_From_int((int)(SICONOS_VI_IPARAM_ERROR_EVALUATION_FREQUENCY)));
  SWIG_Python_SetConstant(d, "SICONOS_VI_EG_DPARAM_RHO",SWIG_From_int((int)(SICONOS_VI_EG_DPARAM_RHO)));
  SWIG_Python_SetConstant(d, "SICONOS_VI_EG_DPARAM_LS_TAU",SWIG_From_int((int)(SICONOS_VI_EG_DPARAM_LS_TAU)));
  SWIG_Python_SetConstant(d, "SICONOS_VI_EG_DPARAM_LS_TAUINV",SWIG_From_int((int)(SICONOS_VI_EG_DPARAM_LS_TAUINV)));
  SWIG_Python_SetConstant(d, "SICONOS_VI_EG_DPARAM_LS_L",SWIG_From_int((int)(SICONOS_VI_EG_DPARAM_LS_L)));
  SWIG_Python_SetConstant(d, "SICONOS_VI_EG_DPARAM_LS_LMIN",SWIG_From_int((int)(SICONOS_VI_EG_DPARAM_LS_LMIN)));
  SWIG_Python_SetConstant(d, "SICONOS_VI_ERROR_EVALUATION_FULL",SWIG_From_int((int)(SICONOS_VI_ERROR_EVALUATION_FULL)));
  SWIG_Python_SetConstant(d, "SICONOS_VI_ERROR_EVALUATION_LIGHT_WITH_FULL_FINAL",SWIG_From_int((int)(SICONOS_VI_ERROR_EVALUATION_LIGHT_WITH_FULL_FINAL)));
  SWIG_Python_SetConstant(d, "SICONOS_VI_ERROR_EVALUATION_LIGHT",SWIG_From_int((int)(SICONOS_VI_ERROR_EVALUATION_LIGHT)));
  SWIG_Python_SetConstant(d, "SICONOS_VI_ERROR_EVALUATION_ADAPTIVE",SWIG_From_int((int)(SICONOS_VI_ERROR_EVALUATION_ADAPTIVE)));
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_VI_EG_STR",Swig_var_SICONOS_VI_EG_STR_get, Swig_var_SICONOS_VI_EG_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_VI_FPP_STR",Swig_var_SICONOS_VI_FPP_STR_get, Swig_var_SICONOS_VI_FPP_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_VI_HP_STR",Swig_var_SICONOS_VI_HP_STR_get, Swig_var_SICONOS_VI_HP_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_VI_BOX_QI_STR",Swig_var_SICONOS_VI_BOX_QI_STR_get, Swig_var_SICONOS_VI_BOX_QI_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_VI_BOX_AVI_LSA_STR",Swig_var_SICONOS_VI_BOX_AVI_LSA_STR_get, Swig_var_SICONOS_VI_BOX_AVI_LSA_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_VI_BOX_PATH_STR",Swig_var_SICONOS_VI_BOX_PATH_STR_get, Swig_var_SICONOS_VI_BOX_PATH_STR_set);
  SWIG_Python_SetConstant(d, "SICONOS_GENERIC_MECHANICAL_NSGS",SWIG_From_int((int)(SICONOS_GENERIC_MECHANICAL_NSGS)));
  SWIG_Python_SetConstant(d, "ENV_IS_C_STRUCT",SWIG_From_int((int)(ENV_IS_C_STRUCT)));
  SWIG_Python_SetConstant(d, "ENV_IS_UNKNOWN",SWIG_From_int((int)(ENV_IS_UNKNOWN)));
  SWIG_Python_SetConstant(d, "ENV_IS_PYTHON_CLASS",SWIG_From_int((int)(ENV_IS_PYTHON_CLASS)));
  SWIG_Python_SetConstant(d, "ENV_IS_PYTHON_FUNCTIONS",SWIG_From_int((int)(ENV_IS_PYTHON_FUNCTIONS)));
  SWIG_Python_SetConstant(d, "ENV_IS_PYTHON_FUNCTIONS_WITH_PROJ",SWIG_From_int((int)(ENV_IS_PYTHON_FUNCTIONS_WITH_PROJ)));
  SWIG_Python_SetConstant(d, "ENV_IS_MATLAB_FUNCTION_HANDLES",SWIG_From_int((int)(ENV_IS_MATLAB_FUNCTION_HANDLES)));
  SWIG_Python_SetConstant(d, "ENV_IS_MATLAB_FUNCTION_NAMES",SWIG_From_int((int)(ENV_IS_MATLAB_FUNCTION_NAMES)));
  SWIG_Python_SetConstant(d, "SICONOS_CONVEXQP_PG",SWIG_From_int((int)(SICONOS_CONVEXQP_PG)));
  SWIG_Python_SetConstant(d, "SICONOS_CONVEXQP_VI_FPP",SWIG_From_int((int)(SICONOS_CONVEXQP_VI_FPP)));
  SWIG_Python_SetConstant(d, "SICONOS_CONVEXQP_VI_EG",SWIG_From_int((int)(SICONOS_CONVEXQP_VI_EG)));
  SWIG_Python_SetConstant(d, "SICONOS_CONVEXQP_ADMM",SWIG_From_int((int)(SICONOS_CONVEXQP_ADMM)));
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_CONVEXQP_PG_STR",Swig_var_SICONOS_CONVEXQP_PG_STR_get, Swig_var_SICONOS_CONVEXQP_PG_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_CONVEXQP_VI_FPP_STR",Swig_var_SICONOS_CONVEXQP_VI_FPP_STR_get, Swig_var_SICONOS_CONVEXQP_VI_FPP_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_CONVEXQP_VI_EG_STR",Swig_var_SICONOS_CONVEXQP_VI_EG_STR_get, Swig_var_SICONOS_CONVEXQP_VI_EG_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_CONVEXQP_ADMM_STR",Swig_var_SICONOS_CONVEXQP_ADMM_STR_get, Swig_var_SICONOS_CONVEXQP_ADMM_STR_set);
  SWIG_Python_SetConstant(d, "SICONOS_CONVEXQP_PGOC_LINESEARCH_MAXITER",SWIG_From_int((int)(SICONOS_CONVEXQP_PGOC_LINESEARCH_MAXITER)));
  SWIG_Python_SetConstant(d, "SICONOS_CONVEXQP_PGOC_RHO",SWIG_From_int((int)(SICONOS_CONVEXQP_PGOC_RHO)));
  SWIG_Python_SetConstant(d, "SICONOS_CONVEXQP_PGOC_RHOMIN",SWIG_From_int((int)(SICONOS_CONVEXQP_PGOC_RHOMIN)));
  SWIG_Python_SetConstant(d, "SICONOS_CONVEXQP_PGOC_LINESEARCH_MU",SWIG_From_int((int)(SICONOS_CONVEXQP_PGOC_LINESEARCH_MU)));
  SWIG_Python_SetConstant(d, "SICONOS_CONVEXQP_PGOC_LINESEARCH_TAU",SWIG_From_int((int)(SICONOS_CONVEXQP_PGOC_LINESEARCH_TAU)));
  SWIG_Python_SetConstant(d, "SICONOS_CONVEXQP_ADMM_IPARAM_RHO_STRATEGY",SWIG_From_int((int)(SICONOS_CONVEXQP_ADMM_IPARAM_RHO_STRATEGY)));
  SWIG_Python_SetConstant(d, "SICONOS_CONVEXQP_ADMM_IPARAM_ACCELERATION",SWIG_From_int((int)(SICONOS_CONVEXQP_ADMM_IPARAM_ACCELERATION)));
  SWIG_Python_SetConstant(d, "SICONOS_CONVEXQP_ADMM_RHO",SWIG_From_int((int)(SICONOS_CONVEXQP_ADMM_RHO)));
  SWIG_Python_SetConstant(d, "SICONOS_CONVEXQP_ADMM_RESTART_ETA",SWIG_From_int((int)(SICONOS_CONVEXQP_ADMM_RESTART_ETA)));
  SWIG_Python_SetConstant(d, "SICONOS_CONVEXQP_ADMM_NO_ACCELERATION",SWIG_From_int((int)(SICONOS_CONVEXQP_ADMM_NO_ACCELERATION)));
  SWIG_Python_SetConstant(d, "SICONOS_CONVEXQP_ADMM_ACCELERATION",SWIG_From_int((int)(SICONOS_CONVEXQP_ADMM_ACCELERATION)));
  SWIG_Python_SetConstant(d, "SICONOS_CONVEXQP_ADMM_ACCELERATION_AND_RESTART",SWIG_From_int((int)(SICONOS_CONVEXQP_ADMM_ACCELERATION_AND_RESTART)));
  SWIG_Python_SetConstant(d, "SICONOS_CONVEXQP_RHO_STRATEGY_CONSTANT",SWIG_From_int((int)(SICONOS_CONVEXQP_RHO_STRATEGY_CONSTANT)));
  SWIG_Python_SetConstant(d, "SICONOS_CONVEXQP_RHO_STRATEGY_ADAPTIVE",SWIG_From_int((int)(SICONOS_CONVEXQP_RHO_STRATEGY_ADAPTIVE)));
  SWIG_Python_SetConstant(d, "SICONOS_SOCLCP_NSGS",SWIG_From_int((int)(SICONOS_SOCLCP_NSGS)));
  SWIG_Python_SetConstant(d, "SICONOS_SOCLCP_VI_FPP",SWIG_From_int((int)(SICONOS_SOCLCP_VI_FPP)));
  SWIG_Python_SetConstant(d, "SICONOS_SOCLCP_VI_EG",SWIG_From_int((int)(SICONOS_SOCLCP_VI_EG)));
  SWIG_Python_SetConstant(d, "SICONOS_SOCLCP_ProjectionOnCone",SWIG_From_int((int)(SICONOS_SOCLCP_ProjectionOnCone)));
  SWIG_Python_SetConstant(d, "SICONOS_SOCLCP_ProjectionOnConeWithLocalIteration",SWIG_From_int((int)(SICONOS_SOCLCP_ProjectionOnConeWithLocalIteration)));
  SWIG_Python_SetConstant(d, "SICONOS_SOCLCP_projectionOnConeWithRegularization",SWIG_From_int((int)(SICONOS_SOCLCP_projectionOnConeWithRegularization)));
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_SOCLCP_NSGS_STR",Swig_var_SICONOS_SOCLCP_NSGS_STR_get, Swig_var_SICONOS_SOCLCP_NSGS_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_SOCLCP_NSGSV_STR",Swig_var_SICONOS_SOCLCP_NSGSV_STR_get, Swig_var_SICONOS_SOCLCP_NSGSV_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_SOCLCP_PROX_STR",Swig_var_SICONOS_SOCLCP_PROX_STR_get, Swig_var_SICONOS_SOCLCP_PROX_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_SOCLCP_TFP_STR",Swig_var_SICONOS_SOCLCP_TFP_STR_get, Swig_var_SICONOS_SOCLCP_TFP_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_SOCLCP_NSN_AC_STR",Swig_var_SICONOS_SOCLCP_NSN_AC_STR_get, Swig_var_SICONOS_SOCLCP_NSN_AC_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_SOCLCP_NSN_FB_STR",Swig_var_SICONOS_SOCLCP_NSN_FB_STR_get, Swig_var_SICONOS_SOCLCP_NSN_FB_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_SOCLCP_DSFP_STR",Swig_var_SICONOS_SOCLCP_DSFP_STR_get, Swig_var_SICONOS_SOCLCP_DSFP_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_SOCLCP_VI_EG_STR",Swig_var_SICONOS_SOCLCP_VI_EG_STR_get, Swig_var_SICONOS_SOCLCP_VI_EG_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_SOCLCP_VI_FPP_STR",Swig_var_SICONOS_SOCLCP_VI_FPP_STR_get, Swig_var_SICONOS_SOCLCP_VI_FPP_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_SOCLCP_EG_STR",Swig_var_SICONOS_SOCLCP_EG_STR_get, Swig_var_SICONOS_SOCLCP_EG_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_SOCLCP_FPP_STR",Swig_var_SICONOS_SOCLCP_FPP_STR_get, Swig_var_SICONOS_SOCLCP_FPP_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_SOCLCP_HP_STR",Swig_var_SICONOS_SOCLCP_HP_STR_get, Swig_var_SICONOS_SOCLCP_HP_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_SOCLCP_NCPGlockerFBFixedPoint_STR",Swig_var_SICONOS_SOCLCP_NCPGlockerFBFixedPoint_STR_get, Swig_var_SICONOS_SOCLCP_NCPGlockerFBFixedPoint_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_SOCLCP_AlartCurnierNewton_STR",Swig_var_SICONOS_SOCLCP_AlartCurnierNewton_STR_get, Swig_var_SICONOS_SOCLCP_AlartCurnierNewton_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_SOCLCP_DampedAlartCurnierNewton_STR",Swig_var_SICONOS_SOCLCP_DampedAlartCurnierNewton_STR_get, Swig_var_SICONOS_SOCLCP_DampedAlartCurnierNewton_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_SOCLCP_NCPGlockerFBNewton_STR",Swig_var_SICONOS_SOCLCP_NCPGlockerFBNewton_STR_get, Swig_var_SICONOS_SOCLCP_NCPGlockerFBNewton_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_SOCLCP_ProjectionOnConeWithDiagonalization_STR",Swig_var_SICONOS_SOCLCP_ProjectionOnConeWithDiagonalization_STR_get, Swig_var_SICONOS_SOCLCP_ProjectionOnConeWithDiagonalization_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_SOCLCP_ProjectionOnCone_STR",Swig_var_SICONOS_SOCLCP_ProjectionOnCone_STR_get, Swig_var_SICONOS_SOCLCP_ProjectionOnCone_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_SOCLCP_ProjectionOnConeWithLocalIteration_STR",Swig_var_SICONOS_SOCLCP_ProjectionOnConeWithLocalIteration_STR_get, Swig_var_SICONOS_SOCLCP_ProjectionOnConeWithLocalIteration_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_SOCLCP_projectionOnConeWithRegularization_STR",Swig_var_SICONOS_SOCLCP_projectionOnConeWithRegularization_STR_get, Swig_var_SICONOS_SOCLCP_projectionOnConeWithRegularization_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_SOCLCP_NCPGlockerFBPATH_STR",Swig_var_SICONOS_SOCLCP_NCPGlockerFBPATH_STR_get, Swig_var_SICONOS_SOCLCP_NCPGlockerFBPATH_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_SOCLCP_projectionOnCylinder_STR",Swig_var_SICONOS_SOCLCP_projectionOnCylinder_STR_get, Swig_var_SICONOS_SOCLCP_projectionOnCylinder_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_SOCLCP_ProjectionOnCone_velocity_STR",Swig_var_SICONOS_SOCLCP_ProjectionOnCone_velocity_STR_get, Swig_var_SICONOS_SOCLCP_ProjectionOnCone_velocity_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_SOCLCP_PGoC_STR",Swig_var_SICONOS_SOCLCP_PGoC_STR_get, Swig_var_SICONOS_SOCLCP_PGoC_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_SOCLCP_DeSaxceFixedPoint_STR",Swig_var_SICONOS_SOCLCP_DeSaxceFixedPoint_STR_get, Swig_var_SICONOS_SOCLCP_DeSaxceFixedPoint_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_SOCLCP_QUARTIC_STR",Swig_var_SICONOS_SOCLCP_QUARTIC_STR_get, Swig_var_SICONOS_SOCLCP_QUARTIC_STR_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"SICONOS_SOCLCP_QUARTIC_NU_STR",Swig_var_SICONOS_SOCLCP_QUARTIC_NU_STR_get, Swig_var_SICONOS_SOCLCP_QUARTIC_NU_STR_set);
  SWIG_Python_SetConstant(d, "GAMS_OPT_GENERAL",SWIG_From_int((int)(GAMS_OPT_GENERAL)));
  SWIG_Python_SetConstant(d, "GAMS_OPT_SOLVER",SWIG_From_int((int)(GAMS_OPT_SOLVER)));
#if PY_VERSION_HEX >= 0x03000000
  return m;
#else
  return;
#endif
}


//						VULNERABLE LINES

// 700,2;700,8

// 4232,8;4232,15

// 4233,8;4233,14

// 4235,6;4235,13

// 4236,6;4236,12

// 4272,10;4272,17

// 4276,10;4276,17

// 4278,8;4278,14

// 4284,8;4284,15

// 4285,8;4285,14

// 6006,6;6006,13

// 6012,6;6012,13

// 6098,6;6098,13

// 6104,6;6104,13

